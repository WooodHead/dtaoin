"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

var FatalError = require("../lib/errors.js").FatalError;
var prepackSources = require("../lib/prepack-node.js").prepackSources;

var Serializer = require("../lib/serializer/index.js").default;
var construct_realm = require("../lib/construct_realm.js").default;
var initializeGlobals = require("../lib/globals.js").default;
var util = require("util");
var chalk = require("chalk");
var path = require("path");
var fs = require("fs");
var vm = require("vm");
var os = require("os");
var minimist = require("minimist");
var EOL = os.EOL;

function search(dir, relative) {
  var tests = [];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = fs.readdirSync(dir)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var name = _step.value;

      var loc = path.join(dir, name);
      var stat = fs.statSync(loc);

      if (stat.isFile()) {
        tests.push({
          file: fs.readFileSync(loc, "utf8"),
          name: path.join(relative, name)
        });
      } else if (stat.isDirectory()) {
        tests = tests.concat(search(loc, path.join(relative, name)));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return tests;
}

var tests = search(__dirname + "/../test/serializer", "test/serializer");

function exec(code) {
  var script = new vm.Script("var global = this; var self = this; " + code + "; // keep newline here as code may end with comment\nreport(inspect());", { cachedDataProduced: false });

  var result = "";
  var logOutput = "";

  function write(prefix, values) {
    logOutput += "\n" + prefix + values.join("");
  }

  script.runInNewContext({
    setTimeout: setTimeout,
    setInterval: setInterval,
    clearTimeout: clearTimeout,
    clearInterval: clearInterval,
    report: function report(s) {
      result = s;
    },
    console: {
      log: function log() {
        for (var _len = arguments.length, s = Array(_len), _key = 0; _key < _len; _key++) {
          s[_key] = arguments[_key];
        }

        write("", s);
      },
      warn: function warn() {
        for (var _len2 = arguments.length, s = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          s[_key2] = arguments[_key2];
        }

        write("WARN:", s);
      },
      error: function error() {
        for (var _len3 = arguments.length, s = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          s[_key3] = arguments[_key3];
        }

        write("ERROR:", s);
      }
    }
  });
  return result + logOutput;
}

function runTest(name, code, options, args) {
  console.log(chalk.inverse(name) + " " + util.inspect(options));
  var compatibility = code.includes("// jsc") ? "jsc-600-1-4-17" : undefined;
  var initializeMoreModules = code.includes("// initialize more modules");
  var delayUnsupportedRequires = code.includes("// delay unsupported requires");
  var functionCloneCountMatch = code.match(/\/\/ serialized function clone count: (\d+)/);
  options = Object.assign({}, options, {
    compatibility: compatibility,
    debugNames: args.debugNames,
    initializeMoreModules: initializeMoreModules,
    delayUnsupportedRequires: delayUnsupportedRequires,
    errorHandler: function errorHandler(diag) {
      return "Fail";
    },
    internalDebug: true,
    serialize: true,
    uniqueSuffix: ""
  });
  if (code.includes("// inline expression")) options.inlineExpressions = true;
  if (code.includes("// additional functions")) options.additionalFunctions = ["additional1", "additional2"];
  if (code.includes("// throws introspection error")) {
    try {
      var realmOptions = { serialize: true, compatibility: compatibility, uniqueSuffix: "", errorHandler: function errorHandler(diag) {
          return "Fail";
        } };
      var realm = construct_realm(realmOptions);
      initializeGlobals(realm);
      var serializerOptions = {
        initializeMoreModules: initializeMoreModules,
        delayUnsupportedRequires: delayUnsupportedRequires,
        internalDebug: true,
        additionalFunctions: options.additionalFunctions
      };
      var serializer = new Serializer(realm, serializerOptions);
      var sources = [{ filePath: name, fileContents: code }];
      var serialized = serializer.init(sources, false);
      if (!serialized) {
        console.log(chalk.red("Error during serialization"));
      } else {
        console.log(chalk.red("Test should have caused introspection error!"));
      }
    } catch (err) {
      if (err instanceof FatalError) return true;
      console.log("Test should have caused introspection error, but instead caused a different internal error!");
      console.log(err);
    }
    return false;
  } else if (code.includes("// cannot serialize")) {
    try {
      prepackSources([{ filePath: name, fileContents: code, sourceMapContents: "" }], options);
    } catch (err) {
      if (err instanceof FatalError) {
        return true;
      }
    }
    console.log(chalk.red("Test should have caused error during serialization!"));
    return false;
  } else if (code.includes("// no effect")) {
    try {
      var _serialized = prepackSources([{ filePath: name, fileContents: code, sourceMapContents: "" }], options);
      if (!_serialized) {
        console.log(chalk.red("Error during serialization!"));
        return false;
      }
      if (!_serialized.code.trim()) {
        return true;
      }
      console.log(chalk.red("Generated code should be empty but isn't!"));
      console.log(chalk.underline("original code"));
      console.log(code);
      console.log(chalk.underline("generated code"));
      console.log(_serialized.code);
    } catch (err) {
      console.log(err);
    }
    return false;
  } else if (code.includes("// Copies of ")) {
    var marker = "// Copies of ";
    var searchStart = code.indexOf(marker);
    var searchEnd = code.indexOf(":", searchStart);
    var value = code.substring(searchStart + marker.length, searchEnd);
    var count = parseInt(code.substring(searchEnd + 1, code.indexOf("\n", searchStart)), 10);
    try {
      var _serialized2 = prepackSources([{ filePath: name, fileContents: code, sourceMapContents: "" }], options);
      if (!_serialized2) {
        console.log(chalk.red("Error during serialization!"));
        return false;
      }
      var regex = new RegExp(value, "gi");
      var matches = _serialized2.code.match(regex);
      if (!matches || matches.length !== count) {
        console.log(chalk.red("Wrong number of occurrances of " + value + " got " + (matches ? matches.length : 0) + " instead of " + count));
        return false;
      }
    } catch (err) {
      console.log(err);
      return false;
    }
    return true;
  } else {
    var expected = void 0,
        actual = void 0;
    var codeIterations = [];
    var markersToFind = [];
    var _arr = [[true, "// does contain:"], [false, "// does not contain:"]];
    for (var _i = 0; _i < _arr.length; _i++) {
      var _ref = _arr[_i];

      var _ref2 = _slicedToArray(_ref, 2);

      var positive = _ref2[0];
      var _marker = _ref2[1];

      if (code.includes(_marker)) {
        var _i4 = code.indexOf(_marker);
        var _value2 = code.substring(_i4 + _marker.length, code.indexOf("\n", _i4));
        markersToFind.push({ positive: positive, value: _value2, start: _i4 + _marker.length });
      }
    }
    var addedCode = "";
    var injectAtRuntime = "// add at runtime:";
    if (code.includes(injectAtRuntime)) {
      var i = code.indexOf(injectAtRuntime);
      addedCode = code.substring(i + injectAtRuntime.length, code.indexOf("\n", i));
    }
    var unique = 27277;
    var oldUniqueSuffix = "";
    try {
      expected = exec(addedCode + "\n(function () {" + code + " // keep newline here as code may end with comment\n}).call(this);");

      var _i2 = 0;
      var max = addedCode ? 1 : 4;
      var oldCode = code;
      var anyDelayedValues = false;
      for (; _i2 < max; _i2++) {
        var newUniqueSuffix = "_unique" + unique++;
        options.uniqueSuffix = newUniqueSuffix;
        var _serialized3 = prepackSources([{ filePath: name, fileContents: code, sourceMapContents: "" }], options);
        if (_serialized3.statistics && _serialized3.statistics.delayedValues > 0) anyDelayedValues = true;
        if (!_serialized3) {
          console.log(chalk.red("Error during serialization!"));
          break;
        }
        var newCode = _serialized3.code;
        codeIterations.push(newCode);
        if (args.verbose) console.log(newCode);
        var markersIssue = false;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = markersToFind[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _ref3 = _step2.value;
            var _positive = _ref3.positive,
                _value = _ref3.value,
                start = _ref3.start;

            var found = newCode.indexOf(_value, start) !== -1;
            if (found !== _positive) {
              console.log(chalk.red("Output " + (_positive ? "does not contain" : "contains") + " forbidden string: " + _value));
              markersIssue = true;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (markersIssue) break;
        actual = exec(addedCode + newCode);
        if (expected !== actual) {
          console.log(chalk.red("Output mismatch!"));
          break;
        }
        // Test the number of clone functions generated with the inital prepack call
        if (_i2 === 0 && functionCloneCountMatch) {
          var functionCount = parseInt(functionCloneCountMatch[1], 10);
          if (_serialized3.statistics && functionCount !== _serialized3.statistics.functionClones) {
            console.log(chalk.red("Code generation serialized an unexpected number of clone functions. Expected: " + functionCount + ", Got: " + _serialized3.statistics.functionClones));
            break;
          }
        }
        if (oldCode.replace(new RegExp(oldUniqueSuffix, "g"), "") === newCode.replace(new RegExp(newUniqueSuffix, "g"), "") || delayUnsupportedRequires) {
          // The generated code reached a fixed point!
          return true;
        }
        oldCode = newCode;
        oldUniqueSuffix = newUniqueSuffix;
      }
      if (_i2 === 1) return true;
      if (_i2 === max) {
        if (anyDelayedValues) {
          // TODO #835: Make delayed initializations logic more sophisticated in order to still reach a fixed point.
          return true;
        }
        console.log(chalk.red("Code generation did not reach fixed point after " + max + " iterations!"));
      }
    } catch (err) {
      console.log(err);
    }
    console.log(chalk.underline("original code"));
    console.log(code);
    console.log(chalk.underline("output of inspect() on original code"));
    console.log(expected);
    for (var _i3 = 0; _i3 < codeIterations.length; _i3++) {
      console.log(chalk.underline("generated code in iteration " + _i3));
      console.log(codeIterations[_i3]);
    }
    console.log(chalk.underline("output of inspect() on last generated code iteration"));
    console.log(actual);
    return false;
  }
}
function run(args) {
  var failed = 0;
  var passed = 0;
  var total = 0;

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = tests[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var test = _step3.value;

      // filter hidden files
      if (path.basename(test.name)[0] === ".") continue;
      if (test.name.endsWith("~")) continue;
      if (test.file.includes("// skip")) continue;
      //only run specific tests if desired
      if (!test.name.includes(args.filter)) continue;

      var _arr2 = [[false, false], [true, true]];
      for (var _i5 = 0; _i5 < _arr2.length; _i5++) {
        var _ref4 = _arr2[_i5];

        var _ref5 = _slicedToArray(_ref4, 2);

        var delayInitializations = _ref5[0];
        var inlineExpressions = _ref5[1];

        total++;
        var options = { delayInitializations: delayInitializations, inlineExpressions: inlineExpressions };
        if (runTest(test.name, test.file, options, args)) passed++;else failed++;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  console.log("Passed:", passed + "/" + total, (Math.round(passed / total * 100) || 0) + "%");
  return failed === 0;
}

// Object to store all command line arguments

var ProgramArgs = function ProgramArgs(debugNames, verbose, filter) {
  _classCallCheck(this, ProgramArgs);

  this.debugNames = debugNames;
  this.verbose = verbose;
  this.filter = filter; //lets user choose specific test files, runs all tests if omitted
};

// Execution of tests begins here


function main() {
  try {
    var args = argsParse();
    if (!run(args)) {
      process.exit(1);
    } else {
      return 0;
    }
  } catch (e) {
    if (e instanceof ArgsParseError) {
      console.log("Illegal argument: %s.\n%s", e.message, usage());
    } else {
      console.log(e);
    }
    return 1;
  }
  return 0;
}

// Helper function to provide correct usage information to the user
function usage() {
  return "Usage: " + process.argv[0] + " " + process.argv[1] + " " + EOL + "[--verbose] [--filter <string>]";
}

// NOTE: inheriting from Error does not seem to pass through an instanceof
// check

var ArgsParseError = function ArgsParseError(message) {
  _classCallCheck(this, ArgsParseError);

  this.message = message;
};

// Parses through the command line arguments and throws errors if usage is incorrect


function argsParse() {
  var parsedArgs = minimist(process.argv.slice(2), {
    string: ["filter"],
    boolean: ["debugNames", "verbose"],
    default: {
      debugNames: false,
      verbose: false,
      filter: ""
    }
  });
  if (typeof parsedArgs.debugNames !== "boolean") {
    throw new ArgsParseError("debugNames must be a boolean (either --debugNames or not)");
  }
  if (typeof parsedArgs.verbose !== "boolean") {
    throw new ArgsParseError("verbose must be a boolean (either --verbose or not)");
  }
  if (typeof parsedArgs.filter !== "string") {
    throw new ArgsParseError("filter must be a string (relative path from serialize directory) (--filter abstract/Residual.js)");
  }
  var programArgs = new ProgramArgs(parsedArgs.debugNames, parsedArgs.verbose, parsedArgs.filter);
  return programArgs;
}

main();
//# sourceMappingURL=test-runner.js.map