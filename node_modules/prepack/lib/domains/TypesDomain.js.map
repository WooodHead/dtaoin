{"version":3,"sources":["../../src/domains/TypesDomain.js"],"names":["TypesDomain","type","_type","undefined","t","getType","isTypeCompatibleWith","topVal","v1","v2","types","joinWith"],"mappings":";;;;;;qjBAAA;;;;;;;;;AAWA;;AASA;;;;;;;;AAEA;;IAEqBA,W;AACnB,uBAAYC,IAAZ,EAAuC;AAAA;;AACrC,6BAAUA,6BAAV,EAAkC,kCAAlC;AACA,SAAKC,KAAL,GAAaD,wBAAiBE,SAAjB,GAA6BF,IAA1C;AACD;;;;8BAMuB;AACtB,aAAO,KAAKC,KAAL,gBAAP;AACD;;;6BAUQE,C,EAA8B;AACrC,UAAIH,OAAO,KAAKI,OAAL,EAAX;AACA,UAAIJ,SAASG,CAAb,EAAgB,OAAO,IAAP;AAChB,UAAI,aAAME,oBAAN,CAA2BL,IAA3B,2BAAmD,aAAMK,oBAAN,CAA2BF,CAA3B,uBAAvD,EAAqG;AACnG,eAAO,IAAIJ,WAAJ,sBAAP;AACD;AACD,UAAI,aAAMM,oBAAN,CAA2BL,IAA3B,yBAAiD,aAAMK,oBAAN,CAA2BF,CAA3B,qBAArD,EAAiG;AAC/F,eAAO,IAAIJ,WAAJ,oBAAP;AACD;AACD,UAAI,aAAMM,oBAAN,CAA2BL,IAA3B,4BAAoD,aAAMK,oBAAN,CAA2BF,CAA3B,wBAAxD,EAAuG;AACrG,eAAO,IAAIJ,WAAJ,uBAAP;AACD;AACD,aAAOA,YAAYO,MAAnB;AACD;;;+BArBiBC,E,EAAkBC,E,EAA+B;AACjE,UAAID,OAAOL,SAAP,IAAoBM,OAAON,SAA/B,EAA0C,OAAO,IAAIH,WAAJ,uBAAP;AAC1C,UAAIQ,OAAOL,SAAP,IAAoBM,OAAON,SAA/B,EAA0C,OAAOH,YAAYO,MAAnB;AAC1C,UAAIC,kCAAJ,EAAiC,OAAOA,GAAGE,KAAH,CAASC,QAAT,CAAkBF,GAAGJ,OAAH,EAAlB,CAAP;AACjC,UAAII,kCAAJ,EAAiC,OAAOA,GAAGC,KAAH,CAASC,QAAT,CAAkBH,GAAGH,OAAH,EAAlB,CAAP;AACjC,aAAO,IAAIL,WAAJ,CAAgBQ,GAAGH,OAAH,EAAhB,EAA8BM,QAA9B,CAAuCF,GAAGJ,OAAH,EAAvC,CAAP;AACD;;;;;;AApBkBL,W,CAMZO,M,GAAsB,IAAIP,WAAJ,CAAgBG,SAAhB,C;kBANVH,W","file":"TypesDomain.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  AbstractValue,\n  ConcreteValue,\n  FunctionValue,\n  ObjectValue,\n  PrimitiveValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\n\n/* An abstract domain for the type of value a variable might have.  */\n\nexport default class TypesDomain {\n  constructor(type: void | typeof Value) {\n    invariant(type !== ConcreteValue, \"Concrete values must be specific\");\n    this._type = type === Value ? undefined : type;\n  }\n\n  static topVal: TypesDomain = new TypesDomain(undefined);\n\n  _type: void | typeof Value;\n\n  getType(): typeof Value {\n    return this._type || Value;\n  }\n\n  static joinValues(v1: void | Value, v2: void | Value): TypesDomain {\n    if (v1 === undefined && v2 === undefined) return new TypesDomain(UndefinedValue);\n    if (v1 === undefined || v2 === undefined) return TypesDomain.topVal;\n    if (v1 instanceof AbstractValue) return v1.types.joinWith(v2.getType());\n    if (v2 instanceof AbstractValue) return v2.types.joinWith(v1.getType());\n    return new TypesDomain(v1.getType()).joinWith(v2.getType());\n  }\n\n  joinWith(t: typeof Value): TypesDomain {\n    let type = this.getType();\n    if (type === t) return this;\n    if (Value.isTypeCompatibleWith(type, FunctionValue) && Value.isTypeCompatibleWith(t, FunctionValue)) {\n      return new TypesDomain(FunctionValue);\n    }\n    if (Value.isTypeCompatibleWith(type, ObjectValue) && Value.isTypeCompatibleWith(t, ObjectValue)) {\n      return new TypesDomain(ObjectValue);\n    }\n    if (Value.isTypeCompatibleWith(type, PrimitiveValue) && Value.isTypeCompatibleWith(t, PrimitiveValue)) {\n      return new TypesDomain(PrimitiveValue);\n    }\n    return TypesDomain.topVal;\n  }\n}\n"]}