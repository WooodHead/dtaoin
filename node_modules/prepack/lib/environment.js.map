{"version":3,"sources":["../src/environment.js"],"names":["canBecomeAnObject","t","sourceMap","require","EnvironmentRecord","realm","isReadOnly","DeclarativeEnvironmentRecord","bindings","Object","create","N","envRec","D","recordModifiedBinding","initialized","mutable","deletable","intrinsics","undefined","S","strict","V","binding","value","empty","createErrorThrowCompletion","ReferenceError","CreateMutableBinding","InitializeBinding","TypeError","ObjectEnvironmentRecord","obj","object","foundBinding","withEnvironment","unscopables","SymbolUnscopables","blocked","configValue","writable","enumerable","configurable","SetMutableBinding","$Delete","FunctionEnvironmentRecord","$ThisBindingStatus","$ThisValue","$HomeObject","home","$GetPrototypeOf","GlobalEnvironmentRecord","DclRec","$DeclarativeRecord","HasBinding","ObjRec","$ObjectRecord","CreateImmutableBinding","GetBindingValue","DeleteBinding","globalObject","existingProp","status","varNames","$VarNames","indexOf","splice","$GlobalThisValue","varDeclaredNames","$GetOwnProperty","hasProperty","extensible","push","desc","ModuleEnvironmentRecord","LexicalEnvironment","globalAst","rvalue","globalValue","evaluate","ast","strictCode","metadata","partiallyEvaluateCompletion","result","partial_ast","partial_io","Reference","partiallyEvaluate","err","Error","evaluateCompletion","reportIntrospectionError","joinCondition","evaluateAbstract","constructor","name","sources","sourceType","asts","code","directives","source","node","fileContents","filePath","sourceMapContents","length","fixup_source_locations","fixup_filenames","concat","program","body","e","file","onParse","concatenateAndParse","context","lexicalEnvironment","variableEnvironment","pushContext","res","popContext","options","partialAST","partiallyEvaluateCompletionDeref","type","fileAst","prog","sourceMaps","filename","map","smc","SourceMapConsumer","loc","fixup","start","end","fixup_comments","leadingComments","innerComments","trailingComments","new_loc","new_pos","old_pos","originalPositionFor","line","column","comments","c","cloc","currentLocation","testTimeout","evaluator","evaluators","getRunningContext","savedCompletion","partialEvaluator","partialEvaluators","base","getType","refName","thisValue","referencedName","mightNotBeString"],"mappings":"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","file":"environment.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelNode,\n  BabelNodeComment,\n  BabelNodeFile,\n  BabelNodeLVal,\n  BabelNodePosition,\n  BabelNodeStatement,\n  BabelNodeSourceLocation,\n} from \"babel-types\";\nimport type { Realm } from \"./realm.js\";\nimport type { SourceFile, SourceMap, SourceType } from \"./types.js\";\n\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  NormalCompletion,\n  PossiblyNormalCompletion,\n  ThrowCompletion,\n} from \"./completions.js\";\nimport { FatalError } from \"./errors.js\";\nimport { defaultOptions } from \"./options\";\nimport type { PartialEvaluatorOptions } from \"./options\";\nimport { ExecutionContext } from \"./realm.js\";\nimport { Value } from \"./values/index.js\";\nimport {\n  AbstractValue,\n  NullValue,\n  SymbolValue,\n  BooleanValue,\n  FunctionValue,\n  NumberValue,\n  ObjectValue,\n  AbstractObjectValue,\n  StringValue,\n  UndefinedValue,\n} from \"./values/index.js\";\nimport generate from \"babel-generator\";\nimport parse from \"./utils/parse.js\";\nimport invariant from \"./invariant.js\";\nimport traverseFast from \"./utils/traverse-fast.js\";\nimport {\n  ToBooleanPartial,\n  HasProperty,\n  Get,\n  GetValue,\n  PutValue,\n  DefinePropertyOrThrow,\n  Set,\n  IsExtensible,\n  HasOwnProperty,\n  IsDataDescriptor,\n  ThrowIfMightHaveBeenDeleted,\n  composePossiblyNormalCompletions,\n  updatePossiblyNormalCompletionWithValue,\n} from \"./methods/index.js\";\nimport * as t from \"babel-types\";\n\nconst sourceMap = require(\"source-map\");\n\n// ECMA262 8.1.1\nexport class EnvironmentRecord {\n  realm: Realm;\n  isReadOnly: boolean;\n  $NewTarget: void | ObjectValue;\n\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.isReadOnly = false;\n  }\n\n  +HasBinding: (N: string) => boolean;\n  +CreateMutableBinding: (N: string, D: boolean) => Value;\n  +CreateImmutableBinding: (N: string, S: boolean) => Value;\n  +InitializeBinding: (N: string, V: Value) => Value;\n  +SetMutableBinding: (N: string, V: Value, S: boolean) => Value;\n  +GetBindingValue: (N: string, S: boolean) => Value;\n  +DeleteBinding: (N: string) => boolean;\n  +HasThisBinding: () => boolean;\n  +GetThisBinding: () => NullValue | ObjectValue | AbstractObjectValue | UndefinedValue;\n  +HasSuperBinding: () => boolean;\n  +WithBaseObject: () => Value;\n  +BindThisValue: (\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ) => NullValue | ObjectValue | AbstractObjectValue | UndefinedValue;\n}\n\nexport type Binding = {\n  value?: Value,\n  initialized?: boolean,\n  mutable?: boolean,\n  deletable?: boolean,\n};\n\n// ECMA262 8.1.1.1\nexport class DeclarativeEnvironmentRecord extends EnvironmentRecord {\n  constructor(realm: Realm) {\n    super(realm);\n    this.bindings = Object.create(null);\n  }\n\n  bindings: { [name: string]: Binding };\n\n  // ECMA262 8.1.1.1.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec has a binding for the name that is the value of N, return true.\n    if (envRec.bindings[N]) return true;\n\n    // 3. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n    this.bindings[N] = realm.recordModifiedBinding(\n      {\n        initialized: false,\n        mutable: true,\n        deletable: D,\n      },\n      envRec\n    );\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.\n    this.bindings[N] = realm.recordModifiedBinding(\n      {\n        initialized: false,\n        strict: S,\n        deletable: false,\n      },\n      envRec\n    );\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    invariant(binding && !binding.initialized, `shouldn't have the binding ${N}`);\n\n    // 3. Set the bound value for N in envRec to V.\n    this.realm.recordModifiedBinding(binding, envRec).value = V;\n\n    // 4. Record that the binding for N in envRec has been initialized.\n    binding.initialized = true;\n\n    // 5. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. If envRec does not have a binding for N, then\n    if (!binding) {\n      // a. If S is true, throw a ReferenceError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} not found`);\n      }\n\n      // b. Perform envRec.CreateMutableBinding(N, true).\n      envRec.CreateMutableBinding(N, true);\n\n      // c. Perform envRec.InitializeBinding(N, V).\n      envRec.InitializeBinding(N, V);\n\n      // d. Return NormalCompletion(empty).\n      return this.realm.intrinsics.empty;\n    }\n\n    // 3. If the binding for N in envRec is a strict binding, let S be true.\n    if (binding.strict) S = true;\n\n    // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} has not yet been initialized`);\n    } else if (binding.mutable) {\n      // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.\n      realm.recordModifiedBinding(binding, envRec).value = V;\n    } else {\n      // 6. Else,\n      // a. Assert: This is an attempt to change the value of an immutable binding.\n\n      // b. If S is true, throw a TypeError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"attempt to change immutable binding\");\n      }\n    }\n\n    // 7. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec has a binding for N.\n    invariant(binding, \"expected binding\");\n\n    // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return the value currently bound to N in envRec.\n    invariant(binding.value);\n    return binding.value;\n  }\n\n  // ECMA262 8.1.1.1.7\n  DeleteBinding(N: string): boolean {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec has a binding for the name that is the value of N.\n    invariant(envRec.bindings[N], \"expected binding to exist\");\n\n    // 3. If the binding for N in envRec cannot be deleted, return false.\n    if (!envRec.bindings[N].deletable) return false;\n\n    // 4. Remove the binding for N from envRec.\n    this.realm.recordModifiedBinding(envRec.bindings[N], envRec).value = undefined;\n    delete envRec.bindings[N];\n\n    // 5. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.1.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.2\nexport class ObjectEnvironmentRecord extends EnvironmentRecord {\n  object: ObjectValue | AbstractObjectValue;\n  withEnvironment: boolean;\n\n  constructor(realm: Realm, obj: ObjectValue | AbstractObjectValue) {\n    super(realm);\n    this.object = obj;\n  }\n\n  // ECMA262 8.1.1.2.1\n  HasBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = this.object;\n\n    // 3. Let foundBinding be ? HasProperty(bindings, N).\n    let foundBinding = HasProperty(realm, bindings, N);\n\n    // 4. If foundBinding is false, return false.\n    if (!foundBinding) return false;\n\n    // 5. If the withEnvironment flag of envRec is false, return true.\n    if (!envRec.withEnvironment) return true;\n\n    // 6. Let unscopables be ? Get(bindings, @@unscopables).\n    let unscopables = Get(realm, bindings, realm.intrinsics.SymbolUnscopables);\n\n    // 7. If Type(unscopables) is Object, then\n    if (unscopables instanceof ObjectValue || unscopables instanceof AbstractObjectValue) {\n      // a. Let blocked be ToBoolean(? Get(unscopables, N)).\n      let blocked = ToBooleanPartial(realm, Get(realm, unscopables, N));\n\n      // b. If blocked is true, return false.\n      if (blocked) return false;\n    }\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.2.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. If D is true, let configValue be true; otherwise let configValue be false.\n    let configValue = D ? true : false;\n\n    // 4. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: configValue}).\n    return new BooleanValue(\n      realm,\n      DefinePropertyOrThrow(realm, bindings, N, {\n        value: realm.intrinsics.undefined,\n        writable: true,\n        enumerable: true,\n        configurable: configValue,\n      })\n    );\n  }\n\n  // ECMA262 8.1.1.2.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    // The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.\n    invariant(false);\n  }\n\n  // ECMA262 8.1.1.2.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    // 3. Record that the binding for N in envRec has been initialized.\n\n    // 4. Return ? envRec.SetMutableBinding(N, V, false).\n    return envRec.SetMutableBinding(N, V, false);\n  }\n\n  // ECMA262 8.1.1.2.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? Set(bindings, N, V, S).\n    return new BooleanValue(realm, Set(realm, bindings, N, V, S));\n  }\n\n  // ECMA262 8.1.1.2.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Let value be ? HasProperty(bindings, N).\n    let value = HasProperty(realm, bindings, N);\n\n    // 4. If value is false, then\n    if (!value) {\n      // a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.\n      if (!S) {\n        return realm.intrinsics.undefined;\n      } else {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n    }\n\n    // 5. Return ? Get(bindings, N).\n    return Get(realm, bindings, N);\n  }\n\n  // ECMA262 8.1.1.2.7\n  DeleteBinding(N: string): boolean {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? bindings.[[Delete]](N).\n    return bindings.$Delete(N);\n  }\n\n  // ECMA262 8.1.1.2.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.10\n  WithBaseObject(): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.\n    if (envRec.withEnvironment) return envRec.object;\n\n    // 3. Otherwise, return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.3\nexport class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {\n  $ThisBindingStatus: \"lexical\" | \"initialized\" | \"uninitialized\";\n  $ThisValue: UndefinedValue | NullValue | ObjectValue | AbstractObjectValue;\n  $HomeObject: void | ObjectValue;\n  $FunctionObject: FunctionValue;\n\n  // ECMA262 8.1.1.3.1\n  BindThisValue(\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"initialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"initialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Set envRec.[[ThisValue]] to V.\n    envRec.$ThisValue = V;\n\n    // 5. Set envRec.[[ThisBindingStatus]] to \"initialized\".\n    envRec.$ThisBindingStatus = \"initialized\";\n\n    // 6. Return V.\n    return V;\n  }\n\n  // ECMA262 8.1.1.3.2\n  HasThisBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false; otherwise, return true.\n    return envRec.$ThisBindingStatus === \"lexical\" ? false : true;\n  }\n\n  // ECMA262 8.1.1.3.3\n  HasSuperBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false.\n    if (envRec.$ThisBindingStatus === \"lexical\") return false;\n\n    // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.\n    if (envRec.$HomeObject === undefined) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  // ECMA262 8.1.1.3.4\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"uninitialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"uninitialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return envRec.[[ThisValue]].\n    return envRec.$ThisValue;\n  }\n\n  // ECMA262 8.1.1.3.5\n  GetSuperBase(): ObjectValue | NullValue | UndefinedValue {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let home be the value of envRec.[[HomeObject]].\n    let home = envRec.$HomeObject;\n\n    // 3. If home has the value undefined, return undefined.\n    if (home === undefined) return this.realm.intrinsics.undefined;\n\n    // 4. Assert: Type(home) is Object.\n    invariant(home instanceof ObjectValue, \"expected object value\");\n\n    // 5. Return ? home.[[GetPrototypeOf]]().\n    return home.$GetPrototypeOf();\n  }\n}\n\n// ECMA262 8.1.1.4\nexport class GlobalEnvironmentRecord extends EnvironmentRecord {\n  $DeclarativeRecord: EnvironmentRecord;\n  $ObjectRecord: ObjectEnvironmentRecord;\n  $VarNames: Array<string>;\n  $GlobalThisValue: ObjectValue;\n\n  // ECMA262 8.1.1.4.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, return true.\n    if (DclRec.HasBinding(N)) return true;\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.HasBinding(N).\n    return ObjRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateMutableBinding(N, D).\n    return DclRec.CreateMutableBinding(N, D);\n  }\n\n  // ECMA262 8.1.1.4.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateImmutableBinding(N, S).\n    return DclRec.CreateImmutableBinding(N, S);\n  }\n\n  // ECMA262 8.1.1.4.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.InitializeBinding(N, V).\n      return DclRec.InitializeBinding(N, V);\n    }\n\n    // 4. Assert: If the binding exists, it must be in the object Environment Record.\n\n    // 5. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 6. Return ? ObjRec.InitializeBinding(N, V).\n    return ObjRec.InitializeBinding(N, V);\n  }\n\n  // ECMA262 8.1.1.4.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.SetMutableBinding(N, V, S).\n      return DclRec.SetMutableBinding(N, V, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.SetMutableBinding(N, V, S).\n    return ObjRec.SetMutableBinding(N, V, S);\n  }\n\n  // ECMA262 8.1.1.4.6\n  GetBindingValue(N: string, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.GetBindingValue(N, S).\n      return DclRec.GetBindingValue(N, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.GetBindingValue(N, S).\n    return ObjRec.GetBindingValue(N, S);\n  }\n\n  // ECMA262 8.1.1.4.7\n  DeleteBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.DeleteBinding(N).\n      return DclRec.DeleteBinding(N);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 6. Let existingProp be ? HasOwnProperty(globalObject, N).\n    let existingProp = HasOwnProperty(realm, globalObject, N);\n\n    // 7. If existingProp is true, then\n    if (existingProp) {\n      // a. Let status be ? ObjRec.DeleteBinding(N).\n      let status = ObjRec.DeleteBinding(N);\n\n      // b. If status is true, then\n      if (status) {\n        // i. Let varNames be envRec.[[VarNames]].\n        let varNames = envRec.$VarNames;\n\n        // ii. If N is an element of varNames, remove that element from the varNames.\n        if (varNames.indexOf(N) >= 0) {\n          varNames.splice(varNames.indexOf(N), 1);\n        }\n      }\n\n      // c. Return status.\n      return status;\n    }\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.8\n  HasThisBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.9\n  HasSuperBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.4.11\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    invariant(envRec.$GlobalThisValue);\n    // 2. Return envRec.[[GlobalThisValue]].\n    return envRec.$GlobalThisValue;\n  }\n\n  // ECMA262 8.1.1.4.12\n  HasVarDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 3. If varDeclaredNames contains the value of N, return true.\n    if (varDeclaredNames.indexOf(N) >= 0) return true;\n\n    // 4. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.13\n  HasLexicalDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. Return DclRec.HasBinding(N).\n    return DclRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.14\n  HasRestrictedGlobalProperty(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return false.\n    if (!existingProp) return false;\n    ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return false.\n    if (existingProp.configurable) return false;\n\n    // 7. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.15\n  CanDeclareGlobalVar(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. If hasProperty is true, return true.\n    if (hasProperty) return true;\n\n    // 6. Return ? IsExtensible(globalObject).\n    return IsExtensible(realm, globalObject);\n  }\n\n  // ECMA262 8.1.1.4.16\n  CanDeclareGlobalFunction(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return ? IsExtensible(globalObject).\n    if (!existingProp) return IsExtensible(realm, globalObject);\n    ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return true.\n    if (existingProp.configurable) return true;\n\n    // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values {[[Writable]]: true, [[Enumerable]]: true}, return true.\n    if (IsDataDescriptor(realm, existingProp) && existingProp.writable && existingProp.enumerable) {\n      return true;\n    }\n\n    // 8. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.17\n  CreateGlobalVarBinding(N: string, D: boolean) {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. Let extensible be ? IsExtensible(globalObject).\n    let extensible = IsExtensible(realm, globalObject);\n\n    // 6. If hasProperty is false and extensible is true, then\n    if (!hasProperty && extensible) {\n      // a. Perform ? ObjRec.CreateMutableBinding(N, D).\n      ObjRec.CreateMutableBinding(N, D);\n\n      // b. Perform ? ObjRec.InitializeBinding(N, undefined).\n      ObjRec.InitializeBinding(N, this.realm.intrinsics.undefined);\n    }\n\n    // 7. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 8. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 9. Return NormalCompletion(empty).\n  }\n\n  // ECMA262 8.1.1.4.18\n  CreateGlobalFunctionBinding(N: string, V: Value, D: boolean) {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then\n    let desc;\n    if (!existingProp || existingProp.configurable) {\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D}.\n      desc = { value: V, writable: true, enumerable: true, configurable: D };\n    } else {\n      // 6. Else,\n      ThrowIfMightHaveBeenDeleted(existingProp.value);\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V }.\n      desc = { value: V };\n    }\n\n    // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).\n    DefinePropertyOrThrow(this.realm, globalObject, N, desc);\n\n    // TODO? 8. Record that the binding for N in ObjRec has been initialized.\n\n    // 9. Perform ? Set(globalObject, N, V, false).\n    Set(this.realm, globalObject, N, V, false);\n\n    // 10. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 11. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 12. Return NormalCompletion(empty).\n  }\n}\n\n// ECMA262 8.1.1.5\nexport class ModuleEnvironmentRecord extends DeclarativeEnvironmentRecord {\n  // ECMA262 8.1.1.3.1\n  BindThisValue(\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    throw new FatalError(\"TODO: implement modules\");\n  }\n\n  // ECMA262 8.1.1.3.2\n  HasThisBinding(): boolean {\n    throw new FatalError(\"TODO: implement modules\");\n  }\n\n  // ECMA262 8.1.1.3.3\n  HasSuperBinding(): boolean {\n    throw new FatalError(\"TODO: implement modules\");\n  }\n\n  // ECMA262 8.1.1.3.4\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    throw new FatalError(\"TODO: implement modules\");\n  }\n\n  // ECMA262 8.1.1.3.5\n  GetSuperBase(): NullValue | ObjectValue | UndefinedValue {\n    throw new FatalError(\"TODO: implement modules\");\n  }\n}\n\n// ECMA262 8.1\nexport class LexicalEnvironment {\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n  }\n\n  environmentRecord: EnvironmentRecord;\n  parent: null | LexicalEnvironment;\n  realm: Realm;\n\n  assignToGlobal(globalAst: BabelNodeLVal, rvalue: Value) {\n    let globalValue = this.evaluate(globalAst, false);\n    PutValue(this.realm, globalValue, rvalue);\n  }\n\n  partiallyEvaluateCompletionDeref(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Value, BabelNode, Array<BabelNodeStatement>] {\n    let [result, partial_ast, partial_io] = this.partiallyEvaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) {\n      result = GetValue(this.realm, result);\n    }\n    return [result, partial_ast, partial_io];\n  }\n\n  partiallyEvaluateCompletion(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>] {\n    try {\n      return this.partiallyEvaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return [err, ast, []];\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateCompletionDeref(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value {\n    let result = this.evaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) result = GetValue(this.realm, result);\n    return result;\n  }\n\n  evaluateCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value | Reference {\n    try {\n      return this.evaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof JoinedAbruptCompletions || err instanceof PossiblyNormalCompletion) {\n        AbstractValue.reportIntrospectionError(err.joinCondition);\n        throw new FatalError();\n      }\n      if (err instanceof AbruptCompletion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateAbstractCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): Completion | Value | Reference {\n    try {\n      return this.evaluateAbstract(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      if (err instanceof Object) throw new FatalError(err.constructor.name + \": \" + err);\n      throw new FatalError(err);\n    }\n  }\n\n  concatenateAndParse(sources: Array<SourceFile>, sourceType: SourceType = \"script\"): [BabelNodeFile, any] {\n    let asts = [];\n    let code = {};\n    let directives = [];\n    for (let source of sources) {\n      try {\n        let node = parse(this.realm, source.fileContents, source.filePath, sourceType);\n        if (source.sourceMapContents && source.sourceMapContents.length > 0)\n          this.fixup_source_locations(node, source.sourceMapContents);\n        this.fixup_filenames(node);\n        asts = asts.concat(node.program.body);\n        code[source.filePath] = source.fileContents;\n        directives = directives.concat(node.program.directives);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) return e;\n        throw e;\n      }\n    }\n    return [t.file(t.program(asts, directives)), code];\n  }\n\n  executeSources(\n    sources: Array<SourceFile>,\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): [AbruptCompletion | Value, any] {\n    let [ast, code] = this.concatenateAndParse(sources, sourceType);\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let res;\n    try {\n      if (onParse) onParse(ast);\n      res = this.evaluateCompletion(ast, false);\n    } finally {\n      this.realm.popContext(context);\n    }\n    if (res instanceof AbruptCompletion) return [res, code];\n\n    return [GetValue(this.realm, res), code];\n  }\n\n  executePartialEvaluator(\n    sources: Array<SourceFile>,\n    options: PartialEvaluatorOptions = defaultOptions,\n    sourceType: SourceType = \"script\"\n  ): AbruptCompletion | { code: string, map?: SourceMap } {\n    let [ast, code] = this.concatenateAndParse(sources, sourceType);\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let partialAST;\n    try {\n      let res;\n      [res, partialAST] = this.partiallyEvaluateCompletionDeref(ast, false);\n      if (res instanceof AbruptCompletion) return res;\n    } finally {\n      this.realm.popContext(context);\n    }\n    invariant(partialAST.type === \"File\");\n    let fileAst = ((partialAST: any): BabelNodeFile);\n    let prog = t.program(fileAst.program.body, ast.program.directives);\n    this.fixup_filenames(prog);\n    return generate(prog, { sourceMaps: options.sourceMaps }, (code: any));\n  }\n\n  execute(\n    code: string,\n    filename: string,\n    map: string = \"\",\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): AbruptCompletion | Value {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n\n    this.realm.pushContext(context);\n\n    let ast, res;\n    try {\n      try {\n        ast = parse(this.realm, code, filename, sourceType);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) return e;\n        throw e;\n      }\n      if (onParse) onParse(ast);\n      if (map.length > 0) this.fixup_source_locations(ast, map);\n      this.fixup_filenames(ast);\n      res = this.evaluateCompletion(ast, false);\n    } finally {\n      this.realm.popContext(context);\n    }\n    if (res instanceof AbruptCompletion) return res;\n\n    return GetValue(this.realm, res);\n  }\n\n  fixup_source_locations(ast: BabelNode, map: string) {\n    const smc = new sourceMap.SourceMapConsumer(map);\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (!loc) return false;\n      fixup(loc, loc.start);\n      fixup(loc, loc.end);\n      fixup_comments(node.leadingComments);\n      fixup_comments(node.innerComments);\n      fixup_comments(node.trailingComments);\n      return false;\n\n      function fixup(new_loc: BabelNodeSourceLocation, new_pos: BabelNodePosition) {\n        let old_pos = smc.originalPositionFor({ line: new_pos.line, column: new_pos.column });\n        if (old_pos.source === null) return;\n        new_pos.line = old_pos.line;\n        new_pos.column = old_pos.column;\n        new_loc.source = old_pos.source;\n      }\n\n      function fixup_comments(comments: ?Array<BabelNodeComment>) {\n        if (!comments) return;\n        for (let c of comments) {\n          let cloc = c.loc;\n          if (!cloc) continue;\n          fixup(cloc, cloc.start);\n          fixup(cloc, cloc.end);\n        }\n      }\n    });\n  }\n\n  fixup_filenames(ast: BabelNode) {\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (!loc || !loc.source) {\n        node.leadingComments = null;\n        node.innerComments = null;\n        node.trailingComments = null;\n        node.loc = null;\n      } else {\n        let filename = loc.source;\n        (loc: any).filename = filename;\n        fixup_comments(node.leadingComments, filename);\n        fixup_comments(node.innerComments, filename);\n        fixup_comments(node.trailingComments, filename);\n      }\n      return false;\n\n      function fixup_comments(comments: ?Array<BabelNodeComment>, filename: string) {\n        if (!comments) return;\n        for (let c of comments) {\n          if (c.loc) {\n            (c.loc: any).filename = filename;\n            c.loc.source = filename;\n          }\n        }\n      }\n    });\n  }\n\n  evaluate(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    let res = this.evaluateAbstract(ast, strictCode, metadata);\n    if (res instanceof PossiblyNormalCompletion) {\n      AbstractValue.reportIntrospectionError(res.joinCondition);\n      throw new FatalError();\n    }\n    invariant(res instanceof Value || res instanceof Reference, ast.type);\n    return res;\n  }\n\n  evaluateAbstract(ast: BabelNode, strictCode: boolean, metadata?: any): NormalCompletion | Value | Reference {\n    this.realm.currentLocation = ast.loc;\n    this.realm.testTimeout();\n\n    let evaluator = this.realm.evaluators[(ast.type: string)];\n    if (evaluator) {\n      let result = evaluator(ast, strictCode, this, this.realm, metadata);\n      let context = this.realm.getRunningContext();\n      let savedCompletion = context.savedCompletion;\n      if (savedCompletion !== undefined) {\n        if (result instanceof Value) {\n          updatePossiblyNormalCompletionWithValue(this.realm, savedCompletion, result);\n          result = savedCompletion;\n        } else if (result instanceof PossiblyNormalCompletion) {\n          result = composePossiblyNormalCompletions(this.realm, savedCompletion, result);\n        } else {\n          AbstractValue.reportIntrospectionError(savedCompletion.joinCondition);\n          throw new FatalError();\n        }\n        context.savedCompletion = undefined;\n      }\n      return result;\n    }\n\n    throw new TypeError(`Unsupported node type ${ast.type}`);\n  }\n\n  partiallyEvaluate(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>] {\n    let partialEvaluator = this.realm.partialEvaluators[(ast.type: string)];\n    if (partialEvaluator) {\n      return partialEvaluator(ast, strictCode, this, this.realm, metadata);\n    }\n\n    let err = new TypeError(`Unsupported node type ${ast.type}`);\n    throw err;\n  }\n}\n\n// ECMA262 6.2.3\n// A Reference is a resolved name or property binding. A Reference consists of three components, the base value,\n// the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object,\n// a Boolean, a String, a Symbol, a Number, or an Environment Record. A base value of undefined indicates that the\n// Reference could not be resolved to a binding. The referenced name is a String or Symbol value.\nexport type BaseValue = void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord;\nexport type ReferenceName = string | SymbolValue;\n\nexport function canBecomeAnObject(base: Value): boolean {\n  let type = base.getType();\n  return type === BooleanValue || type === StringValue || type === SymbolValue || type === NumberValue;\n}\n\nexport class Reference {\n  base: BaseValue | AbstractValue;\n  referencedName: ReferenceName | AbstractValue;\n  strict: boolean;\n  thisValue: void | Value;\n\n  constructor(\n    base: BaseValue | AbstractValue,\n    refName: ReferenceName | AbstractValue,\n    strict: boolean,\n    thisValue?: void | Value\n  ) {\n    invariant(\n      base instanceof AbstractObjectValue ||\n        base === undefined ||\n        base instanceof ObjectValue ||\n        base instanceof EnvironmentRecord ||\n        canBecomeAnObject(base)\n    );\n    this.base = base;\n    this.referencedName = refName;\n    invariant(!(refName instanceof AbstractValue) || !refName.mightNotBeString());\n    this.strict = strict;\n    this.thisValue = thisValue;\n    invariant(thisValue === undefined || !(base instanceof EnvironmentRecord));\n  }\n}\n"]}