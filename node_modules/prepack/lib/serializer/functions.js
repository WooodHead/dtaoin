"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Functions = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _completions = require("../completions.js");

var _errors = require("../errors.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _realm = require("../realm.js");

var _errors2 = require("../utils/errors.js");

var _index = require("../values/index.js");

var _modules = require("./modules.js");

var _babelTemplate = require("babel-template");

var _babelTemplate2 = _interopRequireDefault(_babelTemplate);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Functions = exports.Functions = function () {
  function Functions(realm, functions, moduleTracer) {
    _classCallCheck(this, Functions);

    this.realm = realm;
    this.functions = functions;
    this.moduleTracer = moduleTracer;
  }

  _createClass(Functions, [{
    key: "checkThatFunctionsAreIndependent",
    value: function checkThatFunctionsAreIndependent() {
      var _this = this;

      var functions = this.functions;
      (0, _invariant2.default)(functions, "This method should only be called if initialized with defined functions");

      // lookup functions
      var calls = [];

      var _loop = function _loop(fname) {
        var fun = void 0;
        var fnameAst = (0, _babelTemplate2.default)(fname)({}).expression;
        if (fnameAst) {
          try {
            var e = (0, _errors2.ignoreErrorsIn)(_this.realm, function () {
              return _this.realm.evaluateNodeForEffectsInGlobalEnv(fnameAst);
            });
            fun = e ? e[0] : undefined;
          } catch (ex) {
            if (!(ex instanceof _completions.ThrowCompletion)) throw ex;
          }
        }
        if (!(fun instanceof _index.FunctionValue)) {
          var error = new _errors.CompilerDiagnostic("Additional function " + fname + " not defined in the global environment", null, "PP1001", "FatalError");
          _this.realm.handleError(error);
          throw new _errors.FatalError();
        }
        var call = t.callExpression(fnameAst, []);
        calls.push([fname, call]);
      };

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = functions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var fname = _step.value;

          _loop(fname);
        }

        // Get write effects of the functions
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var writeEffects = new Map();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = calls[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _ref = _step2.value;

          var _ref2 = _slicedToArray(_ref, 2);

          var fname = _ref2[0];
          var call = _ref2[1];

          // This may throw a FatalError if there is an unrecoverable error in the called function
          // When that happens we cannot prepack the bundle.
          // There may also be warnings reported for errors that happen inside imported modules that can be postponed.
          var e = this.realm.evaluateNodeForEffectsInGlobalEnv(call, this.moduleTracer);
          writeEffects.set(fname, e);
        }

        // check that functions are independent
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var conflicts = new Map();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = calls[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _ref3 = _step3.value;

          var _ref4 = _slicedToArray(_ref3, 2);

          var fname1 = _ref4[0];
          var call1 = _ref4[1];

          var e1 = writeEffects.get(fname1);
          (0, _invariant2.default)(e1 !== undefined);
          if (e1[0] instanceof _completions.Completion) {
            var error = new _errors.CompilerDiagnostic("Additional function " + fname1 + " may terminate abruptly", e1[0].location, "PP1002", "FatalError");
            this.realm.handleError(error);
            throw new _errors.FatalError();
          }
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = calls[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _ref5 = _step5.value;

              var _ref6 = _slicedToArray(_ref5, 2);

              var fname2 = _ref6[0];
              var call2 = _ref6[1];

              fname2; // not used
              if (call1 === call2) continue;
              this.reportWriteConflicts(fname1, conflicts, e1[3], call1, call2);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (conflicts.size > 0) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = conflicts.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var diagnostic = _step4.value;
            this.realm.handleError(diagnostic);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        throw new _errors.FatalError();
      }
    }
  }, {
    key: "reportWriteConflicts",
    value: function reportWriteConflicts(fname, conflicts, pbs, call1, call2) {
      var _this2 = this;

      var reportConflict = function reportConflict(location) {
        var error = new _errors.CompilerDiagnostic("Property access conflicts with write in additional function " + fname, location, "PP1003", "FatalError");
        conflicts.set(location, error);
      };
      var writtenObjects = new Set();
      pbs.forEach(function (val, key, m) {
        writtenObjects.add(key.object);
      });
      var oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;
      this.realm.reportObjectGetOwnProperties = function (ob) {
        var location = _this2.realm.currentLocation;
        (0, _invariant2.default)(location);
        if (writtenObjects.has(ob) && !conflicts.has(location)) reportConflict(location);
      };
      var oldReportPropertyAccess = this.realm.reportPropertyAccess;
      this.realm.reportPropertyAccess = function (pb) {
        var location = _this2.realm.currentLocation;
        if (!location) return; // happens only when accessing an additional function property
        if (pbs.has(pb) && !conflicts.has(location)) reportConflict(location);
      };
      try {
        (0, _errors2.ignoreErrorsIn)(this.realm, function () {
          return _this2.realm.evaluateNodeForEffectsInGlobalEnv(call2, _this2.moduleTracer);
        });
      } finally {
        this.realm.reportPropertyAccess = oldReportPropertyAccess;
        this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;
      }
    }
  }]);

  return Functions;
}();
//# sourceMappingURL=functions.js.map