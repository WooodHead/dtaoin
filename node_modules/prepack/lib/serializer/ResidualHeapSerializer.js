"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualHeapSerializer = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _realm = require("../realm.js");

var _index = require("../methods/index.js");

var _index2 = require("../values/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _generator = require("../utils/generator.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _types = require("./types.js");

var _logger = require("./logger.js");

var _modules = require("./modules.js");

var _ResidualHeapInspector = require("./ResidualHeapInspector.js");

var _ResidualFunctions = require("./ResidualFunctions.js");

var _factorify = require("./factorify.js");

var _internalizer = require("../utils/internalizer.js");

var _Emitter = require("./Emitter.js");

var _ResidualHeapValueIdentifiers = require("./ResidualHeapValueIdentifiers.js");

var _utils = require("./utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResidualHeapSerializer = exports.ResidualHeapSerializer = function () {
  function ResidualHeapSerializer(realm, logger, modules, residualHeapValueIdentifiers, residualHeapInspector, residualValues, residualFunctionBindings, residualFunctionInfos, delayInitializations, referencedDeclaredValues) {
    var _this = this;

    _classCallCheck(this, ResidualHeapSerializer);

    this.realm = realm;
    this.logger = logger;
    this.modules = modules;
    this.residualHeapValueIdentifiers = residualHeapValueIdentifiers;

    var realmGenerator = this.realm.generator;
    (0, _invariant2.default)(realmGenerator);
    this.generator = realmGenerator;
    var realmPreludeGenerator = this.realm.preludeGenerator;
    (0, _invariant2.default)(realmPreludeGenerator);
    this.preludeGenerator = realmPreludeGenerator;

    this.declarativeEnvironmentRecordsBindings = new Map();
    this.prelude = [];
    this.descriptors = new Map();
    this.needsEmptyVar = false;
    this.needsAuxiliaryConstructor = false;
    this.valueNameGenerator = this.preludeGenerator.createNameGenerator("_");
    this.descriptorNameGenerator = this.preludeGenerator.createNameGenerator("$$");
    this.factoryNameGenerator = this.preludeGenerator.createNameGenerator("$_");
    this.intrinsicNameGenerator = this.preludeGenerator.createNameGenerator("$i_");
    this.requireReturns = new Map();
    this.statistics = new _types.SerializerStatistics();
    this.serializedValues = new Set();
    this.residualFunctions = new _ResidualFunctions.ResidualFunctions(this.realm, this.statistics, this.modules, this.requireReturns, {
      getLocation: function getLocation(value) {
        return _this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCountOptional(value);
      },
      createLocation: function createLocation() {
        var location = t.identifier(_this.valueNameGenerator.generate("initialized"));
        _this.mainBody.push(t.variableDeclaration("var", [t.variableDeclarator(location)]));
        return location;
      }
    }, this.prelude, this.preludeGenerator.createNameGenerator("__init_"), this.factoryNameGenerator, this.preludeGenerator.createNameGenerator("__scope_"), residualFunctionInfos);
    this.emitter = new _Emitter.Emitter(this.residualFunctions);
    this.mainBody = this.emitter.getBody();
    this.residualHeapInspector = residualHeapInspector;
    this.residualValues = residualValues;
    this.residualFunctionBindings = residualFunctionBindings;
    this.residualFunctionInfos = residualFunctionInfos;
    this.delayInitializations = delayInitializations;
    this.referencedDeclaredValues = referencedDeclaredValues;
    this.activeGeneratorBodies = new Map();
  }

  _createClass(ResidualHeapSerializer, [{
    key: "_emitObjectProperties",


    // Configures all mutable aspects of an object, in particular:
    // symbols, properties, prototype.
    // For every created object that corresponds to a value,
    // this function should be invoked once.
    // Thus, as a side effects, we gather statistics here on all emitted objects.
    value: function _emitObjectProperties(obj) {
      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : obj.properties;

      var _this2 = this;

      var objectPrototypeAlreadyEstablished = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var cleanupDummyProperties = arguments[3];

      var _loop = function _loop(symbol, propertyBinding) {
        (0, _invariant2.default)(propertyBinding);
        var desc = propertyBinding.descriptor;
        if (desc === undefined) return "continue"; //deleted
        _this2.emitter.emitNowOrAfterWaitingForDependencies(_this2._getDescriptorValues(desc).concat([symbol, obj]), function () {
          (0, _invariant2.default)(desc !== undefined);
          return _this2._emitProperty(obj, symbol, desc);
        });
      };

      //inject symbols
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = obj.symbols[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref = _step.value;

          var _ref2 = _slicedToArray(_ref, 2);

          var symbol = _ref2[0];
          var propertyBinding = _ref2[1];

          var _ret = _loop(symbol, propertyBinding);

          if (_ret === "continue") continue;
        }

        // inject properties
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _loop2 = function _loop2(key, propertyBinding) {
        (0, _invariant2.default)(propertyBinding);
        var desc = propertyBinding.descriptor;
        if (desc === undefined) return "continue"; //deleted
        if (_this2.residualHeapInspector.canIgnoreProperty(obj, key)) return "continue";
        (0, _invariant2.default)(desc !== undefined);
        _this2.emitter.emitNowOrAfterWaitingForDependencies(_this2._getDescriptorValues(desc).concat(obj), function () {
          (0, _invariant2.default)(desc !== undefined);
          return _this2._emitProperty(obj, key, desc, cleanupDummyProperties != null && cleanupDummyProperties.has(key));
        });
      };

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _ref3 = _step2.value;

          var _ref4 = _slicedToArray(_ref3, 2);

          var key = _ref4[0];
          var propertyBinding = _ref4[1];

          var _ret2 = _loop2(key, propertyBinding);

          if (_ret2 === "continue") continue;
        }

        // inject properties with computed names
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (obj.unknownProperty !== undefined) {
        var _desc = obj.unknownProperty.descriptor;
        if (_desc !== undefined) {
          var val = _desc.value;
          (0, _invariant2.default)(val instanceof _index2.AbstractValue);
          this.emitter.emitNowOrAfterWaitingForDependencies(this._getNestedAbstractValues(val, [obj]), function () {
            (0, _invariant2.default)(val instanceof _index2.AbstractValue);
            _this2._emitPropertiesWithComputedNames(obj, val);
          });
        }
      }

      // prototype
      this._emitObjectPrototype(obj, objectPrototypeAlreadyEstablished);
      if (obj instanceof _index2.FunctionValue) this._emitConstructorPrototype(obj);

      this.statistics.objects++;
      this.statistics.objectProperties += obj.properties.size;
    }
  }, {
    key: "_emitObjectPrototype",
    value: function _emitObjectPrototype(obj, objectPrototypeAlreadyEstablished) {
      var _this3 = this;

      var kind = obj.getKind();
      var proto = obj.$Prototype;
      if (objectPrototypeAlreadyEstablished) {
        // Emitting an assertion. This can be removed in the future, or put under a DEBUG flag.
        this.emitter.emitNowOrAfterWaitingForDependencies([proto, obj], function () {
          (0, _invariant2.default)(proto);
          var serializedProto = _this3.serializeValue(proto);
          var uid = _this3.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(obj);
          var condition = t.binaryExpression("!==", t.memberExpression(uid, _internalizer.protoExpression), serializedProto);
          var throwblock = t.blockStatement([t.throwStatement(t.newExpression(t.identifier("Error"), [t.stringLiteral("unexpected prototype")]))]);
          _this3.emitter.emit(t.ifStatement(condition, throwblock));
        });
        return;
      }
      if (proto === this.realm.intrinsics[kind + "Prototype"]) return;

      this.emitter.emitNowOrAfterWaitingForDependencies([proto, obj], function () {
        (0, _invariant2.default)(proto);
        var serializedProto = _this3.serializeValue(proto);
        var uid = _this3.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(obj);
        if (!_this3.realm.isCompatibleWith(_this3.realm.MOBILE_JSC_VERSION)) _this3.emitter.emit(t.expressionStatement(t.callExpression(_this3.preludeGenerator.memoizeReference("Object.setPrototypeOf"), [uid, serializedProto])));else {
          _this3.emitter.emit(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(uid, _internalizer.protoExpression), serializedProto)));
        }
      });
    }
  }, {
    key: "_emitConstructorPrototype",
    value: function _emitConstructorPrototype(func) {
      var _this4 = this;

      // If the original prototype object was mutated,
      // request its serialization here as this might be observable by
      // residual code.
      var prototype = _ResidualHeapInspector.ResidualHeapInspector.getPropertyValue(func, "prototype");
      if (prototype instanceof _index2.ObjectValue && this.residualValues.has(prototype)) {
        this.emitter.emitNowOrAfterWaitingForDependencies([func], function () {
          (0, _invariant2.default)(prototype);
          _this4.serializeValue(prototype);
        });
      }
    }
  }, {
    key: "_getNestedAbstractValues",
    value: function _getNestedAbstractValues(absVal, values) {
      (0, _invariant2.default)(absVal.args.length === 3);
      var cond = absVal.args[0];
      (0, _invariant2.default)(cond instanceof _index2.AbstractValue);
      if (cond.kind === "template for property name condition") {
        var P = cond.args[0];
        values.push(P);
        var V = absVal.args[1];
        values.push(V);
        var W = absVal.args[2];
        if (W instanceof _index2.AbstractValue) this._getNestedAbstractValues(W, values);else values.push(W);
      } else {
        // conditional assignment
        values.push(cond);
        var consequent = absVal.args[1];
        (0, _invariant2.default)(consequent instanceof _index2.AbstractValue);
        var alternate = absVal.args[2];
        (0, _invariant2.default)(alternate instanceof _index2.AbstractValue);
        this._getNestedAbstractValues(consequent, values);
        this._getNestedAbstractValues(alternate, values);
      }
      return values;
    }
  }, {
    key: "_emitPropertiesWithComputedNames",
    value: function _emitPropertiesWithComputedNames(obj, absVal) {
      (0, _invariant2.default)(absVal.args.length === 3);
      var cond = absVal.args[0];
      (0, _invariant2.default)(cond instanceof _index2.AbstractValue);
      if (cond.kind === "template for property name condition") {
        var P = cond.args[0];
        (0, _invariant2.default)(P instanceof _index2.AbstractValue);
        var V = absVal.args[1];
        var earlier_props = absVal.args[2];
        if (earlier_props instanceof _index2.AbstractValue) this._emitPropertiesWithComputedNames(obj, earlier_props);
        var uid = this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(obj);
        var serializedP = this.serializeValue(P);
        var serializedV = this.serializeValue(V);
        this.emitter.emit(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(uid, serializedP, true), serializedV)));
      } else {
        // conditional assignment
        var serializedCond = this.serializeValue(cond);
        var consequent = absVal.args[1];
        (0, _invariant2.default)(consequent instanceof _index2.AbstractValue);
        var alternate = absVal.args[2];
        (0, _invariant2.default)(alternate instanceof _index2.AbstractValue);
        var oldBody = this.emitter.beginEmitting("consequent", []);
        this._emitPropertiesWithComputedNames(obj, consequent);
        var consequentBody = this.emitter.endEmitting("consequent", oldBody);
        var consequentStatement = t.blockStatement(consequentBody);
        oldBody = this.emitter.beginEmitting("alternate", []);
        this._emitPropertiesWithComputedNames(obj, alternate);
        var alternateBody = this.emitter.endEmitting("alternate", oldBody);
        var alternateStatement = t.blockStatement(alternateBody);
        this.emitter.emit(t.ifStatement(serializedCond, consequentStatement, alternateStatement));
      }
    }
  }, {
    key: "_emitProperty",
    value: function _emitProperty(val, key, desc) {
      var _this5 = this;

      var cleanupDummyProperty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (this._canEmbedProperty(val, key, desc)) {
        var descValue = desc.value;
        (0, _invariant2.default)(descValue instanceof _index2.Value);
        (0, _invariant2.default)(!this.emitter.getReasonToWaitForDependencies([descValue, val]), "precondition of _emitProperty");
        var mightHaveBeenDeleted = descValue.mightHaveBeenDeleted();
        // The only case we do not need to remove the dummy property is array index property.
        this._assignProperty(function () {
          var serializedKey = key instanceof _index2.SymbolValue ? _this5.serializeValue(key) : _this5.generator.getAsPropertyNameExpression(key);
          var computed = key instanceof _index2.SymbolValue || !t.isIdentifier(serializedKey);
          return t.memberExpression(_this5.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val), serializedKey, computed);
        }, function () {
          (0, _invariant2.default)(descValue instanceof _index2.Value);
          return _this5.serializeValue(descValue);
        }, mightHaveBeenDeleted, cleanupDummyProperty);
      } else {
        var descProps = [];

        var boolKeys = ["enumerable", "configurable"];
        var valKeys = [];

        if (!desc.get && !desc.set) {
          boolKeys.push("writable");
          valKeys.push("value");
        } else {
          valKeys.push("set", "get");
        }

        var descriptorsKey = [];
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = boolKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var boolKey = _step3.value;

            if (boolKey in desc) {
              var b = desc[boolKey];
              (0, _invariant2.default)(b !== undefined);
              descProps.push(t.objectProperty(t.identifier(boolKey), t.booleanLiteral(b)));
              descriptorsKey.push(boolKey + ":" + b.toString());
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = valKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var descKey = _step4.value;

            if (descKey in desc) descriptorsKey.push(descKey);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        descriptorsKey = descriptorsKey.join(",");
        var descriptorId = this.descriptors.get(descriptorsKey);
        if (descriptorId === undefined) {
          descriptorId = t.identifier(this.descriptorNameGenerator.generate(descriptorsKey));
          var declar = t.variableDeclaration("var", [t.variableDeclarator(descriptorId, t.objectExpression(descProps))]);
          // The descriptors are used across all scopes, and thus must be declared in the prelude.
          this.prelude.push(declar);
          this.descriptors.set(descriptorsKey, descriptorId);
        }
        (0, _invariant2.default)(descriptorId !== undefined);

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = valKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _descKey = _step5.value;

            if (_descKey in desc) {
              var _descValue = desc[_descKey];
              (0, _invariant2.default)(_descValue instanceof _index2.Value);
              (0, _invariant2.default)(!this.emitter.getReasonToWaitForDependencies([_descValue]), "precondition of _emitProperty");
              this.emitter.emit(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(descriptorId, t.identifier(_descKey)), this.serializeValue(_descValue))));
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        var serializedKey = key instanceof _index2.SymbolValue ? this.serializeValue(key) : this.generator.getAsPropertyNameExpression(key, /*canBeIdentifier*/false);
        (0, _invariant2.default)(!this.emitter.getReasonToWaitForDependencies([val]), "precondition of _emitProperty");
        var uid = this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val);
        this.emitter.emit(t.expressionStatement(t.callExpression(this.preludeGenerator.memoizeReference("Object.defineProperty"), [uid, serializedKey, descriptorId])));
      }
    }
  }, {
    key: "_serializeDeclarativeEnvironmentRecordBinding",
    value: function _serializeDeclarativeEnvironmentRecordBinding(visitedBinding) {
      var serializedBinding = this.declarativeEnvironmentRecordsBindings.get(visitedBinding);
      if (!serializedBinding) {
        var value = visitedBinding.value;
        (0, _invariant2.default)(value);
        (0, _invariant2.default)(visitedBinding.declarativeEnvironmentRecord);

        // Set up binding identity before starting to serialize value. This is needed in case of recursive dependencies.
        serializedBinding = {
          serializedValue: undefined,
          value: value,
          modified: visitedBinding.modified,
          referentialized: false,
          declarativeEnvironmentRecord: visitedBinding.declarativeEnvironmentRecord
        };
        this.declarativeEnvironmentRecordsBindings.set(visitedBinding, serializedBinding);
        var serializedValue = this.serializeValue(value);
        serializedBinding.serializedValue = serializedValue;
        if (value.mightBeObject()) {
          // Increment ref count one more time to ensure that this object will be assigned a unique id.
          // This ensures that only once instance is created across all possible residual function invocations.
          this.residualHeapValueIdentifiers.incrementReferenceCount(value);
        }
      }
      return serializedBinding;
    }

    // Determine whether initialization code for a value should go into the main body, or a more specific initialization body.

  }, {
    key: "_getTarget",
    value: function _getTarget(val, scopes) {
      // All relevant values were visited in at least one scope.
      (0, _invariant2.default)(scopes.size >= 1);

      // First, let's figure out from which function and generator scopes this value is referenced.
      var functionValues = [];
      var generators = [];
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = scopes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var scope = _step6.value;

          if (scope instanceof _index2.FunctionValue) functionValues.push(scope);else {
            (0, _invariant2.default)(scope instanceof _generator.Generator);
            if (scope === this.realm.generator) {
              // This value is used from the main generator scope. This means that we need to emit the value and its
              // initialization code into the main body, and cannot delay initialization.
              return { body: this.mainBody };
            }
            generators.push(scope);
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      if (generators.length === 0) {
        // This value is only referenced from residual functions.
        (0, _invariant2.default)(functionValues.length > 0);
        if (this.delayInitializations) {
          // We can delay the initialization, and move it into a conditional code block in the residual functions!
          var _body = this.residualFunctions.residualFunctionInitializers.registerValueOnlyReferencedByResidualFunctions(functionValues, val);
          return { body: _body, usedOnlyByResidualFunctions: true };
        } else {
          // We can just emit it into the main body which will get executed unconditionally.
          return { body: this.mainBody };
        }
      }

      // This value is referenced from more than one generator or function.
      // We can emit the initialization of this value into the body associated with their common ancestor.
      var commonAncestor = Array.from(scopes).reduce(function (x, y) {
        return (0, _utils.commonAncestorOf)(x, y);
      }, generators[0]);
      (0, _invariant2.default)(commonAncestor instanceof _generator.Generator); // every scope is either the root, or a descendant
      var body = commonAncestor === this.generator ? this.mainBody : this.activeGeneratorBodies.get(commonAncestor);
      (0, _invariant2.default)(body !== undefined);
      return { body: body };
    }
  }, {
    key: "serializeValue",
    value: function serializeValue(val, referenceOnly, bindingType) {
      var scopes = this.residualValues.get(val);
      (0, _invariant2.default)(scopes !== undefined);

      var ref = this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCountOptional(val);
      if (ref) {
        return ref;
      }

      this.serializedValues.add(val);
      if (!referenceOnly && _ResidualHeapInspector.ResidualHeapInspector.isLeaf(val)) {
        var res = this._serializeValue(val);
        (0, _invariant2.default)(res !== undefined);
        return res;
      }

      var target = this._getTarget(val, scopes);

      var name = this.valueNameGenerator.generate(val.__originalName || "");
      var id = t.identifier(name);
      this.residualHeapValueIdentifiers.setIdentifier(val, id);
      var oldBody = this.emitter.beginEmitting(val, target.body);
      var init = this._serializeValue(val);
      var result = id;
      this.residualHeapValueIdentifiers.incrementReferenceCount(val);

      if (this.residualHeapValueIdentifiers.needsIdentifier(val)) {
        if (init) {
          if (init !== id) {
            if (target.usedOnlyByResidualFunctions) {
              var declar = t.variableDeclaration(bindingType ? bindingType : "var", [t.variableDeclarator(id)]);
              this.mainBody.push(declar);
              var assignment = t.expressionStatement(t.assignmentExpression("=", id, init));
              this.emitter.emit(assignment);
            } else {
              var _declar = t.variableDeclaration(bindingType ? bindingType : "var", [t.variableDeclarator(id, init)]);
              this.emitter.emit(_declar);
            }
          }
          this.statistics.valueIds++;
          if (target.usedOnlyByResidualFunctions) this.statistics.delayedValues++;
        }
      } else {
        if (init) {
          this.residualHeapValueIdentifiers.deleteIdentifier(val);
          result = init;
          this.statistics.valuesInlined++;
        }
      }

      this.emitter.endEmitting(val, oldBody);
      return result;
    }
  }, {
    key: "_serializeValueIntrinsic",
    value: function _serializeValueIntrinsic(val) {
      var intrinsicName = val.intrinsicName;
      (0, _invariant2.default)(intrinsicName);
      var intrinsicId = t.identifier(this.valueNameGenerator.generate(intrinsicName));
      var declar = t.variableDeclaration("var", [t.variableDeclarator(intrinsicId, this.preludeGenerator.convertStringToMember(intrinsicName))]);
      if (val instanceof _index2.ObjectValue && val.intrinsicNameGenerated) {
        // TODO #882: The value came into existance as a template for an abstract object.
        // Unfortunately, we are not properly tracking which generate it's associated with.
        // Until this gets fixed, let's stick to the historical behavior: Emit to the current emitter body.
        this.emitter.emit(declar);
      } else {
        (0, _invariant2.default)(this.emitter.getBody() === this.mainBody);
        this.prelude.push(declar);
      }
      return intrinsicId;
    }
  }, {
    key: "_getDescriptorValues",
    value: function _getDescriptorValues(desc) {
      if (desc.value !== undefined) return [desc.value];
      (0, _invariant2.default)(desc.get !== undefined);
      (0, _invariant2.default)(desc.set !== undefined);
      return [desc.get, desc.set];
    }
  }, {
    key: "_assignProperty",
    value: function _assignProperty(locationFn, valueFn, mightHaveBeenDeleted) {
      var cleanupDummyProperty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var location = locationFn();
      var value = valueFn();
      var assignment = t.expressionStatement(t.assignmentExpression("=", location, value));
      if (mightHaveBeenDeleted) {
        var condition = t.binaryExpression("!==", value, this.serializeValue(this.realm.intrinsics.empty));
        var deletion = null;
        if (cleanupDummyProperty) {
          (0, _invariant2.default)(location.type === "MemberExpression");
          deletion = t.expressionStatement(t.unaryExpression("delete", location, true));
        }
        this.emitter.emit(t.ifStatement(condition, assignment, deletion));
      } else {
        this.emitter.emit(assignment);
      }
    }
  }, {
    key: "_serializeArrayIndexProperties",
    value: function _serializeArrayIndexProperties(array, indexPropertyLength, remainingProperties) {
      var elems = [];
      for (var i = 0; i < indexPropertyLength; i++) {
        var key = i + "";
        var propertyBinding = remainingProperties.get(key);
        var elem = null;
        // "propertyBinding === undefined" means array has a hole in the middle.
        if (propertyBinding !== undefined) {
          var descriptor = propertyBinding.descriptor;
          // "descriptor === undefined" means this array item has been deleted.
          if (descriptor !== undefined && descriptor.value !== undefined && this._canEmbedProperty(array, key, descriptor)) {
            var elemVal = descriptor.value;
            (0, _invariant2.default)(elemVal instanceof _index2.Value);
            var mightHaveBeenDeleted = elemVal.mightHaveBeenDeleted();
            var delayReason = this.emitter.getReasonToWaitForDependencies(elemVal) || this.emitter.getReasonToWaitForActiveValue(array, mightHaveBeenDeleted);
            if (!delayReason) {
              elem = this.serializeValue(elemVal);
              remainingProperties.delete(key);
            }
          }
        }
        elems.push(elem);
      }
      return elems;
    }
  }, {
    key: "_serializeArrayLengthIfNeeded",
    value: function _serializeArrayLengthIfNeeded(val, numberOfIndexProperties, remainingProperties) {
      var _this6 = this;

      var realm = this.realm;
      var lenProperty = (0, _index.Get)(realm, val, "length");
      // Need to serialize length property if:
      // 1. array length is abstract.
      // 2. array length is concrete, but different from number of index properties
      //  we put into initialization list.
      if (lenProperty instanceof _index2.AbstractValue || (0, _index.ToLength)(realm, lenProperty) !== numberOfIndexProperties) {
        this.emitter.emitNowOrAfterWaitingForDependencies([val], function () {
          _this6._assignProperty(function () {
            return t.memberExpression(_this6.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val), t.identifier("length"));
          }, function () {
            return _this6.serializeValue(lenProperty);
          }, false /*mightHaveBeenDeleted*/
          );
        });
        remainingProperties.delete("length");
      }
    }
  }, {
    key: "_serializeValueArray",
    value: function _serializeValueArray(val) {
      var remainingProperties = new Map(val.properties);

      var indexPropertyLength = (0, _utils.getSuggestedArrayLiteralLength)(this.realm, val);
      // Use the serialized index properties as array initialization list.
      var initProperties = this._serializeArrayIndexProperties(val, indexPropertyLength, remainingProperties);
      this._serializeArrayLengthIfNeeded(val, indexPropertyLength, remainingProperties);
      this._emitObjectProperties(val, remainingProperties);
      return t.arrayExpression(initProperties);
    }
  }, {
    key: "_serializeValueMap",
    value: function _serializeValueMap(val) {
      var _this7 = this;

      var kind = val.getKind();
      var elems = [];

      var entries = void 0;
      if (kind === "Map") {
        entries = val.$MapData;
      } else {
        (0, _invariant2.default)(kind === "WeakMap");
        entries = val.$WeakMapData;
      }
      (0, _invariant2.default)(entries !== undefined);
      var len = entries.length;
      var mapConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);

      var _loop3 = function _loop3(i) {
        var entry = entries[i];
        var key = entry.$Key;
        var value = entry.$Value;
        if (key === undefined || value === undefined) return "continue";
        var mightHaveBeenDeleted = key.mightHaveBeenDeleted();
        var delayReason = _this7.emitter.getReasonToWaitForDependencies(key) || _this7.emitter.getReasonToWaitForDependencies(value) || _this7.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || mapConstructorDoesntTakeArguments);
        if (delayReason) {
          _this7.emitter.emitAfterWaiting(delayReason, [key, value, val], function () {
            (0, _invariant2.default)(key !== undefined);
            (0, _invariant2.default)(value !== undefined);
            _this7.emitter.emit(t.expressionStatement(t.callExpression(t.memberExpression(_this7.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val), t.identifier("set")), [_this7.serializeValue(key), _this7.serializeValue(value)])));
          });
        } else {
          var serializedKey = _this7.serializeValue(key);
          var serializedValue = _this7.serializeValue(value);
          var elem = t.arrayExpression([serializedKey, serializedValue]);
          elems.push(elem);
        }
      };

      for (var i = 0; i < len; i++) {
        var _ret3 = _loop3(i);

        if (_ret3 === "continue") continue;
      }

      this._emitObjectProperties(val);
      var args = elems.length > 0 ? [t.arrayExpression(elems)] : [];
      return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);
    }
  }, {
    key: "_serializeValueSet",
    value: function _serializeValueSet(val) {
      var _this8 = this;

      var kind = val.getKind();
      var elems = [];

      var entries = void 0;
      if (kind === "Set") {
        entries = val.$SetData;
      } else {
        (0, _invariant2.default)(kind === "WeakSet");
        entries = val.$WeakSetData;
      }
      (0, _invariant2.default)(entries !== undefined);
      var len = entries.length;
      var setConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);

      var _loop4 = function _loop4(i) {
        var entry = entries[i];
        if (entry === undefined) return "continue";
        var mightHaveBeenDeleted = entry.mightHaveBeenDeleted();
        var delayReason = _this8.emitter.getReasonToWaitForDependencies(entry) || _this8.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || setConstructorDoesntTakeArguments);
        if (delayReason) {
          _this8.emitter.emitAfterWaiting(delayReason, [entry, val], function () {
            (0, _invariant2.default)(entry !== undefined);
            _this8.emitter.emit(t.expressionStatement(t.callExpression(t.memberExpression(_this8.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val), t.identifier("add")), [_this8.serializeValue(entry)])));
          });
        } else {
          var elem = _this8.serializeValue(entry);
          elems.push(elem);
        }
      };

      for (var i = 0; i < len; i++) {
        var _ret4 = _loop4(i);

        if (_ret4 === "continue") continue;
      }

      this._emitObjectProperties(val);
      var args = elems.length > 0 ? [t.arrayExpression(elems)] : [];
      return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);
    }
  }, {
    key: "_serializeValueTypedArrayOrDataView",
    value: function _serializeValueTypedArrayOrDataView(val) {
      var buf = val.$ViewedArrayBuffer;
      (0, _invariant2.default)(buf !== undefined);
      var outlinedArrayBuffer = this.serializeValue(buf, true);
      this._emitObjectProperties(val);
      return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [outlinedArrayBuffer]);
    }
  }, {
    key: "_serializeValueArrayBuffer",
    value: function _serializeValueArrayBuffer(val) {
      var elems = [];

      var len = val.$ArrayBufferByteLength;
      var db = val.$ArrayBufferData;
      (0, _invariant2.default)(len !== undefined);
      (0, _invariant2.default)(db);
      var allzero = true;
      for (var i = 0; i < len; i++) {
        if (db[i] !== 0) {
          allzero = false;
        }
        var elem = t.numericLiteral(db[i]);
        elems.push(elem);
      }

      this._emitObjectProperties(val);
      if (allzero) {
        // if they're all zero, just emit the array buffer constructor
        return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [t.numericLiteral(len)]);
      } else {
        // initialize from a byte array otherwise
        var arrayValue = t.arrayExpression(elems);
        var consExpr = t.newExpression(this.preludeGenerator.memoizeReference("Uint8Array"), [arrayValue]);
        // access the Uint8Array.buffer property to extract the created buffer
        return t.memberExpression(consExpr, t.identifier("buffer"));
      }
    }
  }, {
    key: "_serializeValueFunction",
    value: function _serializeValueFunction(val) {
      var _this9 = this;

      if (val instanceof _index2.BoundFunctionValue) {
        this._emitObjectProperties(val);
        return t.callExpression(t.memberExpression(this.serializeValue(val.$BoundTargetFunction), t.identifier("bind")), [].concat(this.serializeValue(val.$BoundThis), val.$BoundArguments.map(function (boundArg, i) {
          return _this9.serializeValue(boundArg);
        })));
      }

      (0, _invariant2.default)(!(val instanceof _index2.NativeFunctionValue), "all native function values should be intrinsics");

      var residualBindings = this.residualFunctionBindings.get(val);
      (0, _invariant2.default)(residualBindings);

      (0, _invariant2.default)(val instanceof _index2.ECMAScriptSourceFunctionValue);
      var serializedBindings = Object.create(null);
      var instance = {
        serializedBindings: serializedBindings,
        functionValue: val,
        scopeInstances: new Set()
      };

      var delayed = 1;
      var undelay = function undelay() {
        if (--delayed === 0) {
          instance.insertionPoint = _this9.emitter.getBodyReference();
          _this9.residualFunctions.addFunctionInstance(instance);
        }
      };

      var _loop5 = function _loop5(boundName) {
        var residualBinding = residualBindings[boundName];
        var referencedValues = [];
        var serializeBindingFunc = void 0;
        if (!residualBinding.declarativeEnvironmentRecord) {
          serializeBindingFunc = function serializeBindingFunc() {
            return _this9._serializeGlobalBinding(boundName, residualBinding);
          };
        } else {
          serializeBindingFunc = function serializeBindingFunc() {
            return _this9._serializeDeclarativeEnvironmentRecordBinding(residualBinding);
          };
          (0, _invariant2.default)(residualBinding.value !== undefined);
          referencedValues.push(residualBinding.value);
        }
        delayed++;
        _this9.emitter.emitNowOrAfterWaitingForDependencies(referencedValues, function () {
          var serializedBinding = serializeBindingFunc();
          (0, _invariant2.default)(serializedBinding);
          serializedBindings[boundName] = serializedBinding;
          undelay();
        });
      };

      for (var boundName in residualBindings) {
        _loop5(boundName);
      }

      undelay();

      this._emitObjectProperties(val);
    }

    // Checks whether a property can be defined via simple assignment, or using object literal syntax.

  }, {
    key: "_canEmbedProperty",
    value: function _canEmbedProperty(obj, key, prop) {
      if (obj instanceof _index2.FunctionValue && key === "prototype" || obj.getKind() === "RegExp" && key === "lastIndex") return !!prop.writable && !prop.configurable && !prop.enumerable && !prop.set && !prop.get;else return !!prop.writable && !!prop.configurable && !!prop.enumerable && !prop.set && !prop.get;
    }
  }, {
    key: "_findLastObjectPrototype",
    value: function _findLastObjectPrototype(obj) {
      while (obj.$Prototype instanceof _index2.ObjectValue) {
        obj = obj.$Prototype;
      }return obj;
    }
  }, {
    key: "_serializeValueObject",
    value: function _serializeValueObject(val) {
      var _this10 = this;

      // If this object is a prototype object that was implicitly created by the runtime
      // for a constructor, then we can obtain a reference to this object
      // in a special way that's handled alongside function serialization.
      var constructor = val.originalConstructor;
      if (constructor !== undefined) {
        var prototypeId = this.residualHeapValueIdentifiers.getIdentifier(val);
        this.emitter.emitNowOrAfterWaitingForDependencies([constructor], function () {
          (0, _invariant2.default)(constructor !== undefined);
          (0, _invariant2.default)(prototypeId !== undefined);
          _this10.serializeValue(constructor);
          _this10._emitObjectProperties(val);
          (0, _invariant2.default)(prototypeId.type === "Identifier");
          _this10.residualFunctions.setFunctionPrototype(constructor, prototypeId);
        });
        return prototypeId;
      }

      var kind = val.getKind();
      switch (kind) {
        case "RegExp":
          var source = val.$OriginalSource;
          var flags = val.$OriginalFlags;
          (0, _invariant2.default)(typeof source === "string");
          (0, _invariant2.default)(typeof flags === "string");
          this._emitObjectProperties(val);
          source = new RegExp(source).source; // add escapes as per 21.2.3.2.4
          return t.regExpLiteral(source, flags);
        case "Number":
          var numberData = val.$NumberData;
          (0, _invariant2.default)(numberData !== undefined);
          numberData.throwIfNotConcreteNumber();
          (0, _invariant2.default)(numberData instanceof _index2.NumberValue, "expected number data internal slot to be a number value");
          this._emitObjectProperties(val);
          return t.newExpression(this.preludeGenerator.memoizeReference("Number"), [t.numericLiteral(numberData.value)]);
        case "String":
          var stringData = val.$StringData;
          (0, _invariant2.default)(stringData !== undefined);
          stringData.throwIfNotConcreteString();
          (0, _invariant2.default)(stringData instanceof _index2.StringValue, "expected string data internal slot to be a string value");
          this._emitObjectProperties(val);
          return t.newExpression(this.preludeGenerator.memoizeReference("String"), [t.stringLiteral(stringData.value)]);
        case "Boolean":
          var booleanData = val.$BooleanData;
          (0, _invariant2.default)(booleanData !== undefined);
          booleanData.throwIfNotConcreteBoolean();
          (0, _invariant2.default)(booleanData instanceof _index2.BooleanValue, "expected boolean data internal slot to be a boolean value");
          this._emitObjectProperties(val);
          return t.newExpression(this.preludeGenerator.memoizeReference("Boolean"), [t.booleanLiteral(booleanData.value)]);
        case "Date":
          var dateValue = val.$DateValue;
          (0, _invariant2.default)(dateValue !== undefined);
          var serializedDateValue = this.serializeValue(dateValue);
          this._emitObjectProperties(val);
          return t.newExpression(this.preludeGenerator.memoizeReference("Date"), [serializedDateValue]);
        case "Float32Array":
        case "Float64Array":
        case "Int8Array":
        case "Int16Array":
        case "Int32Array":
        case "Uint8Array":
        case "Uint16Array":
        case "Uint32Array":
        case "Uint8ClampedArray":
        case "DataView":
          return this._serializeValueTypedArrayOrDataView(val);
        case "ArrayBuffer":
          return this._serializeValueArrayBuffer(val);
        case "Map":
        case "WeakMap":
          return this._serializeValueMap(val);
        case "Set":
        case "WeakSet":
          return this._serializeValueSet(val);
        default:
          (0, _invariant2.default)(kind === "Object", "invariant established by visitor");
          (0, _invariant2.default)(this.$ParameterMap === undefined, "invariant established by visitor");

          var proto = val.$Prototype;
          var createViaAuxiliaryConstructor = proto !== this.realm.intrinsics.ObjectPrototype && this._findLastObjectPrototype(val) === this.realm.intrinsics.ObjectPrototype && proto instanceof _index2.ObjectValue;

          var remainingProperties = new Map(val.properties);
          var dummyProperties = new Set();
          var props = [];
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = val.properties[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var _ref5 = _step7.value;

              var _ref6 = _slicedToArray(_ref5, 2);

              var _key = _ref6[0];
              var propertyBinding = _ref6[1];

              var descriptor = propertyBinding.descriptor;
              if (descriptor === undefined || descriptor.value === undefined) continue; // deleted
              if (!createViaAuxiliaryConstructor && this._canEmbedProperty(val, _key, descriptor)) {
                var propValue = descriptor.value;
                (0, _invariant2.default)(propValue instanceof _index2.Value);
                if (this.residualHeapInspector.canIgnoreProperty(val, _key)) continue;
                var mightHaveBeenDeleted = propValue.mightHaveBeenDeleted();
                var serializedKey = this.generator.getAsPropertyNameExpression(_key);
                var _delayReason = this.emitter.getReasonToWaitForDependencies(propValue) || this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted);
                // Although the property needs to be delayed, we still want to emit dummy "undefined"
                // value as part of the object literal to ensure a consistent property ordering.
                var serializedValue = _internalizer.voidExpression;
                if (_delayReason) {
                  // May need to be cleaned up later.
                  dummyProperties.add(_key);
                } else {
                  remainingProperties.delete(_key);
                  serializedValue = this.serializeValue(propValue);
                }
                props.push(t.objectProperty(serializedKey, serializedValue));
              }
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }

          this._emitObjectProperties(val, remainingProperties, createViaAuxiliaryConstructor, dummyProperties);

          if (createViaAuxiliaryConstructor) {
            this.needsAuxiliaryConstructor = true;
            var serializedProto = this.serializeValue(proto);
            return t.sequenceExpression([t.assignmentExpression("=", t.memberExpression(_internalizer.constructorExpression, t.identifier("prototype")), serializedProto), t.newExpression(_internalizer.constructorExpression, [])]);
          } else {
            return t.objectExpression(props);
          }
      }
    }
  }, {
    key: "_serializeValueSymbol",
    value: function _serializeValueSymbol(val) {
      var args = [];
      if (val.$Description instanceof _index2.Value) {
        var serializedArg = this.serializeValue(val.$Description);
        (0, _invariant2.default)(serializedArg);
        args.push(serializedArg);
      }
      return t.callExpression(this.preludeGenerator.memoizeReference("Symbol"), args);
    }
  }, {
    key: "_serializeValueProxy",
    value: function _serializeValueProxy(val) {
      return t.newExpression(this.preludeGenerator.memoizeReference("Proxy"), [this.serializeValue(val.$ProxyTarget), this.serializeValue(val.$ProxyHandler)]);
    }
  }, {
    key: "_serializeAbstractValue",
    value: function _serializeAbstractValue(val) {
      var _this11 = this;

      (0, _invariant2.default)(val.kind !== "sentinel member expression", "invariant established by visitor");
      var serializedArgs = val.args.map(function (abstractArg, i) {
        return _this11.serializeValue(abstractArg);
      });
      var serializedValue = val.buildNode(serializedArgs);
      if (serializedValue.type === "Identifier") {
        var id = serializedValue;
        (0, _invariant2.default)(!this.preludeGenerator.derivedIds.has(id.name) || this.emitter.hasBeenDeclared(val));
      }
      return serializedValue;
    }
  }, {
    key: "_serializeValue",
    value: function _serializeValue(val) {
      if (val instanceof _index2.AbstractValue) {
        return this._serializeAbstractValue(val);
      } else if (val.isIntrinsic()) {
        return this._serializeValueIntrinsic(val);
      } else if (val instanceof _index2.EmptyValue) {
        this.needsEmptyVar = true;
        return _internalizer.emptyExpression;
      } else if (val instanceof _index2.UndefinedValue) {
        return _internalizer.voidExpression;
      } else if (_ResidualHeapInspector.ResidualHeapInspector.isLeaf(val)) {
        return t.valueToNode(val.serialize());
      } else if ((0, _index.IsArray)(this.realm, val)) {
        (0, _invariant2.default)(val instanceof _index2.ObjectValue);
        return this._serializeValueArray(val);
      } else if (val instanceof _index2.ProxyValue) {
        return this._serializeValueProxy(val);
      } else if (val instanceof _index2.FunctionValue) {
        return this._serializeValueFunction(val);
      } else if (val instanceof _index2.SymbolValue) {
        return this._serializeValueSymbol(val);
      } else {
        (0, _invariant2.default)(val instanceof _index2.ObjectValue);
        return this._serializeValueObject(val);
      }
    }
  }, {
    key: "_serializeGlobalBinding",
    value: function _serializeGlobalBinding(boundName, visitedBinding) {
      (0, _invariant2.default)(!visitedBinding.declarativeEnvironmentRecord);
      if (boundName === "undefined") {
        // The global 'undefined' property is not writable and not configurable, and thus we can just use 'undefined' here,
        // encoded as 'void 0' to avoid the possibility of interference with local variables named 'undefined'.
        return { serializedValue: _internalizer.voidExpression, value: undefined, modified: true, referentialized: true };
      }

      var value = this.realm.getGlobalLetBinding(boundName);
      // Check for let binding vs global property
      if (value) {
        var id = this.serializeValue(value, true, "let");
        // increment ref count one more time as the value has been
        // referentialized (stored in a variable) by serializeValue
        this.residualHeapValueIdentifiers.incrementReferenceCount(value);
        return { serializedValue: id, value: undefined, modified: true, referentialized: true };
      } else {
        return {
          serializedValue: this.preludeGenerator.globalReference(boundName),
          value: undefined,
          modified: true,
          referentialized: true
        };
      }
    }
  }, {
    key: "_getContext",
    value: function _getContext() {
      var _this12 = this;

      // TODO #482: Values serialized by nested generators would currently only get defined
      // along the code of the nested generator; their definitions need to get hoisted
      // or repeated so that they are accessible and defined from all using scopes
      var context = {
        serializeValue: this.serializeValue.bind(this),
        serializeGenerator: function serializeGenerator(generator) {
          var newBody = [];
          var oldBody = _this12.emitter.beginEmitting(generator, newBody);
          _this12.activeGeneratorBodies.set(generator, newBody);
          generator.serialize(context);
          _this12.activeGeneratorBodies.delete(generator);
          return _this12.emitter.endEmitting(generator, oldBody);
        },
        emit: function emit(statement) {
          _this12.emitter.emit(statement);
        },
        canOmit: function canOmit(value) {
          return !_this12.referencedDeclaredValues.has(value);
        },
        declare: function declare(value) {
          _this12.emitter.declare(value);
        }
      };
      return context;
    }
  }, {
    key: "_shouldBeWrapped",
    value: function _shouldBeWrapped(body) {
      for (var i = 0; i < body.length; i++) {
        var item = body[i];
        if (item.type === "ExpressionStatement") {
          continue;
        } else if (item.type === "VariableDeclaration" || item.type === "FunctionDeclaration") {
          return true;
        } else if (item.type === "BlockStatement") {
          if (this._shouldBeWrapped(item.body)) {
            return true;
          }
        } else if (item.type === "IfStatement") {
          if (item.alternate) {
            if (this._shouldBeWrapped(item.alternate.body)) {
              return true;
            }
          }
          if (item.consequent) {
            if (this._shouldBeWrapped(item.consequent.body)) {
              return true;
            }
          }
        }
      }
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      this.generator.serialize(this._getContext());
      (0, _invariant2.default)(this.emitter._declaredAbstractValues.size <= this.preludeGenerator.derivedIds.size);

      Array.prototype.push.apply(this.prelude, this.preludeGenerator.prelude);

      // TODO #20: add timers

      // TODO #21: add event listeners
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.modules.initializedModules[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var _ref7 = _step8.value;

          var _ref8 = _slicedToArray(_ref7, 2);

          var moduleId = _ref8[0];
          var moduleValue = _ref8[1];

          this.requireReturns.set(moduleId, this.serializeValue(moduleValue));
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      this.emitter.finalize();

      var _residualFunctions$sp = this.residualFunctions.spliceFunctions(),
          unstrictFunctionBodies = _residualFunctions$sp.unstrictFunctionBodies,
          strictFunctionBodies = _residualFunctions$sp.strictFunctionBodies,
          requireStatistics = _residualFunctions$sp.requireStatistics;

      if (requireStatistics.replaced > 0 && !this.residualHeapValueIdentifiers.collectValToRefCountOnly) {
        console.log("=== " + this.modules.initializedModules.size + " of " + this.modules.moduleIds.size + " modules initialized, " + requireStatistics.replaced + " of " + requireStatistics.count + " require calls inlined.");
      }

      // add strict modes
      var strictDirective = t.directive(t.directiveLiteral("use strict"));
      var globalDirectives = [];
      if (!this.realm.isStrict && !unstrictFunctionBodies.length && strictFunctionBodies.length) {
        // no unstrict functions, only strict ones
        globalDirectives.push(strictDirective);
      } else if (unstrictFunctionBodies.length && strictFunctionBodies.length) {
        // strict and unstrict functions
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          funcLoop: for (var _iterator9 = strictFunctionBodies[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var func = _step9.value;

            if (func.body.directives) {
              var _iteratorNormalCompletion10 = true;
              var _didIteratorError10 = false;
              var _iteratorError10 = undefined;

              try {
                for (var _iterator10 = func.body.directives[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                  var directive = _step10.value;

                  if (directive.value.value === "use strict") {
                    // already have a use strict directive
                    continue funcLoop;
                  }
                }
              } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion10 && _iterator10.return) {
                    _iterator10.return();
                  }
                } finally {
                  if (_didIteratorError10) {
                    throw _iteratorError10;
                  }
                }
              }
            } else func.body.directives = [];

            func.body.directives.unshift(strictDirective);
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9.return) {
              _iterator9.return();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      }

      // build ast
      if (this.needsEmptyVar) {
        this.prelude.push(t.variableDeclaration("var", [t.variableDeclarator(_internalizer.emptyExpression, t.objectExpression([]))]));
      }
      if (this.needsAuxiliaryConstructor) {
        this.prelude.push(t.variableDeclaration("var", [t.variableDeclarator(_internalizer.constructorExpression, t.functionExpression(null, [], t.blockStatement([])))]));
      }
      var body = this.prelude.concat(this.emitter.getBody());
      (0, _factorify.factorifyObjects)(body, this.factoryNameGenerator);

      var ast_body = [];
      if (this.preludeGenerator.declaredGlobals.size > 0) ast_body.push(t.variableDeclaration("var", Array.from(this.preludeGenerator.declaredGlobals).map(function (key) {
        return t.variableDeclarator(t.identifier(key));
      })));
      if (body.length) {
        if (this.realm.isCompatibleWith("node-source-maps")) {
          ast_body.push(t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.identifier("require"), [t.stringLiteral("source-map-support")]), t.identifier("install")), [])));
        }

        if (this._shouldBeWrapped(body)) {
          var globalExpression = this.realm.isCompatibleWith("node-cli") ? t.identifier("global") : t.thisExpression();

          var functionExpression = t.functionExpression(null, [], t.blockStatement(body, globalDirectives));
          var callExpression = this.preludeGenerator.usesThis ? t.callExpression(t.memberExpression(functionExpression, t.identifier("call")), [globalExpression]) : t.callExpression(functionExpression, []);
          ast_body.push(t.expressionStatement(callExpression));
        } else {
          ast_body = body;
        }
      }

      (0, _invariant2.default)(this.serializedValues.size === this.residualValues.size, "serialized " + this.serializedValues.size + " of " + this.residualValues.size);

      var program_directives = [];
      if (this.realm.isStrict) program_directives.push(strictDirective);
      return t.file(t.program(ast_body, program_directives));
    }
  }]);

  return ResidualHeapSerializer;
}();
//# sourceMappingURL=ResidualHeapSerializer.js.map