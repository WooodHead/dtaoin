{"version":3,"sources":["../../src/serializer/modules.js"],"names":["t","downgradeErrorsToWarnings","realm","f","savedHandler","errorHandler","handler","e","severity","handleError","ModuleTracer","modules","logModules","evaluateForEffectsNesting","requireStack","requireSequence","uninitializedModuleIdsRequiredInEvaluateForEffects","Set","message","console","log","map","join","state","push","undefined","effects","popped","pop","F","thisArgument","argumentsList","newTarget","performCall","getRequire","disallowDelayingRequiresOverride","length","moduleId","moduleIdValue","value","moduleIds","has","delayUnsupportedRequires","logger","logError","recordModuleInitialized","isTopLevelRequire","diagnostic","currentLocation","isModuleInitialized","add","result","requireSequenceStart","acceleratedModuleIds","evaluateForEffects","err","nestedModuleId","nestedEffects","tryInitializeModule","clear","nestedModulesIds","i","deriveAbstract","topVal","callExpression","identifier","valueToNode","applyEffects","getDefine","factoryFunction","factoryFunctions","Modules","_require","intrinsics","_define","initializedModules","Map","tracers","moduleTracer","globalInitializedModulesMap","_getGlobalProperty","getOwnPropertyKeysArray","property","properties","get","moduleValue","descriptor","set","name","active","tryQuery","$GlobalObject","formalParameters","functions","scope","node","isIdentifier","callee","arguments","argument","isNumericLiteral","isStringLiteral","innerName","scopedBinding","getBinding","path","kind","doesNotMatter","reference","$Environment","referencedBase","base","referencedName","binding","bindings","initialized","assignToGlobal","memberExpression","previousDisallowDelayingRequiresOverride","evaluateNodeForEffectsInGlobalEnv","logCompletion","count","oldReadOnly","setReadOnly","oldDisallowDelayingRequiresOverride","compl","generator","createdObjects","body","escapes","object"],"mappings":"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","file":"modules.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { GlobalEnvironmentRecord, DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { Realm, Tracer } from \"../realm.js\";\nimport type { Effects } from \"../realm.js\";\nimport { IsUnresolvableReference, ResolveBinding, Get } from \"../methods/index.js\";\nimport { AbruptCompletion, Completion, PossiblyNormalCompletion, ThrowCompletion } from \"../completions.js\";\nimport { Value, FunctionValue, ObjectValue, NumberValue, StringValue } from \"../values/index.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeIdentifier, BabelNodeLVal, BabelNodeCallExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Logger } from \"./logger.js\";\n\nfunction downgradeErrorsToWarnings(realm: Realm, f: () => any) {\n  let savedHandler = realm.errorHandler;\n  function handler(e) {\n    e.severity = \"Warning\";\n    realm.errorHandler = savedHandler;\n    try {\n      return realm.handleError(e);\n    } finally {\n      realm.errorHandler = handler;\n    }\n  }\n  realm.errorHandler = handler;\n  try {\n    return f();\n  } finally {\n    realm.errorHandler = savedHandler;\n  }\n}\n\nexport class ModuleTracer extends Tracer {\n  constructor(modules: Modules, logModules: boolean) {\n    super();\n    this.modules = modules;\n    this.evaluateForEffectsNesting = 0;\n    this.requireStack = [];\n    this.requireSequence = [];\n    this.logModules = logModules;\n    this.uninitializedModuleIdsRequiredInEvaluateForEffects = new Set();\n  }\n\n  modules: Modules;\n  evaluateForEffectsNesting: number;\n  requireStack: Array<number | string | void>;\n  requireSequence: Array<number | string>;\n  uninitializedModuleIdsRequiredInEvaluateForEffects: Set<number | string>;\n  // We can't say that a module has been initialized if it was initialized in a\n  // evaluate for effects context until we know the effects are applied.\n  logModules: boolean;\n\n  log(message: string) {\n    if (this.logModules) console.log(`[modules] ${this.requireStack.map(_ => \"  \").join(\"\")}${message}`);\n  }\n\n  beginEvaluateForEffects(state: any) {\n    if (state !== this) {\n      this.log(\">evaluate for effects\");\n      this.evaluateForEffectsNesting++;\n      this.requireStack.push(undefined);\n    }\n  }\n\n  endEvaluateForEffects(state: any, effects: void | Effects) {\n    if (state !== this) {\n      let popped = this.requireStack.pop();\n      invariant(popped === undefined);\n      this.evaluateForEffectsNesting--;\n      this.log(\"<evaluate for effects\");\n    }\n  }\n\n  detourCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    performCall: () => Value\n  ): void | Value {\n    let realm = this.modules.realm;\n    if (\n      F === this.modules.getRequire() &&\n      !this.modules.disallowDelayingRequiresOverride &&\n      argumentsList.length === 1\n    ) {\n      let moduleId = argumentsList[0];\n      let moduleIdValue;\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue) {\n        moduleIdValue = moduleId.value;\n        if (!this.modules.moduleIds.has(moduleIdValue) && this.modules.delayUnsupportedRequires) {\n          this.modules.logger.logError(moduleId, \"Module referenced by require call has not been defined.\");\n        }\n      } else {\n        if (this.modules.delayUnsupportedRequires) {\n          this.modules.logger.logError(moduleId, \"First argument to require function is not a number or string value.\");\n        }\n        return undefined;\n      }\n\n      if (!this.modules.delayUnsupportedRequires) {\n        if (\n          (this.requireStack.length === 0 || this.requireStack[this.requireStack.length - 1] !== moduleIdValue) &&\n          this.modules.moduleIds.has(moduleIdValue)\n        ) {\n          this.requireStack.push(moduleIdValue);\n          try {\n            let value = performCall();\n            this.modules.recordModuleInitialized(moduleIdValue, value);\n            return value;\n          } finally {\n            invariant(this.requireStack.pop() === moduleIdValue);\n          }\n        }\n        return undefined;\n      }\n\n      // If a require fails, recover from it and delay the factory call until runtime\n      this.log(`>require(${moduleIdValue})`);\n      let isTopLevelRequire = this.requireStack.length === 0;\n      if (this.evaluateForEffectsNesting > 0) {\n        if (isTopLevelRequire) {\n          let diagnostic = new CompilerDiagnostic(\n            \"Non-deterministically conditional top-level require not currently supported\",\n            realm.currentLocation,\n            \"PP0017\",\n            \"FatalError\"\n          );\n          realm.handleError(diagnostic);\n          throw new FatalError();\n        } else if (!this.modules.isModuleInitialized(moduleIdValue))\n          this.uninitializedModuleIdsRequiredInEvaluateForEffects.add(moduleIdValue);\n        return undefined;\n      } else {\n        return downgradeErrorsToWarnings(realm, () => {\n          let result;\n          try {\n            this.requireStack.push(moduleIdValue);\n            let requireSequenceStart = this.requireSequence.length;\n            this.requireSequence.push(moduleIdValue);\n            let acceleratedModuleIds, effects;\n            do {\n              try {\n                effects = realm.evaluateForEffects(() => {\n                  try {\n                    return performCall();\n                  } catch (e) {\n                    if (e instanceof Completion) return e;\n                    throw e;\n                  }\n                }, this);\n              } catch (err) {\n                if (err instanceof FatalError) effects = undefined;\n                else throw err;\n              }\n\n              acceleratedModuleIds = [];\n              if (isTopLevelRequire) {\n                // We gathered all effects, but didn't apply them yet.\n                // Let's check if there was any call to `require` in a\n                // evaluate-for-effects context. If so, try to initialize\n                // that module right now. Acceleration module initialization in this\n                // way might not actually be desirable, but it works around\n                // general prepack-limitations around joined abstract values involving\n                // conditionals. Long term, Prepack needs to implement a notion of refinement\n                // of conditional abstract values under the known path condition.\n                for (let nestedModuleId of this.uninitializedModuleIdsRequiredInEvaluateForEffects) {\n                  let nestedEffects = this.modules.tryInitializeModule(\n                    nestedModuleId,\n                    `accelerated initialization of conditional module ${nestedModuleId} as it's required in an evaluate-for-effects context by module ${moduleIdValue}`\n                  );\n                  if (\n                    nestedEffects !== undefined &&\n                    nestedEffects[0] instanceof Value &&\n                    this.modules.isModuleInitialized(nestedModuleId)\n                  ) {\n                    acceleratedModuleIds.push(nestedModuleId);\n                  }\n                }\n                this.uninitializedModuleIdsRequiredInEvaluateForEffects.clear();\n                // Keep restarting for as long as we find additional modules to accelerate.\n                if (acceleratedModuleIds.length > 0) {\n                  console.log(\n                    `restarting require(${moduleIdValue}) after accelerating conditional require calls for ${acceleratedModuleIds.join()}`\n                  );\n                }\n              }\n            } while (acceleratedModuleIds.length > 0);\n\n            if (effects !== undefined) {\n              result = effects[0];\n              invariant(result instanceof Value || result instanceof Completion);\n              if (result instanceof PossiblyNormalCompletion) {\n                effects = undefined;\n              }\n            }\n\n            if (effects === undefined) {\n              console.log(`delaying require(${moduleIdValue})`);\n              // So we are about to emit a delayed require(...) call.\n              // However, before we do that, let's try to require all modules that we\n              // know this delayed require call will require.\n              // This way, we ensure that those modules will be fully initialized\n              // before the require call executes.\n              // TODO #690: More needs to be done to make the delayUnsupportedRequires\n              // feature completely safe. Open issues are:\n              // 1) Side-effects on the heap of delayed factory functions are not discovered or rejected.\n              // 2) While we do process an appropriate list of transitively required modules here,\n              //    it's likely just a subset / prefix of all transivitely required modules, as\n              //    more modules would have been required if the Introspection exception had not been thrown.\n              //    To be correct, those modules would have to be prepacked here as well.\n              //    TODO #798: Watch out for an upcoming change to the __d module declaration where the statically known\n              //    list of dependencies will be announced, so we'll no longer have to guess.\n              let nestedModulesIds = new Set();\n              for (let i = requireSequenceStart; i < this.requireSequence.length; i++) {\n                let nestedModuleId = this.requireSequence[i];\n                if (nestedModulesIds.has(nestedModuleId)) continue;\n                nestedModulesIds.add(nestedModuleId);\n                this.modules.tryInitializeModule(\n                  nestedModuleId,\n                  `initialization of module ${nestedModuleId} as it's required by module ${moduleIdValue}`\n                );\n              }\n\n              result = realm.deriveAbstract(TypesDomain.topVal, ValuesDomain.topVal, [], ([]) =>\n                t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleIdValue)])\n              );\n            } else {\n              invariant(result);\n              if (!(result instanceof Completion)) {\n                this.modules.recordModuleInitialized(moduleIdValue, result);\n              }\n              realm.applyEffects(effects, `initialization of module ${moduleIdValue}`);\n            }\n          } finally {\n            let popped = this.requireStack.pop();\n            invariant(popped === moduleIdValue);\n            let message = \"\";\n            if (result instanceof ThrowCompletion) message = \" threw an error\";\n            this.log(`<require(${moduleIdValue})${message}`);\n          }\n          if (result instanceof Completion) throw result;\n          return result;\n        });\n      }\n    } else if (F === this.modules.getDefine()) {\n      if (this.evaluateForEffectsNesting !== 0)\n        this.modules.logger.logError(F, \"Defining a module in nested partial evaluation is not supported.\");\n      let factoryFunction = argumentsList[0];\n      if (factoryFunction instanceof FunctionValue) this.modules.factoryFunctions.add(factoryFunction);\n      else this.modules.logger.logError(factoryFunction, \"First argument to define function is not a function value.\");\n      let moduleId = argumentsList[1];\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue)\n        this.modules.moduleIds.add(moduleId.value);\n      else\n        this.modules.logger.logError(moduleId, \"Second argument to define function is not a number or string value.\");\n    }\n    return undefined;\n  }\n}\n\nexport class Modules {\n  constructor(realm: Realm, logger: Logger, logModules: boolean, delayUnsupportedRequires: boolean) {\n    this.realm = realm;\n    this.logger = logger;\n    this._require = realm.intrinsics.undefined;\n    this._define = realm.intrinsics.undefined;\n    this.factoryFunctions = new Set();\n    this.moduleIds = new Set();\n    this.initializedModules = new Map();\n    realm.tracers.push((this.moduleTracer = new ModuleTracer(this, logModules)));\n    this.delayUnsupportedRequires = delayUnsupportedRequires;\n    this.disallowDelayingRequiresOverride = false;\n  }\n\n  realm: Realm;\n  logger: Logger;\n  _require: Value;\n  _define: Value;\n  factoryFunctions: Set<FunctionValue>;\n  moduleIds: Set<number | string>;\n  initializedModules: Map<number | string, Value>;\n  active: boolean;\n  delayUnsupportedRequires: boolean;\n  disallowDelayingRequiresOverride: boolean;\n  moduleTracer: ModuleTracer;\n\n  resolveInitializedModules(): void {\n    let globalInitializedModulesMap = this._getGlobalProperty(\"__initializedModules\");\n    invariant(globalInitializedModulesMap instanceof ObjectValue);\n    for (let moduleId of globalInitializedModulesMap.getOwnPropertyKeysArray()) {\n      let property = globalInitializedModulesMap.properties.get(moduleId);\n      invariant(property);\n      let moduleValue = property.descriptor && property.descriptor.value;\n      invariant(moduleValue);\n      this.initializedModules.set(moduleId, moduleValue);\n    }\n  }\n\n  _getGlobalProperty(name: string): Value {\n    if (this.active) return this.realm.intrinsics.undefined;\n    this.active = true;\n    try {\n      let realm = this.realm;\n      return this.logger.tryQuery(() => Get(realm, realm.$GlobalObject, name), realm.intrinsics.undefined, false);\n    } finally {\n      this.active = false;\n    }\n  }\n\n  getRequire(): Value {\n    if (!(this._require instanceof FunctionValue)) this._require = this._getGlobalProperty(\"require\");\n    return this._require;\n  }\n\n  getDefine(): Value {\n    if (!(this._define instanceof FunctionValue)) this._define = this._getGlobalProperty(\"__d\");\n    return this._define;\n  }\n\n  getIsRequire(\n    formalParameters: Array<BabelNodeLVal>,\n    functions: Array<FunctionValue>\n  ): (scope: any, node: BabelNodeCallExpression) => boolean {\n    let realm = this.realm;\n    let logger = this.logger;\n    let modules = this;\n    return function(scope: any, node: BabelNodeCallExpression) {\n      if (!t.isIdentifier(node.callee) || node.arguments.length !== 1 || !node.arguments[0]) return false;\n      let argument = node.arguments[0];\n      if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument)) return false;\n\n      invariant(node.callee);\n      let innerName = ((node.callee: any): BabelNodeIdentifier).name;\n\n      for (let f of functions) {\n        let scopedBinding = scope.getBinding(innerName);\n        if (scopedBinding) {\n          if (modules.factoryFunctions.has(f) && formalParameters[1] === scopedBinding.path.node) {\n            invariant(scopedBinding.kind === \"param\");\n            continue;\n          }\n          // The name binds to some local entity, but nothing we'd know what exactly it is\n          return false;\n        }\n\n        let doesNotMatter = true;\n        let reference = logger.tryQuery(\n          () => ResolveBinding(realm, innerName, doesNotMatter, f.$Environment),\n          undefined,\n          false\n        );\n        if (reference === undefined) {\n          // We couldn't resolve as we came across some behavior that we cannot deal with abstractly\n          return false;\n        }\n        if (IsUnresolvableReference(realm, reference)) return false;\n        let referencedBase = reference.base;\n        let referencedName: string = (reference.referencedName: any);\n        if (typeof referencedName !== \"string\") return false;\n        let value;\n        if (reference.base instanceof GlobalEnvironmentRecord) {\n          value = logger.tryQuery(() => Get(realm, realm.$GlobalObject, innerName), realm.intrinsics.undefined, false);\n        } else {\n          invariant(referencedBase instanceof DeclarativeEnvironmentRecord);\n          let binding = referencedBase.bindings[referencedName];\n          if (!binding.initialized) return false;\n          value = binding.value;\n        }\n        if (value !== modules.getRequire()) return false;\n      }\n\n      return true;\n    };\n  }\n\n  recordModuleInitialized(moduleId: number | string, value: Value) {\n    this.realm.assignToGlobal(\n      t.memberExpression(\n        t.memberExpression(t.identifier(\"global\"), t.identifier(\"__initializedModules\")),\n        t.identifier(\"\" + moduleId)\n      ),\n      value\n    );\n  }\n\n  tryInitializeModule(moduleId: number | string, message: string): void | Effects {\n    let realm = this.realm;\n    let previousDisallowDelayingRequiresOverride = this.disallowDelayingRequiresOverride;\n    this.disallowDelayingRequiresOverride = true;\n    return downgradeErrorsToWarnings(realm, () => {\n      try {\n        let node = t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleId)]);\n\n        let effects = realm.evaluateNodeForEffectsInGlobalEnv(node);\n        realm.applyEffects(effects, message);\n        let result = effects[0];\n        if (result instanceof Completion) {\n          console.log(`=== UNEXPECTED ERROR during ${message} ===`);\n          this.logger.logCompletion(result);\n          return undefined;\n        }\n\n        if (result instanceof Value) this.recordModuleInitialized(moduleId, result);\n        return effects;\n      } catch (err) {\n        if (err instanceof FatalError) return undefined;\n        else throw err;\n      } finally {\n        this.disallowDelayingRequiresOverride = previousDisallowDelayingRequiresOverride;\n      }\n    });\n  }\n\n  initializeMoreModules() {\n    // partially evaluate all factory methods by calling require\n    let count = 0;\n    for (let moduleId of this.moduleIds) {\n      if (this.initializedModules.has(moduleId)) continue;\n      let effects = this.tryInitializeModule(moduleId, `Speculative initialization of module ${moduleId}`);\n      if (effects === undefined) continue;\n      let result = effects[0];\n      invariant(result instanceof Value);\n      count++;\n      this.initializedModules.set(moduleId, result);\n    }\n    if (count > 0) console.log(`=== speculatively initialized ${count} additional modules`);\n  }\n\n  isModuleInitialized(moduleId: number | string): void | Value {\n    let realm = this.realm;\n    let oldReadOnly = realm.setReadOnly(true);\n    let oldDisallowDelayingRequiresOverride = this.disallowDelayingRequiresOverride;\n    this.disallowDelayingRequiresOverride = true;\n    try {\n      let node = t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleId)]);\n\n      let [compl, generator, bindings, properties, createdObjects] = realm.evaluateNodeForEffectsInGlobalEnv(node);\n      // for lint unused\n      invariant(bindings);\n\n      if (compl instanceof AbruptCompletion) return undefined;\n      invariant(compl instanceof Value);\n\n      if (generator.body.length !== 0 || (compl instanceof ObjectValue && createdObjects.has(compl))) return undefined;\n      // Check for escaping property assignments, if none escape, we got an existing object\n      let escapes = false;\n      for (let [binding] of properties) {\n        if (!createdObjects.has(binding.object)) escapes = true;\n      }\n      if (escapes) return undefined;\n\n      return compl;\n    } catch (err) {\n      if (err instanceof FatalError) return undefined;\n      throw err;\n    } finally {\n      realm.setReadOnly(oldReadOnly);\n      this.disallowDelayingRequiresOverride = oldDisallowDelayingRequiresOverride;\n    }\n  }\n}\n"]}