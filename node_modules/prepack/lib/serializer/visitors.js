"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClosureRefVisitor = exports.ClosureRefReplacer = undefined;

var _realm = require("../realm.js");

var _index = require("../values/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _babelTraverse = require("babel-traverse");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function markVisited(node, data) {
  node._renamedOnce = data;
}

function shouldVisit(node, data) {
  return node._renamedOnce !== data;
}

// replaceWith causes the node to be re-analysed, so to prevent double replacement
// we add this property on the node to mark it such that it does not get replaced
// again on this pass
// TODO: Make this work when replacing with arbitrary BabelNodeExpressions. Currently
//       if the node that we're substituting contains identifiers as children,
//       they will be visited again and possibly transformed.
//       If necessary we could implement this by following node.parentPath and checking
//       if any parent nodes are marked visited, but that seem unnecessary right now.let closureRefReplacer = {
function replaceName(path, serializedBinding, name, data) {
  if (path.scope.hasBinding(name, /*noGlobals*/true)) return;

  if (serializedBinding && shouldVisit(path.node, data)) {
    markVisited(serializedBinding.serializedValue, data);
    path.replaceWith(serializedBinding.serializedValue);
  }
}

var ClosureRefReplacer = exports.ClosureRefReplacer = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (ignorePath(path)) return;

    var serializedBindings = state.serializedBindings;
    var name = path.node.name;
    var serializedBinding = serializedBindings[name];
    if (serializedBinding) replaceName(path, serializedBinding, name, serializedBindings);
  },
  CallExpression: function CallExpression(path, state) {
    // Here we apply the require optimization by replacing require calls with their
    // corresponding initialized modules.
    var requireReturns = state.requireReturns;
    if (!state.isRequire || !state.isRequire(path.scope, path.node)) return;
    state.requireStatistics.count++;
    if (state.modified[path.node.callee.name]) return;

    var moduleId = "" + path.node.arguments[0].value;
    var new_node = requireReturns.get(moduleId);
    if (new_node !== undefined) {
      markVisited(new_node, state.serializedBindings);
      path.replaceWith(new_node);
      state.requireStatistics.replaced++;
    }
  },
  "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path, state) {
    var serializedBindings = state.serializedBindings;
    var ids = path.getBindingIdentifierPaths();
    for (var name in ids) {
      var serializedBinding = serializedBindings[name];
      if (serializedBinding) {
        var nestedPath = ids[name];
        replaceName(nestedPath, serializedBinding, name, serializedBindings);
      }
    }
  }
};

function visitName(path, state, name, modified) {
  // Is the name bound to some local identifier? If so, we don't need to do anything
  if (path.scope.hasBinding(name, /*noGlobals*/true)) return;

  // Otherwise, let's record that there's an unbound identifier
  state.functionInfo.unbound[name] = true;
  if (modified) state.functionInfo.modified[name] = true;
}

function ignorePath(path) {
  var parent = path.parent;
  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);
}

// TODO #886: doesn't check that `arguments` and `this` is in top function
var ClosureRefVisitor = exports.ClosureRefVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (ignorePath(path)) return;

    var innerName = path.node.name;
    if (innerName === "arguments") {
      state.functionInfo.usesArguments = true;
      return;
    }
    visitName(path, state, innerName, false);
  },
  ThisExpression: function ThisExpression(path, state) {
    state.functionInfo.usesThis = true;
  },
  "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path, state) {
    for (var name in path.getBindingIdentifiers()) {
      visitName(path, state, name, true);
    }
  }
};
//# sourceMappingURL=visitors.js.map