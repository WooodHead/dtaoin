{"version":3,"sources":["../../src/serializer/visitors.js"],"names":["t","markVisited","node","data","_renamedOnce","shouldVisit","replaceName","path","serializedBinding","name","scope","hasBinding","serializedValue","replaceWith","ClosureRefReplacer","ReferencedIdentifier","state","ignorePath","serializedBindings","CallExpression","requireReturns","isRequire","requireStatistics","count","modified","callee","moduleId","arguments","value","new_node","get","undefined","replaced","ids","getBindingIdentifierPaths","nestedPath","visitName","functionInfo","unbound","parent","isLabeledStatement","isBreakStatement","isContinueStatement","ClosureRefVisitor","innerName","usesArguments","ThisExpression","usesThis","getBindingIdentifiers"],"mappings":"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","file":"visitors.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport { FunctionValue } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeExpression, BabelNodeCallExpression } from \"babel-types\";\nimport { BabelTraversePath } from \"babel-traverse\";\nimport type { TryQuery, FunctionInfo, Names } from \"./types.js\";\n\nexport type ClosureRefVisitorState = {\n  tryQuery: TryQuery<*>,\n  val: FunctionValue,\n  functionInfo: FunctionInfo,\n  realm: Realm,\n};\n\nexport type ClosureRefReplacerState = {\n  serializedBindings: any,\n  modified: Names,\n  requireReturns: Map<number | string, BabelNodeExpression>,\n  requireStatistics: { replaced: 0, count: 0 },\n  isRequire: void | ((scope: any, node: BabelNodeCallExpression) => boolean),\n};\n\nfunction markVisited(node, data) {\n  (node: any)._renamedOnce = data;\n}\n\nfunction shouldVisit(node, data) {\n  return (node: any)._renamedOnce !== data;\n}\n\n// replaceWith causes the node to be re-analysed, so to prevent double replacement\n// we add this property on the node to mark it such that it does not get replaced\n// again on this pass\n// TODO: Make this work when replacing with arbitrary BabelNodeExpressions. Currently\n//       if the node that we're substituting contains identifiers as children,\n//       they will be visited again and possibly transformed.\n//       If necessary we could implement this by following node.parentPath and checking\n//       if any parent nodes are marked visited, but that seem unnecessary right now.let closureRefReplacer = {\nfunction replaceName(path, serializedBinding, name, data) {\n  if (path.scope.hasBinding(name, /*noGlobals*/ true)) return;\n\n  if (serializedBinding && shouldVisit(path.node, data)) {\n    markVisited(serializedBinding.serializedValue, data);\n    path.replaceWith(serializedBinding.serializedValue);\n  }\n}\n\nexport let ClosureRefReplacer = {\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    if (ignorePath(path)) return;\n\n    let serializedBindings = state.serializedBindings;\n    let name = path.node.name;\n    let serializedBinding = serializedBindings[name];\n    if (serializedBinding) replaceName(path, serializedBinding, name, serializedBindings);\n  },\n\n  CallExpression(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    // Here we apply the require optimization by replacing require calls with their\n    // corresponding initialized modules.\n    let requireReturns = state.requireReturns;\n    if (!state.isRequire || !state.isRequire(path.scope, path.node)) return;\n    state.requireStatistics.count++;\n    if (state.modified[path.node.callee.name]) return;\n\n    let moduleId = \"\" + path.node.arguments[0].value;\n    let new_node = requireReturns.get(moduleId);\n    if (new_node !== undefined) {\n      markVisited(new_node, state.serializedBindings);\n      path.replaceWith(new_node);\n      state.requireStatistics.replaced++;\n    }\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    let serializedBindings = state.serializedBindings;\n    let ids = path.getBindingIdentifierPaths();\n    for (let name in ids) {\n      let serializedBinding = serializedBindings[name];\n      if (serializedBinding) {\n        let nestedPath = ids[name];\n        replaceName(nestedPath, serializedBinding, name, serializedBindings);\n      }\n    }\n  },\n};\n\nfunction visitName(path, state, name, modified) {\n  // Is the name bound to some local identifier? If so, we don't need to do anything\n  if (path.scope.hasBinding(name, /*noGlobals*/ true)) return;\n\n  // Otherwise, let's record that there's an unbound identifier\n  state.functionInfo.unbound[name] = true;\n  if (modified) state.functionInfo.modified[name] = true;\n}\n\nfunction ignorePath(path: BabelTraversePath) {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\n// TODO #886: doesn't check that `arguments` and `this` is in top function\nexport let ClosureRefVisitor = {\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      state.functionInfo.usesArguments = true;\n      return;\n    }\n    visitName(path, state, innerName, false);\n  },\n\n  ThisExpression(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    state.functionInfo.usesThis = true;\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    for (let name in path.getBindingIdentifiers()) {\n      visitName(path, state, name, true);\n    }\n  },\n};\n"]}