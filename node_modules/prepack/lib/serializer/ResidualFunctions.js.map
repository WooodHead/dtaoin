{"version":3,"sources":["../../src/serializer/ResidualFunctions.js"],"names":["t","ResidualFunctions","realm","statistics","modules","requireReturns","locationService","prelude","initializerNameGenerator","factoryNameGenerator","scopeNameGenerator","residualFunctionInfos","capturedScopeInstanceIdx","capturedScopesArray","identifier","generate","serializedScopes","Map","functionPrototypes","firstFunctionUsages","functions","functionInstances","residualFunctionInitializers","instance","push","code","functionValue","$ECMAScriptCode","get","undefined","set","constructor","prototypeId","val","bodyReference","has","serializedBinding","declarativeEnvironmentRecord","scope","name","id","initializationValues","unbound","instances","serializedBindings","modified","referentialized","_getSerializedBindingScopeInstance","capturedScope","serializedValue","memberExpression","scopeInstances","add","properties","entries","variableName","value","objectProperty","initExpression","capturedScopeId","variableDeclaration","variableDeclarator","ifStatement","unaryExpression","expressionStatement","assignmentExpression","objectExpression","scrubFunctionInitializers","functionBodies","getFunctionBody","b","requireStatistics","replaced","count","functionEntries","Array","from","length","unstrictFunctionBodies","strictFunctionBodies","funcNodes","funcBody","functionInfo","_referentialize","usesThis","usesArguments","params","$FormalParameters","shouldInline","start","end","bodySize","define","funcId","funcNode","body","isFunctionExpression","isCallExpression","declaration","getLocation","functionClones","funcParams","slice","functionExpression","cloneDeep","scopeInitialization","numericLiteral","concat","_getReferentializedScopeInitialization","file","program","isRequire","getIsRequire","$Strict","instanceBatches","newInstanceBatches","batch","bindingLookup","functionInstance","found","binding","group","matchingInstances","suffix","__originalName","factoryId","factoryNames","sameSerializedBindings","Object","create","isDifferent","lastBinding","factoryParams","key","factoryNode","factoryDeclaration","map","insertionPoint","functionId","flatArgs","firstUsage","hasInitializerStatement","isNotEarlierThan","callArgs","thisExpression","flatArg","param","type","callee","childBody","blockStatement","returnStatement","callExpression","scopeVar","unshift","reverse","functionBody","prototype","splice","apply","index","initializerStatement","getInitializerStatement"],"mappings":"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","file":"ResidualFunctions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { Realm } from \"../realm.js\";\nimport { FunctionValue } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeSpreadElement,\n  BabelNodeFunctionExpression,\n  BabelNodeIfStatement,\n  BabelNodeVariableDeclaration,\n} from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\nimport traverse from \"babel-traverse\";\nimport invariant from \"../invariant.js\";\nimport type { SerializedBinding, ScopeBinding, FunctionInfo, FunctionInstance, Names } from \"./types.js\";\nimport { BodyReference, AreSameSerializedBindings, SerializerStatistics } from \"./types.js\";\nimport { ClosureRefReplacer } from \"./visitors.js\";\nimport { Modules } from \"./modules.js\";\nimport { ResidualFunctionInitializers } from \"./ResidualFunctionInitializers.js\";\nimport { nullExpression } from \"../utils/internalizer.js\";\nimport type { LocationService } from \"./types.js\";\n\ntype ResidualFunctionsResult = {\n  unstrictFunctionBodies: Array<BabelNodeFunctionExpression>,\n  strictFunctionBodies: Array<BabelNodeFunctionExpression>,\n  requireStatistics: { replaced: number, count: number },\n};\n\nexport class ResidualFunctions {\n  constructor(\n    realm: Realm,\n    statistics: SerializerStatistics,\n    modules: Modules,\n    requireReturns: Map<number | string, BabelNodeExpression>,\n    locationService: LocationService,\n    prelude: Array<BabelNodeStatement>,\n    initializerNameGenerator: NameGenerator,\n    factoryNameGenerator: NameGenerator,\n    scopeNameGenerator: NameGenerator,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>\n  ) {\n    this.realm = realm;\n    this.statistics = statistics;\n    this.modules = modules;\n    this.requireReturns = requireReturns;\n    this.locationService = locationService;\n    this.prelude = prelude;\n    this.factoryNameGenerator = factoryNameGenerator;\n    this.scopeNameGenerator = scopeNameGenerator;\n    this.capturedScopeInstanceIdx = 0;\n    this.capturedScopesArray = t.identifier(this.scopeNameGenerator.generate(\"main\"));\n    this.serializedScopes = new Map();\n    this.functionPrototypes = new Map();\n    this.firstFunctionUsages = new Map();\n    this.functions = new Map();\n    this.functionInstances = [];\n    this.residualFunctionInitializers = new ResidualFunctionInitializers(\n      locationService,\n      prelude,\n      initializerNameGenerator\n    );\n    this.residualFunctionInfos = residualFunctionInfos;\n  }\n\n  realm: Realm;\n  modules: Modules;\n  statistics: SerializerStatistics;\n  requireReturns: Map<number | string, BabelNodeExpression>;\n  locationService: LocationService;\n  prelude: Array<BabelNodeStatement>;\n  factoryNameGenerator: NameGenerator;\n  scopeNameGenerator: NameGenerator;\n  capturedScopeInstanceIdx: number;\n  capturedScopesArray: BabelNodeIdentifier;\n  serializedScopes: Map<DeclarativeEnvironmentRecord, ScopeBinding>;\n  functionPrototypes: Map<FunctionValue, BabelNodeIdentifier>;\n  firstFunctionUsages: Map<FunctionValue, BodyReference>;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  functionInstances: Array<FunctionInstance>;\n  residualFunctionInitializers: ResidualFunctionInitializers;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n\n  addFunctionInstance(instance: FunctionInstance) {\n    this.functionInstances.push(instance);\n    let code = instance.functionValue.$ECMAScriptCode;\n    invariant(code != null);\n    let functionInstances = this.functions.get(code);\n    if (functionInstances === undefined) this.functions.set(code, (functionInstances = []));\n    functionInstances.push(instance);\n  }\n\n  setFunctionPrototype(constructor: FunctionValue, prototypeId: BabelNodeIdentifier) {\n    this.functionPrototypes.set(constructor, prototypeId);\n  }\n\n  addFunctionUsage(val: FunctionValue, bodyReference: BodyReference) {\n    if (!this.firstFunctionUsages.has(val)) this.firstFunctionUsages.set(val, bodyReference);\n  }\n\n  _getSerializedBindingScopeInstance(serializedBinding: SerializedBinding): ScopeBinding {\n    let declarativeEnvironmentRecord = serializedBinding.declarativeEnvironmentRecord;\n    invariant(declarativeEnvironmentRecord);\n\n    let scope = this.serializedScopes.get(declarativeEnvironmentRecord);\n    if (!scope) {\n      scope = {\n        name: this.scopeNameGenerator.generate(),\n        id: this.capturedScopeInstanceIdx++,\n        initializationValues: new Map(),\n      };\n      this.serializedScopes.set(declarativeEnvironmentRecord, scope);\n    }\n\n    serializedBinding.scope = scope;\n    return scope;\n  }\n\n  _referentialize(unbound: Names, instances: Array<FunctionInstance>): void {\n    for (let instance of instances) {\n      let serializedBindings = instance.serializedBindings;\n\n      for (let name in unbound) {\n        let serializedBinding = serializedBindings[name];\n        invariant(serializedBinding !== undefined);\n        if (serializedBinding.modified) {\n          // Initialize captured scope at function call instead of globally\n          if (!serializedBinding.referentialized) {\n            let scope = this._getSerializedBindingScopeInstance(serializedBinding);\n            let capturedScope = \"__captured\" + scope.name;\n            // Save the serialized value for initialization at the top of\n            // the factory.\n            // This can serialize more variables than are necessary to execute\n            // the function because every function serializes every\n            // modified variable of its parent scope. In some cases it could be\n            // an improvement to split these variables into multiple\n            // scopes.\n            invariant(serializedBinding.serializedValue);\n            scope.initializationValues.set(name, serializedBinding.serializedValue);\n            scope.capturedScope = capturedScope;\n\n            // Replace binding usage with scope references\n            serializedBinding.serializedValue = t.memberExpression(\n              t.identifier(capturedScope),\n              t.identifier(name),\n              false\n            );\n\n            serializedBinding.referentialized = true;\n            this.statistics.referentialized++;\n          }\n\n          // Already referentialized in prior scope\n          if (serializedBinding.declarativeEnvironmentRecord) {\n            invariant(serializedBinding.scope);\n            instance.scopeInstances.add(serializedBinding.scope);\n          }\n        }\n      }\n    }\n  }\n\n  _getReferentializedScopeInitialization(scope: ScopeBinding): [BabelNodeVariableDeclaration, BabelNodeIfStatement] {\n    let properties = [];\n    for (let [variableName, value] of scope.initializationValues.entries()) {\n      properties.push(t.objectProperty(t.identifier(variableName), value));\n    }\n    let initExpression = t.memberExpression(this.capturedScopesArray, t.identifier(scope.name), true);\n    invariant(scope.capturedScope);\n    let capturedScope = scope.capturedScope;\n    let capturedScopeId = t.identifier(capturedScope);\n\n    return [\n      t.variableDeclaration(\"var\", [t.variableDeclarator(capturedScopeId, initExpression)]),\n      t.ifStatement(\n        t.unaryExpression(\"!\", capturedScopeId),\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            initExpression,\n            t.assignmentExpression(\"=\", capturedScopeId, t.objectExpression(properties))\n          )\n        )\n      ),\n    ];\n  }\n\n  spliceFunctions(): ResidualFunctionsResult {\n    this.residualFunctionInitializers.scrubFunctionInitializers();\n\n    let functionBodies = new Map();\n    function getFunctionBody(instance: FunctionInstance): Array<BabelNodeStatement> {\n      let b = functionBodies.get(instance);\n      if (b === undefined) functionBodies.set(instance, (b = []));\n      return b;\n    }\n\n    let requireStatistics = { replaced: 0, count: 0 };\n\n    let functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]> = Array.from(\n      this.functions.entries()\n    );\n    this.statistics.functions = functionEntries.length;\n    let unstrictFunctionBodies = [];\n    let strictFunctionBodies = [];\n    let funcNodes: Map<FunctionValue, BabelNodeFunctionExpression> = new Map();\n\n    for (let [funcBody, instances] of functionEntries) {\n      let functionInfo = this.residualFunctionInfos.get(funcBody);\n      invariant(functionInfo);\n      this._referentialize(functionInfo.unbound, instances);\n    }\n\n    for (let [funcBody, instances] of functionEntries) {\n      let functionInfo = this.residualFunctionInfos.get(funcBody);\n      invariant(functionInfo);\n      let { unbound, modified, usesThis, usesArguments } = functionInfo;\n      let params = instances[0].functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      let shouldInline = !funcBody;\n      if (!shouldInline && funcBody.start && funcBody.end) {\n        let bodySize = funcBody.end - funcBody.start;\n        shouldInline = bodySize <= 30;\n      }\n\n      let define = (instance, funcId, funcNode) => {\n        let { functionValue } = instance;\n        let body;\n        if (t.isFunctionExpression(funcNode)) {\n          funcNodes.set(functionValue, ((funcNode: any): BabelNodeFunctionExpression));\n          body = this.prelude;\n        } else {\n          invariant(t.isCallExpression(funcNode)); // .bind call\n          body = getFunctionBody(instance);\n        }\n        let declaration = t.variableDeclaration(\"var\", [t.variableDeclarator(funcId, funcNode)]);\n        body.push(declaration);\n        let prototypeId = this.functionPrototypes.get(functionValue);\n        if (prototypeId !== undefined) {\n          let id = this.locationService.getLocation(functionValue);\n          invariant(id !== undefined);\n          body.push(\n            t.variableDeclaration(\"var\", [\n              t.variableDeclarator(prototypeId, t.memberExpression(id, t.identifier(\"prototype\"))),\n            ])\n          );\n        }\n      };\n\n      if (shouldInline || instances.length === 1 || usesArguments) {\n        this.statistics.functionClones += instances.length - 1;\n\n        for (let instance of instances) {\n          let { functionValue, serializedBindings, scopeInstances } = instance;\n          let id = this.locationService.getLocation(functionValue);\n          invariant(id !== undefined);\n          let funcParams = params.slice();\n          let funcNode = t.functionExpression(\n            null,\n            funcParams,\n            ((t.cloneDeep(funcBody): any): BabelNodeBlockStatement)\n          );\n          let scopeInitialization = [];\n          for (let scope of scopeInstances) {\n            scopeInitialization.push(\n              t.variableDeclaration(\"var\", [t.variableDeclarator(t.identifier(scope.name), t.numericLiteral(scope.id))])\n            );\n            scopeInitialization = scopeInitialization.concat(this._getReferentializedScopeInitialization(scope));\n          }\n          funcNode.body.body = scopeInitialization.concat(funcNode.body.body);\n\n          traverse(t.file(t.program([t.expressionStatement(funcNode)])), ClosureRefReplacer, null, {\n            serializedBindings,\n            modified,\n            requireReturns: this.requireReturns,\n            requireStatistics,\n            isRequire: this.modules.getIsRequire(funcParams, [functionValue]),\n          });\n\n          if (functionValue.$Strict) {\n            strictFunctionBodies.push(funcNode);\n          } else {\n            unstrictFunctionBodies.push(funcNode);\n          }\n\n          define(instance, id, funcNode);\n        }\n      } else {\n        // Group instances with modified bindings\n        let instanceBatches = [instances];\n        for (let name in modified) {\n          let newInstanceBatches = [];\n\n          for (let batch of instanceBatches) {\n            // Map from representative binding to function instances that use it\n            let bindingLookup = new Map();\n\n            for (let functionInstance of batch) {\n              let serializedBinding = functionInstance.serializedBindings[name];\n              invariant(serializedBinding !== undefined);\n              let found = false;\n              for (let [binding, group] of bindingLookup.entries()) {\n                if (AreSameSerializedBindings(this.realm, serializedBinding, binding)) {\n                  group.push(functionInstance);\n                  found = true;\n                  break;\n                }\n              }\n              if (!found) {\n                let matchingInstances = [functionInstance];\n                bindingLookup.set(serializedBinding, matchingInstances);\n                newInstanceBatches.push(matchingInstances);\n              }\n            }\n          }\n          instanceBatches = newInstanceBatches;\n        }\n        this.statistics.functionClones += instanceBatches.length - 1;\n\n        for (instances of instanceBatches) {\n          let suffix = instances[0].functionValue.__originalName || \"\";\n          let factoryId = t.identifier(this.factoryNameGenerator.generate(suffix));\n\n          // filter included variables to only include those that are different\n          let factoryNames: Array<string> = [];\n          let sameSerializedBindings = Object.create(null);\n          for (let name in unbound) {\n            let isDifferent = false;\n            let lastBinding;\n\n            if (instances[0].serializedBindings[name].modified) {\n              // Must modify for traversal\n              sameSerializedBindings[name] = instances[0].serializedBindings[name];\n              continue;\n            }\n\n            for (let { serializedBindings } of instances) {\n              let serializedBinding = serializedBindings[name];\n\n              invariant(!serializedBinding.modified);\n              if (!lastBinding) {\n                lastBinding = serializedBinding;\n              } else if (!AreSameSerializedBindings(this.realm, serializedBinding, lastBinding)) {\n                isDifferent = true;\n                break;\n              }\n            }\n\n            if (isDifferent) {\n              factoryNames.push(name);\n            } else {\n              invariant(lastBinding);\n              sameSerializedBindings[name] = { serializedValue: lastBinding.serializedValue };\n            }\n          }\n          //\n\n          let factoryParams: Array<BabelNodeLVal> = [];\n          for (let key of factoryNames) {\n            factoryParams.push(t.identifier(key));\n          }\n\n          let scopeInitialization = [];\n          for (let scope of instances[0].scopeInstances) {\n            factoryParams.push(t.identifier(scope.name));\n            scopeInitialization = scopeInitialization.concat(this._getReferentializedScopeInitialization(scope));\n          }\n\n          factoryParams = factoryParams.concat(params).slice();\n\n          // The Replacer below mutates the AST, so let's clone the original AST to avoid modifying it\n          let factoryNode = t.functionExpression(\n            null,\n            factoryParams,\n            ((t.cloneDeep(funcBody): any): BabelNodeBlockStatement)\n          );\n\n          factoryNode.body.body = scopeInitialization.concat(factoryNode.body.body);\n\n          // factory functions do not depend on any nested generator scope, so they go to the prelude\n          let factoryDeclaration = t.variableDeclaration(\"var\", [t.variableDeclarator(factoryId, factoryNode)]);\n          this.prelude.push(factoryDeclaration);\n\n          traverse(t.file(t.program([t.expressionStatement(factoryNode)])), ClosureRefReplacer, null, {\n            serializedBindings: sameSerializedBindings,\n            modified,\n            requireReturns: this.requireReturns,\n            requireStatistics,\n            isRequire: this.modules.getIsRequire(factoryParams, instances.map(instance => instance.functionValue)),\n          });\n\n          for (let instance of instances) {\n            let { functionValue, serializedBindings, insertionPoint } = instance;\n            let functionId = this.locationService.getLocation(functionValue);\n            invariant(functionId !== undefined);\n            let flatArgs: Array<BabelNodeExpression> = factoryNames.map(name => {\n              let serializedValue = serializedBindings[name].serializedValue;\n              invariant(serializedValue);\n              return serializedValue;\n            });\n            for (let { id } of instance.scopeInstances) {\n              flatArgs.push(t.numericLiteral(id));\n            }\n            let funcNode;\n            let firstUsage = this.firstFunctionUsages.get(functionValue);\n            invariant(insertionPoint !== undefined);\n            if (\n              this.residualFunctionInitializers.hasInitializerStatement(functionValue) ||\n              usesThis ||\n              (firstUsage !== undefined && !firstUsage.isNotEarlierThan(insertionPoint)) ||\n              this.functionPrototypes.get(functionValue) !== undefined\n            ) {\n              let callArgs: Array<BabelNodeExpression | BabelNodeSpreadElement> = [t.thisExpression()];\n              for (let flatArg of flatArgs) callArgs.push(flatArg);\n              for (let param of params) {\n                if (param.type !== \"Identifier\") {\n                  throw new FatalError(\"TODO: do not know how to deal with non-Identifier parameters\");\n                }\n                callArgs.push(((param: any): BabelNodeIdentifier));\n              }\n\n              let callee = t.memberExpression(factoryId, t.identifier(\"call\"));\n\n              let childBody = t.blockStatement([t.returnStatement(t.callExpression(callee, callArgs))]);\n\n              funcNode = t.functionExpression(null, params, childBody);\n            } else {\n              funcNode = t.callExpression(\n                t.memberExpression(factoryId, t.identifier(\"bind\")),\n                [nullExpression].concat(flatArgs)\n              );\n            }\n\n            define(instance, functionId, funcNode);\n          }\n        }\n      }\n    }\n\n    if (this.capturedScopeInstanceIdx) {\n      let scopeVar = t.variableDeclaration(\"var\", [\n        t.variableDeclarator(\n          this.capturedScopesArray,\n          t.callExpression(t.identifier(\"Array\"), [t.numericLiteral(this.capturedScopeInstanceIdx)])\n        ),\n      ]);\n      // The `scopeVar` must be visible in all scopes.\n      this.prelude.unshift(scopeVar);\n    }\n\n    for (let instance of this.functionInstances.reverse()) {\n      let functionBody = functionBodies.get(instance);\n      if (functionBody !== undefined) {\n        let insertionPoint = instance.insertionPoint;\n        invariant(insertionPoint instanceof BodyReference);\n        // v8 seems to do something clever with array splicing, so this potentially\n        // expensive operations seems to be actually cheap.\n        Array.prototype.splice.apply(\n          insertionPoint.body,\n          ([insertionPoint.index, 0]: Array<any>).concat((functionBody: Array<any>))\n        );\n      }\n    }\n\n    // Inject initializer code for indexed vars into functions\n    for (let [functionValue, funcNode] of funcNodes) {\n      let initializerStatement = this.residualFunctionInitializers.getInitializerStatement(functionValue);\n      if (initializerStatement !== undefined) {\n        invariant(t.isFunctionExpression(funcNode));\n        let blockStatement: BabelNodeBlockStatement = ((funcNode: any): BabelNodeFunctionExpression).body;\n        blockStatement.body.unshift(initializerStatement);\n      }\n    }\n\n    return { unstrictFunctionBodies, strictFunctionBodies, requireStatistics };\n  }\n}\n"]}