{"version":3,"sources":["../../src/serializer/ResidualFunctionInitializers.js"],"names":["t","ResidualFunctionInitializers","locationService","prelude","initializerNameGenerator","functionInitializerInfos","Map","initializers","sharedInitializers","functionValues","val","length","infos","functionValue","info","get","undefined","set","ownId","size","toString","initializerIds","Set","push","id","map","sort","join","add","initializer","order","values","body","delete","initializedValues","initializationStatements","isIfStatement","location","value","mightBeUndefined","getLocation","createLocation","unshift","expressionStatement","assignmentExpression","ifStatement","binaryExpression","blockStatement","initializerInfo","ownInitializer","initializerId","i","j","concat","ast","_conditionalInitialization","count","file","program","identifier","generate","functionDeclaration","callExpression"],"mappings":"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","file":"ResidualFunctionInitializers.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FunctionValue, Value } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeStatement } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport invariant from \"../invariant.js\";\nimport { voidExpression, nullExpression } from \"../utils/internalizer.js\";\nimport type { LocationService } from \"./types.js\";\n\n// This class manages information about values\n// which are only referenced by residual functions,\n// and it provides the ability to generate initialization code for those values that\n// can be placed into the residual functions.\nexport class ResidualFunctionInitializers {\n  constructor(\n    locationService: LocationService,\n    prelude: Array<BabelNodeStatement>,\n    initializerNameGenerator: NameGenerator\n  ) {\n    this.functionInitializerInfos = new Map();\n    this.initializers = new Map();\n    this.sharedInitializers = new Map();\n    this.locationService = locationService;\n    this.initializerNameGenerator = initializerNameGenerator;\n    this.prelude = prelude;\n  }\n\n  functionInitializerInfos: Map<FunctionValue, { ownId: string, initializerIds: Set<string> }>;\n  initializers: Map<string, { id: string, order: number, body: Array<BabelNodeStatement>, values: Array<Value> }>;\n  sharedInitializers: Map<string, BabelNodeStatement>;\n  locationService: LocationService;\n  prelude: Array<BabelNodeStatement>;\n  initializerNameGenerator: NameGenerator;\n\n  registerValueOnlyReferencedByResidualFunctions(\n    functionValues: Array<FunctionValue>,\n    val: Value\n  ): Array<BabelNodeStatement> {\n    invariant(functionValues.length >= 1);\n    let infos = [];\n    for (let functionValue of functionValues) {\n      let info = this.functionInitializerInfos.get(functionValue);\n      if (info === undefined)\n        this.functionInitializerInfos.set(\n          functionValue,\n          (info = { ownId: this.functionInitializerInfos.size.toString(), initializerIds: new Set() })\n        );\n      infos.push(info);\n    }\n    let id = infos.map(info => info.ownId).sort().join();\n    for (let info of infos) info.initializerIds.add(id);\n    let initializer = this.initializers.get(id);\n    if (initializer === undefined)\n      this.initializers.set(id, (initializer = { id, order: infos.length, values: [], body: [] }));\n    initializer.values.push(val);\n    return initializer.body;\n  }\n\n  scrubFunctionInitializers() {\n    // Deleting trivial entries in order to avoid creating empty initialization functions that serve no purpose.\n    for (let initializer of this.initializers.values())\n      if (initializer.body.length === 0) this.initializers.delete(initializer.id);\n    for (let [functionValue, info] of this.functionInitializerInfos) {\n      for (let id of info.initializerIds) {\n        let initializer = this.initializers.get(id);\n        if (initializer === undefined) {\n          info.initializerIds.delete(id);\n        }\n      }\n      if (info.initializerIds.size === 0) this.functionInitializerInfos.delete(functionValue);\n    }\n  }\n\n  _conditionalInitialization(\n    initializedValues: Array<Value>,\n    initializationStatements: Array<BabelNodeStatement>\n  ): BabelNodeStatement {\n    if (initializationStatements.length === 1 && t.isIfStatement(initializationStatements[0])) {\n      return initializationStatements[0];\n    }\n\n    // We have some initialization code, and it should only get executed once,\n    // so we are going to guard it.\n    // First, let's see if one of the initialized values is guaranteed to not\n    // be undefined after initialization. In that case, we can use that state-change\n    // to figure out if initialization needs to run.\n    let location;\n    for (let value of initializedValues) {\n      if (!value.mightBeUndefined()) {\n        location = this.locationService.getLocation(value);\n        if (location !== undefined) break;\n      }\n    }\n    if (location === undefined) {\n      // Second, if we didn't find a non-undefined value, let's make one up.\n      // It will transition from `undefined` to `null`.\n      location = this.locationService.createLocation();\n      initializationStatements.unshift(t.expressionStatement(t.assignmentExpression(\"=\", location, nullExpression)));\n    }\n    return t.ifStatement(\n      t.binaryExpression(\"===\", location, voidExpression),\n      t.blockStatement(initializationStatements)\n    );\n  }\n\n  hasInitializerStatement(functionValue: FunctionValue): boolean {\n    return !!this.functionInitializerInfos.get(functionValue);\n  }\n\n  getInitializerStatement(functionValue: FunctionValue): void | BabelNodeStatement {\n    let initializerInfo = this.functionInitializerInfos.get(functionValue);\n    if (initializerInfo === undefined) return undefined;\n\n    invariant(initializerInfo.initializerIds.size > 0);\n    let ownInitializer = this.initializers.get(initializerInfo.ownId);\n    let initializedValues;\n    let initializationStatements = [];\n    let initializers = [];\n    for (let initializerId of initializerInfo.initializerIds) {\n      let initializer = this.initializers.get(initializerId);\n      invariant(initializer !== undefined);\n      invariant(initializer.body.length > 0);\n      initializers.push(initializer);\n    }\n    // Sorting initializers by the number of scopes they are required by.\n    // Note that the scope sets form a lattice, and this sorting effectively\n    // ensures that value initializers that depend on other value initializers\n    // get called in the right order.\n    initializers.sort((i, j) => j.order - i.order);\n    for (let initializer of initializers) {\n      if (initializerInfo.initializerIds.size === 1 || initializer === ownInitializer) {\n        initializedValues = initializer.values;\n      }\n      if (initializer === ownInitializer) {\n        initializationStatements = initializationStatements.concat(initializer.body);\n      } else {\n        let ast = this.sharedInitializers.get(initializer.id);\n        if (ast === undefined) {\n          ast = this._conditionalInitialization(initializer.values, initializer.body);\n          // We inline compact initializers, as calling a function would introduce too much\n          // overhead. To determine if an initializer is compact, we count the number of\n          // nodes in the AST, and check if it exceeds a certain threshold.\n          // TODO #885: Study in more detail which threshold is the best compromise in terms of\n          // code size and performance.\n          let count = 0;\n          traverseFast(t.file(t.program([ast])), node => {\n            count++;\n            return false;\n          });\n          if (count > 24) {\n            let id = t.identifier(this.initializerNameGenerator.generate());\n            this.prelude.push(t.functionDeclaration(id, [], t.blockStatement([ast])));\n            ast = t.expressionStatement(t.callExpression(id, []));\n          }\n          this.sharedInitializers.set(initializer.id, ast);\n        }\n        initializationStatements.push(ast);\n      }\n    }\n\n    return this._conditionalInitialization(initializedValues || [], initializationStatements);\n  }\n}\n"]}