{"version":3,"sources":["../../src/serializer/Emitter.js"],"names":["Emitter","residualFunctions","mainBody","_waitingForValues","Map","_waitingForBodies","_body","_declaredAbstractValues","Set","_residualFunctions","_activeStack","_activeValues","_activeBodies","_finalized","dependency","targetBody","push","add","oldBody","statement","_processCurrentBody","lastDependency","pop","has","delete","_processValue","lastBody","size","length","a","get","undefined","shift","dependencies","func","emitNowOrAfterWaitingForDependencies","value","body","b","set","Array","isArray","values","delayReason","getReasonToWaitForDependencies","val","$BoundTargetFunction","$BoundThis","$BoundArguments","arg","addFunctionUsage","getBodyReference","hasIdentifier","args","$ProxyTarget","$ProxyHandler","$Description","kind","getKind","proto","$Prototype","$DateValue","condition","reason","emitAfterWaiting"],"mappings":"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","file":"Emitter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  BoundFunctionValue,\n  ProxyValue,\n  AbstractValue,\n  FunctionValue,\n  Value,\n  ObjectValue,\n  SymbolValue,\n} from \"../values/index.js\";\nimport type { BabelNodeStatement } from \"babel-types\";\nimport { Generator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport { BodyReference } from \"./types.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\n\n// The emitter keeps track of a stack of what's currently being emitted.\n// There are two kinds of interesting dependencies the emitter is dealing with:\n// 1. Value dependencies:\n//    If an emission task depends on the result of another emission task which\n//    is still currently being emitted, then the emission task must be performed later,\n//    once the dependency is available.\n//    To this end, the emitter maintains the `_activeValues` and `_waitingForValues` datastructures.\n// 2. Generator dependencies:\n//    For each generator, there's a corresponding \"body\", i.e. a stream of babel statements\n//    that the emitter is appending to.\n//    There's always a \"current\" body that is currently being emitted to.\n//    There's also a distinguished `mainBody` to which all statements get directly or indirectly appended.\n//    If there are multiple generators/bodies involved, then they form a stack.\n//    Nested bodies are usually composed into an instruction emitted to the outer body.\n//    For example, two nested generators may yield the then and else-branch of an `if` statement.\n//    When an emission is supposed to target a body that is the current body, i.e. when it sits\n//    lower on the stack, then the emission task gets delayed until the next emission task on\n//    the lower body entry is finished.\n//    To this end, the emitter maintains the `_activeBodies` and `_waitingForBodies` datastructures.\nexport class Emitter {\n  constructor(residualFunctions: ResidualFunctions) {\n    let mainBody = [];\n    this._waitingForValues = new Map();\n    this._waitingForBodies = new Map();\n    this._body = mainBody;\n    this._declaredAbstractValues = new Set();\n    this._residualFunctions = residualFunctions;\n    this._activeStack = [];\n    this._activeValues = new Set();\n    this._activeBodies = new Set([mainBody]);\n    this._finalized = false;\n  }\n\n  _finalized: boolean;\n  _activeStack: Array<string | Generator | Value>;\n  _activeValues: Set<Value>;\n  _activeBodies: Set<Array<BabelNodeStatement>>;\n  _residualFunctions: ResidualFunctions;\n  _waitingForValues: Map<\n    Value,\n    Array<{ body: Array<BabelNodeStatement>, dependencies: Array<Value>, func: () => void }>\n  >;\n  _waitingForBodies: Map<Array<BabelNodeStatement>, Array<{ dependencies: Array<Value>, func: () => void }>>;\n  _declaredAbstractValues: Set<AbstractValue>;\n  _body: Array<BabelNodeStatement>;\n\n  beginEmitting(dependency: string | Generator | Value, targetBody: Array<BabelNodeStatement>) {\n    invariant(!this._finalized);\n    this._activeStack.push(dependency);\n    if (dependency instanceof Value) this._activeValues.add(dependency);\n    else if (dependency instanceof Generator) this._activeBodies.add(targetBody);\n    let oldBody = this._body;\n    this._body = targetBody;\n    return oldBody;\n  }\n  emit(statement: BabelNodeStatement) {\n    invariant(!this._finalized);\n    this._body.push(statement);\n    this._processCurrentBody();\n  }\n  endEmitting(dependency: string | Generator | Value, oldBody: Array<BabelNodeStatement>) {\n    invariant(!this._finalized);\n    let lastDependency = this._activeStack.pop();\n    invariant(dependency === lastDependency);\n    if (dependency instanceof Value) {\n      invariant(this._activeValues.has(dependency));\n      this._activeValues.delete(dependency);\n      this._processValue(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(this._activeBodies.has(this._body));\n      this._activeBodies.delete(this._body);\n    }\n    let lastBody = this._body;\n    this._body = oldBody;\n    return lastBody;\n  }\n  finalize() {\n    invariant(!this._finalized);\n    invariant(this._activeBodies.size === 1);\n    invariant(this._activeBodies.has(this._body));\n    this._activeBodies.delete(this._body);\n    this._processCurrentBody();\n    this._finalized = true;\n    invariant(this._waitingForBodies.size === 0);\n    invariant(this._waitingForValues.size === 0);\n    invariant(this._activeStack.length === 0);\n    invariant(this._activeValues.size === 0);\n    invariant(this._activeBodies.size === 0);\n  }\n  _processCurrentBody() {\n    let a = this._waitingForBodies.get(this._body);\n    if (a === undefined) return;\n    while (a.length > 0) {\n      let { dependencies, func } = a.shift();\n      this.emitNowOrAfterWaitingForDependencies(dependencies, func);\n    }\n    this._waitingForBodies.delete(this._body);\n  }\n  _processValue(value: Value) {\n    let a = this._waitingForValues.get(value);\n    if (a === undefined) return;\n    let oldBody = this._body;\n    while (a.length > 0) {\n      let { body, dependencies, func } = a.shift();\n      if (body !== oldBody) {\n        invariant(this._activeBodies.has(body));\n        let b = this._waitingForBodies.get(body);\n        if (b === undefined) this._waitingForBodies.set(body, (b = []));\n        b.push({ dependencies, func });\n      } else {\n        this.emitNowOrAfterWaitingForDependencies(dependencies, func);\n      }\n    }\n    this._waitingForValues.delete(value);\n  }\n\n  // Serialization of a statement related to a value MUST be delayed if\n  // the creation of the value's identity requires the availability of either:\n  // 1. a time-dependent value that is declared by some generator entry\n  //    that has not yet been processed\n  //    (tracked by the `_declaredAbstractValues` set), or\n  // 2. a value that is also currently being serialized\n  //    (tracked by the `_activeStack`).\n  getReasonToWaitForDependencies(dependencies: Value | Array<Value>): void | Value {\n    invariant(!this._finalized);\n    if (Array.isArray(dependencies)) {\n      let values = ((dependencies: any): Array<Value>);\n      for (let value of values) {\n        let delayReason = this.getReasonToWaitForDependencies(value);\n        if (delayReason) return delayReason;\n      }\n      return undefined;\n    }\n\n    let val = ((dependencies: any): Value);\n    if (this._activeValues.has(val)) return val;\n\n    let delayReason;\n    if (val instanceof BoundFunctionValue) {\n      delayReason = this.getReasonToWaitForDependencies(val.$BoundTargetFunction);\n      if (delayReason) return delayReason;\n      delayReason = this.getReasonToWaitForDependencies(val.$BoundThis);\n      if (delayReason) return delayReason;\n      for (let arg of val.$BoundArguments) {\n        delayReason = this.getReasonToWaitForDependencies(arg);\n        if (delayReason) return delayReason;\n      }\n    } else if (val instanceof FunctionValue) {\n      this._residualFunctions.addFunctionUsage(val, this.getBodyReference());\n      return undefined;\n    } else if (val instanceof AbstractValue) {\n      if (val.hasIdentifier() && !this._declaredAbstractValues.has(val)) return val;\n      for (let arg of val.args) {\n        delayReason = this.getReasonToWaitForDependencies(arg);\n        if (delayReason) return delayReason;\n      }\n    } else if (val instanceof ProxyValue) {\n      delayReason = this.getReasonToWaitForDependencies(val.$ProxyTarget);\n      if (delayReason) return delayReason;\n      delayReason = this.getReasonToWaitForDependencies(val.$ProxyHandler);\n      if (delayReason) return delayReason;\n    } else if (val instanceof SymbolValue) {\n      if (val.$Description instanceof Value) {\n        delayReason = this.getReasonToWaitForDependencies(val.$Description);\n        if (delayReason) return delayReason;\n      }\n    } else if (val instanceof ObjectValue) {\n      let kind = val.getKind();\n      switch (kind) {\n        case \"Object\":\n          let proto = val.$Prototype;\n          if (proto instanceof ObjectValue) {\n            delayReason = this.getReasonToWaitForDependencies(val.$Prototype);\n            if (delayReason) return delayReason;\n          }\n          break;\n        case \"Date\":\n          invariant(val.$DateValue !== undefined);\n          delayReason = this.getReasonToWaitForDependencies(val.$DateValue);\n          if (delayReason) return delayReason;\n          break;\n        default:\n          break;\n      }\n    }\n\n    return undefined;\n  }\n  // Wait for a known-to-be active value if a condition is met.\n  getReasonToWaitForActiveValue(value: Value, condition: boolean): void | Value {\n    invariant(!this._finalized);\n    invariant(this._activeValues.has(value));\n    return condition ? value : undefined;\n  }\n  emitAfterWaiting(reason: Value, dependencies: Array<Value>, func: () => void) {\n    invariant(!this._finalized);\n    invariant(\n      !(reason instanceof AbstractValue && this._declaredAbstractValues.has(reason)) || this._activeValues.has(reason)\n    );\n    let a = this._waitingForValues.get(reason);\n    if (a === undefined) this._waitingForValues.set(reason, (a = []));\n    a.push({ body: this._body, dependencies, func });\n  }\n  emitNowOrAfterWaitingForDependencies(dependencies: Array<Value>, func: () => void) {\n    invariant(!this._finalized);\n    let delayReason = this.getReasonToWaitForDependencies(dependencies);\n    if (delayReason) {\n      this.emitAfterWaiting(delayReason, dependencies, func);\n    } else {\n      func();\n    }\n  }\n  declare(value: AbstractValue) {\n    invariant(!this._finalized);\n    invariant(!this._activeValues.has(value));\n    invariant(value.hasIdentifier());\n    this._declaredAbstractValues.add(value);\n    this._processValue(value);\n  }\n  hasBeenDeclared(value: AbstractValue) {\n    invariant(!this._finalized);\n    return this._declaredAbstractValues.has(value);\n  }\n  getBody(): Array<BabelNodeStatement> {\n    return this._body;\n  }\n  getBodyReference() {\n    invariant(!this._finalized);\n    return new BodyReference(this._body, this._body.length);\n  }\n}\n"]}