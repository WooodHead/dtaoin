"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualHeapVisitor = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _environment = require("../environment.js");

var _errors = require("../errors.js");

var _realm = require("../realm.js");

var _index = require("../methods/index.js");

var _index2 = require("../values/index.js");

var _Error = require("../intrinsics/ecma262/Error.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _generator = require("../utils/generator.js");

var _babelTraverse = require("babel-traverse");

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _visitors = require("./visitors.js");

var _logger = require("./logger.js");

var _modules = require("./modules.js");

var _ResidualHeapInspector = require("./ResidualHeapInspector.js");

var _utils = require("./utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* This class visits all values that are reachable in the residual heap.
   In particular, this "filters out" values that are...
   - captured by a DeclarativeEnvironmentRecord, but not actually used by any closure.
   - Unmodified prototype objects
   TODO #680: Figure out minimal set of values that need to be kept alive for WeakSet and WeakMap instances.
*/
var ResidualHeapVisitor = exports.ResidualHeapVisitor = function () {
  function ResidualHeapVisitor(realm, logger, modules) {
    _classCallCheck(this, ResidualHeapVisitor);

    (0, _invariant2.default)(realm.useAbstractInterpretation);
    this.realm = realm;
    this.logger = logger;
    this.modules = modules;

    this.declarativeEnvironmentRecordsBindings = new Map();
    this.globalBindings = new Map();
    this.functionInfos = new Map();
    this.functionBindings = new Map();
    this.values = new Map();
    var generator = this.realm.generator;
    (0, _invariant2.default)(generator);
    this.scope = this.realmGenerator = generator;
    this.inspector = new _ResidualHeapInspector.ResidualHeapInspector(realm, logger);
    this.referencedDeclaredValues = new Set();
    this.delayedVisitGeneratorEntries = [];
  }

  _createClass(ResidualHeapVisitor, [{
    key: "_withScope",
    value: function _withScope(scope, f) {
      var oldScope = this.scope;
      this.scope = scope;
      f();
      this.scope = oldScope;
    }
  }, {
    key: "visitObjectProperties",
    value: function visitObjectProperties(obj) {
      // visit properties
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = obj.symbols[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref = _step.value;

          var _ref2 = _slicedToArray(_ref, 2);

          var symbol = _ref2[0];
          var propertyBinding = _ref2[1];

          (0, _invariant2.default)(propertyBinding);
          var desc = propertyBinding.descriptor;
          if (desc === undefined) continue; //deleted
          this.visitDescriptor(desc);
          this.visitValue(symbol);
        }

        // visit properties
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = obj.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _ref3 = _step2.value;

          var _ref4 = _slicedToArray(_ref3, 2);

          var key = _ref4[0];
          var _propertyBinding = _ref4[1];

          (0, _invariant2.default)(_propertyBinding);
          var desc = _propertyBinding.descriptor;
          if (desc === undefined) continue; //deleted
          if (!this.inspector.canIgnoreProperty(obj, key)) {
            this.visitDescriptor(desc);
          }
        }

        // inject properties with computed names
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (obj.unknownProperty !== undefined) {
        var desc = obj.unknownProperty.descriptor;
        if (desc !== undefined) {
          var val = desc.value;
          (0, _invariant2.default)(val instanceof _index2.AbstractValue);
          this.visitObjectPropertiesWithComputedNames(val);
        }
      }

      // prototype
      this.visitObjectPrototype(obj);
      if (obj instanceof _index2.FunctionValue) this.visitConstructorPrototype(obj);
    }
  }, {
    key: "visitObjectPrototype",
    value: function visitObjectPrototype(obj) {
      var proto = obj.$Prototype;

      var kind = obj.getKind();
      if (proto === this.realm.intrinsics[kind + "Prototype"]) return;

      this.visitValue(proto);
    }
  }, {
    key: "visitConstructorPrototype",
    value: function visitConstructorPrototype(func) {
      // If the original prototype object was mutated,
      // request its serialization here as this might be observable by
      // residual code.
      var prototype = _ResidualHeapInspector.ResidualHeapInspector.getPropertyValue(func, "prototype");
      if (prototype instanceof _index2.ObjectValue && prototype.originalConstructor === func && !this.inspector.isDefaultPrototype(prototype)) {
        this.visitValue(prototype);
      }
    }
  }, {
    key: "visitObjectPropertiesWithComputedNames",
    value: function visitObjectPropertiesWithComputedNames(absVal) {
      (0, _invariant2.default)(absVal.args.length === 3);
      var cond = absVal.args[0];
      (0, _invariant2.default)(cond instanceof _index2.AbstractValue);
      if (cond.kind === "template for property name condition") {
        var P = cond.args[0];
        (0, _invariant2.default)(P instanceof _index2.AbstractValue);
        var V = absVal.args[1];
        var earlier_props = absVal.args[2];
        if (earlier_props instanceof _index2.AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);
        this.visitValue(P);
        this.visitValue(V);
      } else {
        // conditional assignment
        this.visitValue(cond);
        var consequent = absVal.args[1];
        (0, _invariant2.default)(consequent instanceof _index2.AbstractValue);
        var alternate = absVal.args[2];
        (0, _invariant2.default)(alternate instanceof _index2.AbstractValue);
        this.visitObjectPropertiesWithComputedNames(consequent);
        this.visitObjectPropertiesWithComputedNames(alternate);
      }
    }
  }, {
    key: "visitDescriptor",
    value: function visitDescriptor(desc) {
      if (desc.value !== undefined) this.visitValue(desc.value);
      if (desc.get !== undefined) this.visitValue(desc.get);
      if (desc.set !== undefined) this.visitValue(desc.set);
    }
  }, {
    key: "visitDeclarativeEnvironmentRecordBinding",
    value: function visitDeclarativeEnvironmentRecordBinding(r, n) {
      var visitedBindings = this.declarativeEnvironmentRecordsBindings.get(r);
      if (!visitedBindings) {
        visitedBindings = Object.create(null);
        this.declarativeEnvironmentRecordsBindings.set(r, visitedBindings);
      }
      var visitedBinding = visitedBindings[n];
      if (!visitedBinding) {
        var realm = this.realm;
        var binding = r.bindings[n];
        (0, _invariant2.default)(!binding.deletable);
        var value = binding.initialized && binding.value || realm.intrinsics.undefined;
        visitedBinding = { value: value, modified: false, declarativeEnvironmentRecord: r };
        visitedBindings[n] = visitedBinding;
      }
      (0, _invariant2.default)(visitedBinding.value !== undefined);
      this.visitValue(visitedBinding.value);
      return visitedBinding;
    }
  }, {
    key: "visitValueArray",
    value: function visitValueArray(val) {
      this.visitObjectProperties(val);
      var realm = this.realm;
      var lenProperty = (0, _index.Get)(realm, val, "length");
      if (lenProperty instanceof _index2.AbstractValue || (0, _index.ToLength)(realm, lenProperty) !== (0, _utils.getSuggestedArrayLiteralLength)(realm, val)) {
        this.visitValue(lenProperty);
      }
    }
  }, {
    key: "visitValueMap",
    value: function visitValueMap(val) {
      var kind = val.getKind();

      var entries = void 0;
      if (kind === "Map") {
        entries = val.$MapData;
      } else {
        (0, _invariant2.default)(kind === "WeakMap");
        entries = val.$WeakMapData;
      }
      (0, _invariant2.default)(entries !== undefined);
      var len = entries.length;

      for (var i = 0; i < len; i++) {
        var _entry = entries[i];
        var key = _entry.$Key;
        var value = _entry.$Value;
        if (key === undefined || value === undefined) continue;
        this.visitValue(key);
        this.visitValue(value);
      }
    }
  }, {
    key: "visitValueSet",
    value: function visitValueSet(val) {
      var kind = val.getKind();

      var entries = void 0;
      if (kind === "Set") {
        entries = val.$SetData;
      } else {
        (0, _invariant2.default)(kind === "WeakSet");
        entries = val.$WeakSetData;
      }
      (0, _invariant2.default)(entries !== undefined);
      var len = entries.length;

      for (var i = 0; i < len; i++) {
        var _entry2 = entries[i];
        if (_entry2 === undefined) continue;
        this.visitValue(_entry2);
      }
    }
  }, {
    key: "visitValueFunction",
    value: function visitValueFunction(val) {
      var _this = this;

      this.visitObjectProperties(val);

      if (val instanceof _index2.BoundFunctionValue) {
        this.visitValue(val.$BoundTargetFunction);
        this.visitValue(val.$BoundThis);
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = val.$BoundArguments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var boundArg = _step3.value;
            this.visitValue(boundArg);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        return;
      }

      (0, _invariant2.default)(!(val instanceof _index2.NativeFunctionValue), "all native function values should be intrinsics");

      (0, _invariant2.default)(val instanceof _index2.ECMAScriptSourceFunctionValue);
      (0, _invariant2.default)(val.constructor === _index2.ECMAScriptSourceFunctionValue);
      var formalParameters = val.$FormalParameters;
      (0, _invariant2.default)(formalParameters != null);
      var code = val.$ECMAScriptCode;
      (0, _invariant2.default)(code != null);

      var functionInfo = this.functionInfos.get(code);

      if (!functionInfo) {
        functionInfo = {
          unbound: Object.create(null),
          modified: Object.create(null),
          usesArguments: false,
          usesThis: false
        };
        this.functionInfos.set(code, functionInfo);

        var state = {
          tryQuery: this.logger.tryQuery.bind(this.logger),
          val: val,
          functionInfo: functionInfo,
          realm: this.realm
        };

        (0, _babelTraverse2.default)(t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])), _visitors.ClosureRefVisitor, null, state);

        if (val.isResidual && Object.keys(functionInfo.unbound).length) {
          if (!val.isUnsafeResidual) {
            this.logger.logError(val, "residual function " + ((0, _Error.describeLocation)(this.realm, val, undefined, code.loc) || "(unknown)") + " refers to the following identifiers defined outside of the local scope: " + Object.keys(functionInfo.unbound).join(", "));
          }
        }
      }

      var visitedBindings = Object.create(null);
      this._withScope(val, function () {
        (0, _invariant2.default)(functionInfo);

        var _loop = function _loop(innerName) {
          var visitedBinding = void 0;
          var doesNotMatter = true;
          var reference = _this.logger.tryQuery(function () {
            return (0, _index.ResolveBinding)(_this.realm, innerName, doesNotMatter, val.$Environment);
          }, undefined, false /* The only reason `ResolveBinding` might fail is because the global object is partial. But in that case, we know that we are dealing with the global scope. */
          );
          if (reference === undefined || (0, _index.IsUnresolvableReference)(_this.realm, reference) || reference.base instanceof _environment.GlobalEnvironmentRecord) {
            visitedBinding = _this.visitGlobalBinding(innerName);
          } else {
            (0, _invariant2.default)(!(0, _index.IsUnresolvableReference)(_this.realm, reference));
            var referencedBase = reference.base;
            var referencedName = reference.referencedName;
            if (typeof referencedName !== "string") {
              throw new _errors.FatalError("TODO: do not know how to visit reference with symbol");
            }
            (0, _invariant2.default)(referencedBase instanceof _environment.DeclarativeEnvironmentRecord);
            visitedBinding = _this.visitDeclarativeEnvironmentRecordBinding(referencedBase, referencedName);
          }
          visitedBindings[innerName] = visitedBinding;
          if (functionInfo.modified[innerName]) visitedBinding.modified = true;
        };

        for (var innerName in functionInfo.unbound) {
          _loop(innerName);
        }
      });

      this.functionBindings.set(val, visitedBindings);
    }
  }, {
    key: "visitValueObject",
    value: function visitValueObject(val) {
      this.visitObjectProperties(val);

      // If this object is a prototype object that was implicitly created by the runtime
      // for a constructor, then we can obtain a reference to this object
      // in a special way that's handled alongside function serialization.
      var constructor = val.originalConstructor;
      if (constructor !== undefined) {
        this.visitValue(constructor);
        return;
      }

      var kind = val.getKind();
      switch (kind) {
        case "RegExp":
        case "Number":
        case "String":
        case "Boolean":
        case "ArrayBuffer":
          return;
        case "Date":
          var dateValue = val.$DateValue;
          (0, _invariant2.default)(dateValue !== undefined);
          this.visitValue(dateValue);
          return;
        case "Float32Array":
        case "Float64Array":
        case "Int8Array":
        case "Int16Array":
        case "Int32Array":
        case "Uint8Array":
        case "Uint16Array":
        case "Uint32Array":
        case "Uint8ClampedArray":
        case "DataView":
          var buf = val.$ViewedArrayBuffer;
          (0, _invariant2.default)(buf !== undefined);
          this.visitValue(buf);
          return;
        case "Map":
        case "WeakMap":
          this.visitValueMap(val);
          return;
        case "Set":
        case "WeakSet":
          this.visitValueSet(val);
          return;
        default:
          if (kind !== "Object") this.logger.logError(val, "Object of kind " + kind + " is not supported in residual heap.");
          if (this.$ParameterMap !== undefined) this.logger.logError(val, "Arguments object is not supported in residual heap.");
          return;
      }
    }
  }, {
    key: "visitValueSymbol",
    value: function visitValueSymbol(val) {
      if (val.$Description) this.visitValue(val.$Description);
    }
  }, {
    key: "visitValueProxy",
    value: function visitValueProxy(val) {
      this.visitValue(val.$ProxyTarget);
      this.visitValue(val.$ProxyHandler);
    }
  }, {
    key: "visitAbstractValue",
    value: function visitAbstractValue(val) {
      if (val.kind === "sentinel member expression") this.logger.logError(val, "expressions of type o[p] are not yet supported for partially known o and unknown p");
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = val.args[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var abstractArg = _step4.value;
          this.visitValue(abstractArg);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }, {
    key: "_mark",
    value: function _mark(val) {
      var scopes = this.values.get(val);
      if (scopes === undefined) this.values.set(val, scopes = new Set());
      if (scopes.has(this.scope)) return false;
      scopes.add(this.scope);
      return true;
    }
  }, {
    key: "visitValue",
    value: function visitValue(val) {
      var _this2 = this;

      if (val instanceof _index2.AbstractValue) {
        if (this._mark(val)) this.visitAbstractValue(val);
      } else if (val.isIntrinsic()) {
        // All intrinsic values exist from the beginning of time...
        // ...except for a few that come into existance as templates for abstract objects (TODO #882).
        this._withScope(this.realmGenerator, function () {
          _this2._mark(val);
        });
      } else if (val instanceof _index2.EmptyValue) {
        this._mark(val);
      } else if (_ResidualHeapInspector.ResidualHeapInspector.isLeaf(val)) {
        this._mark(val);
      } else if ((0, _index.IsArray)(this.realm, val)) {
        (0, _invariant2.default)(val instanceof _index2.ObjectValue);
        if (this._mark(val)) this.visitValueArray(val);
      } else if (val instanceof _index2.ProxyValue) {
        if (this._mark(val)) this.visitValueProxy(val);
      } else if (val instanceof _index2.FunctionValue) {
        // Function declarations should get hoisted in the global code so that instances only get allocated once
        this._withScope(this.realmGenerator, function () {
          (0, _invariant2.default)(val instanceof _index2.FunctionValue);
          if (_this2._mark(val)) _this2.visitValueFunction(val);
        });
      } else if (val instanceof _index2.SymbolValue) {
        if (this._mark(val)) this.visitValueSymbol(val);
      } else {
        (0, _invariant2.default)(val instanceof _index2.ObjectValue);

        // Prototypes are reachable via function declarations, and those get hoisted, so we need to move
        // prototype initialization to the global code as well.
        if (val.originalConstructor !== undefined) {
          this._withScope(this.realmGenerator, function () {
            (0, _invariant2.default)(val instanceof _index2.ObjectValue);
            if (_this2._mark(val)) _this2.visitValueObject(val);
          });
        } else {
          if (this._mark(val)) this.visitValueObject(val);
        }
      }
    }
  }, {
    key: "visitGlobalBinding",
    value: function visitGlobalBinding(key) {
      var binding = this.globalBindings.get(key);
      if (!binding) {
        var value = this.realm.getGlobalLetBinding(key);
        binding = { value: value, modified: true };
        this.globalBindings.set(key, binding);
      }
      if (binding.value) this.visitValue(binding.value);
      return binding;
    }
  }, {
    key: "createGeneratorVisitCallbacks",
    value: function createGeneratorVisitCallbacks(generator) {
      var _this3 = this;

      return {
        visitValue: this.visitValue.bind(this),
        visitGenerator: this.visitGenerator.bind(this),
        canSkip: function canSkip(value) {
          return !_this3.referencedDeclaredValues.has(value) && !_this3.values.has(value);
        },
        recordDeclaration: function recordDeclaration(value) {
          _this3.referencedDeclaredValues.add(value);
        },
        recordDelayedEntry: function recordDelayedEntry(entry) {
          _this3.delayedVisitGeneratorEntries.push({ generator: generator, entry: entry });
        }
      };
    }
  }, {
    key: "visitGenerator",
    value: function visitGenerator(generator) {
      var _this4 = this;

      this._withScope(generator, function () {
        generator.visit(_this4.createGeneratorVisitCallbacks(generator));
      });
    }
  }, {
    key: "visitRoots",
    value: function visitRoots() {
      var _this5 = this;

      this.visitGenerator(this.realmGenerator);
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.modules.initializedModules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _ref5 = _step5.value;

          var _ref6 = _slicedToArray(_ref5, 2);

          var moduleValue = _ref6[1];
          this.visitValue(moduleValue);
        } // Do a fixpoint over all pure generator entries to make sure that we visit
        // arguments of only BodyEntries that are required by some other residual value
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var oldDelayedEntries = [];
      while (oldDelayedEntries.length !== this.delayedVisitGeneratorEntries.length) {
        oldDelayedEntries = this.delayedVisitGeneratorEntries;
        this.delayedVisitGeneratorEntries = [];

        var _loop2 = function _loop2(_ref7) {
          var generator = _ref7.generator,
              entry = _ref7.entry;

          _this5._withScope(generator, function () {
            generator.visitEntry(entry, _this5.createGeneratorVisitCallbacks(generator));
          });
        };

        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = oldDelayedEntries[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var _ref7 = _step6.value;

            _loop2(_ref7);
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }
    }
  }]);

  return ResidualHeapVisitor;
}();
//# sourceMappingURL=ResidualHeapVisitor.js.map