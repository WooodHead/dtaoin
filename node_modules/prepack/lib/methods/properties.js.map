{"version":3,"sources":["../../src/methods/properties.js"],"names":["OrdinarySet","FromPropertyDescriptor","OrdinaryDelete","DeletePropertyOrThrow","CompletePropertyDescriptor","IsCompatiblePropertyDescriptor","ValidateAndApplyPropertyDescriptor","OrdinaryDefineOwnProperty","ObjectDefineProperties","Set","DefinePropertyOrThrow","PutValue","ArraySetLength","OrdinaryGetOwnProperty","OrdinarySetPrototypeOf","EnumerateObjectProperties","ThrowIfMightHaveBeenDeleted","ThrowIfInternalSlotNotWritable","PropertyDefinitionEvaluation","InternalDescriptorPropertyToValue","realm","value","undefined","intrinsics","InternalGetPropertiesKey","P","InternalGetPropertiesMap","O","properties","symbols","InternalSetProperty","desc","map","key","propertyBinding","get","descriptor","object","set","recordModifiedProperty","InternalUpdatedProperty","oldDesc","generator","isIntrinsic","$GlobalObject","emitGlobalDelete","getRunningContext","isStrict","emitPropertyDelete","descValue","configurable","enumerable","writable","emitGlobalDeclaration","emitGlobalAssignment","emitDefineProperty","emitPropertyAssignment","parentPermitsChildPropertyCreation","ownDesc","$GetOwnProperty","ownDescValue","mightHaveBeenDeleted","parent","$GetPrototypeOf","throwIfNotConcrete","V","Receiver","weakDeletion","$Set","reportIntrospectionError","existingDescriptor","existingDescValue","valueDesc","$Delete","$DefineOwnProperty","setter","Desc","obj","ObjectPrototype","getExtensible","size","success","createErrorThrowCompletion","TypeError","like","extensible","current","Object","keys","length","identical","field","dval","cval","Properties","props","$OwnPropertyKeys","descriptors","nextKey","propDesc","descObj","push","pair","Throw","W","promoteEmptyToUndefined","ReferenceError","base","globalObj","succeeded","$SetPartial","referencedName","SetMutableBinding","A","DescValue","newLenDesc","assign","newLen","numberLen","RangeError","oldLenDesc","oldLen","newWritable","oldLenCopy","Array","from","parseInt","x","filter","sort","reverse","deleteSucceeded","existingBinding","isPartial","isSimple","callReportPropertyAccess","D","X","kind","realmGenerator","derive","types","values","args","_buildNode","$Prototype","p","done","visited","global","index","iterator","defineNativeMethod","proto","add","has","isNewObject","MethodDefinition","env","strictCode","methodDef","$Closure","$Key","propKey","strict","body","scope","closure","params","prototype","GeneratorPrototype","originalConstructor","formalParameterList"],"mappings":"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","file":"properties.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding, PropertyKeyValue } from \"../types.js\";\nimport {\n  ArrayValue,\n  UndefinedValue,\n  NumberValue,\n  SymbolValue,\n  NullValue,\n  BooleanValue,\n  ObjectValue,\n  StringValue,\n  Value,\n  ConcreteValue,\n  AbstractValue,\n  AbstractObjectValue,\n} from \"../values/index.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression\";\nimport { EnvironmentRecord, Reference } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { CreateIterResultObject } from \"../methods/create.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  ObjectCreate,\n  CreateDataProperty,\n  cloneDescriptor,\n  equalDescriptors,\n  IsAccessorDescriptor,\n  IsPropertyKey,\n  IsUnresolvableReference,\n  IsStrictReference,\n  IsDataDescriptor,\n  IsGenericDescriptor,\n  GetGlobalObject,\n  GetBase,\n  GetReferencedName,\n  GetReferencedNamePartial,\n  GetThisValue,\n  HasPrimitiveBase,\n  Call,\n  ToObject,\n  ToObjectPartial,\n  ToPropertyDescriptor,\n  ToUint32,\n  ToNumber,\n  Get,\n  SameValue,\n  SameValuePartial,\n  IsPropertyReference,\n  HasSomeCompatibleType,\n  DefineMethod,\n  SetFunctionName,\n  GeneratorFunctionCreate,\n  MakeMethod,\n  MakeConstructor,\n  FunctionCreate,\n} from \"../methods/index.js\";\nimport { type BabelNodeObjectMethod, type BabelNodeClassMethod, isValidIdentifier } from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport IsStrict from \"../utils/strict.js\";\n\nfunction InternalDescriptorPropertyToValue(realm: Realm, value: void | boolean | Value) {\n  if (value === undefined) return realm.intrinsics.undefined;\n  if (typeof value === \"boolean\") return new BooleanValue(realm, value);\n  invariant(value instanceof Value);\n  return value;\n}\n\nfunction InternalGetPropertiesKey(P: PropertyKeyValue): string | SymbolValue | void {\n  if (typeof P === \"string\") {\n    return P;\n  } else if (P instanceof StringValue) {\n    return P.value;\n  } else if (P instanceof SymbolValue) {\n    return P;\n  }\n  // otherwise, undefined\n}\n\nfunction InternalGetPropertiesMap(O: ObjectValue, P: PropertyKeyValue): Map<any, PropertyBinding> {\n  if (typeof P === \"string\" || P instanceof StringValue) {\n    return O.properties;\n  } else if (P instanceof SymbolValue) {\n    return O.symbols;\n  } else {\n    invariant(false);\n  }\n}\n\nfunction InternalSetProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, desc: Descriptor) {\n  let map = InternalGetPropertiesMap(O, P);\n  let key = InternalGetPropertiesKey(P);\n  let propertyBinding = map.get(key);\n  if (propertyBinding === undefined) {\n    propertyBinding = { descriptor: undefined, object: O, key: key };\n    map.set(key, propertyBinding);\n  }\n  realm.recordModifiedProperty(propertyBinding);\n  propertyBinding.descriptor = desc;\n}\n\nfunction InternalUpdatedProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, oldDesc?: Descriptor) {\n  let generator = realm.generator;\n  if (!generator) return;\n  if (!O.isIntrinsic()) return;\n  if (P instanceof SymbolValue) return;\n  if (P instanceof StringValue) P = P.value;\n  invariant(typeof P === \"string\");\n  let propertyBinding = InternalGetPropertiesMap(O, P).get(P);\n  invariant(propertyBinding !== undefined); // The callers ensure this\n  let desc = propertyBinding.descriptor;\n  if (desc === undefined) {\n    // The property is being deleted\n    if (O === realm.$GlobalObject) {\n      generator.emitGlobalDelete(P, realm.getRunningContext().isStrict);\n    } else {\n      generator.emitPropertyDelete(O, P);\n    }\n  } else {\n    let descValue = desc.value || realm.intrinsics.undefined;\n    if (oldDesc === undefined) {\n      // The property is being created\n      if (O === realm.$GlobalObject) {\n        if (IsDataDescriptor(realm, desc)) {\n          if (isValidIdentifier(P) && !desc.configurable && desc.enumerable && desc.writable) {\n            generator.emitGlobalDeclaration(P, descValue);\n          } else if (desc.configurable && desc.enumerable && desc.writable) {\n            generator.emitGlobalAssignment(P, descValue, realm.getRunningContext().isStrict);\n          } else {\n            generator.emitDefineProperty(O, P, desc);\n          }\n        } else {\n          generator.emitDefineProperty(O, P, desc);\n        }\n      } else {\n        if (IsDataDescriptor(realm, desc) && desc.configurable && desc.enumerable && desc.writable) {\n          generator.emitPropertyAssignment(O, P, descValue);\n        } else {\n          generator.emitDefineProperty(O, P, desc);\n        }\n      }\n    } else {\n      // The property is being modified\n      if (equalDescriptors(desc, oldDesc)) {\n        // only the value is being modified\n        if (O === realm.$GlobalObject) {\n          generator.emitGlobalAssignment(P, descValue, realm.getRunningContext().isStrict);\n        } else {\n          generator.emitPropertyAssignment(O, P, descValue);\n        }\n      } else {\n        generator.emitDefineProperty(O, P, desc);\n      }\n    }\n  }\n}\n\n// Determines if an object with parent O may create its own property P.\nfunction parentPermitsChildPropertyCreation(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n  let ownDesc = O.$GetOwnProperty(P);\n  let ownDescValue = !ownDesc\n    ? realm.intrinsics.undefined\n    : ownDesc.value === undefined ? realm.intrinsics.undefined : ownDesc.value;\n\n  if (!ownDesc || ownDescValue.mightHaveBeenDeleted()) {\n    // O might not object, so first ask its parent\n    let parent = O.$GetPrototypeOf();\n    parent.throwIfNotConcrete(); //TODO: deal with abstract parents\n    if (!(parent instanceof NullValue)) {\n      if (!parentPermitsChildPropertyCreation(realm, parent, P)) return false;\n    }\n\n    // Parent is OK, so if O does not object return true\n    if (!ownDesc) return true; // O has no opinion of its ownDesc\n  }\n  invariant(ownDesc !== undefined);\n\n  // O might have a property P and so might object\n  if (IsDataDescriptor(realm, ownDesc)) {\n    if (ownDesc.writable) {\n      // The grand parent does not object so it is OK parent does not have P\n      // If parent does have P, it is also OK because it is a writable data property\n      return true;\n    }\n  }\n  // If parent does not have property P, this is too pessimistic, but that is\n  // the caller's problem.\n  return false;\n}\n\n// ECMA262 9.1.9.1\nexport function OrdinarySet(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n  let weakDeletion = V.mightHaveBeenDeleted();\n\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let ownDesc be ? O.[[GetOwnProperty]](P).\n  let ownDesc = O.$GetOwnProperty(P);\n  let ownDescValue = !ownDesc\n    ? realm.intrinsics.undefined\n    : ownDesc.value === undefined ? realm.intrinsics.undefined : ownDesc.value;\n\n  // 3. If ownDesc is undefined (or might be), then\n  if (!ownDesc || ownDescValue.mightHaveBeenDeleted()) {\n    // a. Let parent be ? O.[[GetPrototypeOf]]().\n    let parent = O.$GetPrototypeOf();\n    parent.throwIfNotConcrete(); //TODO: deal with abstract parents\n\n    // b. If parent is not null, then\n    if (!(parent instanceof NullValue)) {\n      if (!ownDesc) {\n        // i. Return ? parent.[[Set]](P, V, Receiver).\n        return parent.$Set(P, V, Receiver);\n      }\n      // But since we don't know if O has its own property P, the parent might\n      // actually have a say. Give up, unless the parent would be OK with it.\n      if (!parentPermitsChildPropertyCreation(realm, parent, P)) {\n        invariant(ownDescValue instanceof AbstractValue);\n        AbstractValue.reportIntrospectionError(ownDescValue);\n        throw new FatalError();\n      }\n      // Since the parent is OK with us creating a local property for O\n      // we can carry on as if there were no parent.\n    }\n\n    // i. Let ownDesc be the PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.\n    if (!ownDesc)\n      ownDesc = {\n        value: realm.intrinsics.undefined,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      };\n  }\n\n  // 4. If IsDataDescriptor(ownDesc) is true, then\n  if (IsDataDescriptor(realm, ownDesc)) {\n    // a. If ownDesc.[[Writable]] is false, return false.\n    if (!ownDesc.writable && !weakDeletion) {\n      // The write will fail if the property actually exists\n      if (ownDescValue.mightHaveBeenDeleted()) {\n        // But maybe it does not and thus would succeed.\n        // Since we don't know what will happen, give up for now.\n        invariant(ownDescValue instanceof AbstractValue);\n        AbstractValue.reportIntrospectionError(ownDescValue);\n        throw new FatalError();\n      }\n      return false;\n    }\n\n    // b. If Type(Receiver) is not Object, return false.\n    Receiver = Receiver.throwIfNotConcrete();\n    if (!(Receiver instanceof ObjectValue)) return false;\n\n    // c. Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).\n    let existingDescriptor = Receiver.$GetOwnProperty(P);\n    let existingDescValue = !existingDescriptor\n      ? realm.intrinsics.undefined\n      : existingDescriptor.value === undefined ? realm.intrinsics.undefined : existingDescriptor.value;\n\n    // d. If existingDescriptor is not undefined, then\n    if (existingDescriptor !== undefined) {\n      // i. If IsAccessorDescriptor(existingDescriptor) is true, return false.\n      if (IsAccessorDescriptor(realm, existingDescriptor)) {\n        invariant(\n          !existingDescValue.mightHaveBeenDeleted(),\n          \"should not fail until weak deletes of accessors are suppported\"\n        );\n        return false;\n      }\n\n      // ii. If existingDescriptor.[[Writable]] is false, return false.\n      if (!existingDescriptor.writable && !(weakDeletion && existingDescriptor.configurable)) {\n        // If we are not sure the receiver actually has a property P we can't just return false here.\n        if (existingDescValue.mightHaveBeenDeleted()) {\n          invariant(existingDescValue instanceof AbstractValue);\n          AbstractValue.reportIntrospectionError(existingDescValue);\n          throw new FatalError();\n        }\n        return false;\n      }\n\n      // iii. Let valueDesc be the PropertyDescriptor{[[Value]]: V}.\n      let valueDesc = { value: V };\n      if (weakDeletion) {\n        valueDesc = existingDescriptor;\n        valueDesc.value = V;\n      }\n\n      // iv. Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).\n      if (weakDeletion || existingDescValue.mightHaveBeenDeleted()) {\n        // At this point we are not actually sure that Receiver actually has\n        // a property P, however, if it has, we are sure that its a data property,\n        // and that redefining the property with valueDesc will not change the\n        // attributes of the property, so we delete it to make things nice for $DefineOwnProperty.\n        Receiver.$Delete(P);\n      }\n      return Receiver.$DefineOwnProperty(P, valueDesc);\n    } else {\n      // e. Else Receiver does not currently have a property P,\n\n      // i. Return ? CreateDataProperty(Receiver, P, V).\n      return CreateDataProperty(realm, Receiver, P, V);\n    }\n  }\n\n  // 5. Assert: IsAccessorDescriptor(ownDesc) is true.\n  invariant(IsAccessorDescriptor(realm, ownDesc), \"expected accessor\");\n\n  // 6. Let setter be ownDesc.[[Set]].\n  let setter = \"set\" in ownDesc ? ownDesc.set : undefined;\n\n  // 7. If setter is undefined, return false.\n  if (!setter || setter instanceof UndefinedValue) return false;\n\n  // 8. Perform ? Call(setter, Receiver, « V »).\n  Call(realm, setter.throwIfNotConcrete(), Receiver, [V]);\n\n  // 9. Return true.\n  return true;\n}\n\n// ECMA262 6.2.4.4\nexport function FromPropertyDescriptor(realm: Realm, Desc: ?Descriptor): Value {\n  // 1. If Desc is undefined, return undefined.\n  if (!Desc) return realm.intrinsics.undefined;\n\n  // 2. Let obj be ObjectCreate(%ObjectPrototype%).\n  let obj = ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n  // 3. Assert: obj is an extensible ordinary object with no own properties.\n  invariant(obj.getExtensible(), \"expected an extensible object\");\n  invariant(!obj.properties.size, \"expected an object with no own properties\");\n\n  // 4. If Desc has a [[Value]] field, then\n  let success = true;\n  if (\"value\" in Desc) {\n    invariant(Desc.value !== undefined);\n    // a. Perform CreateDataProperty(obj, \"value\", Desc.[[Value]]).\n    success = CreateDataProperty(realm, obj, \"value\", Desc.value) && success;\n  }\n\n  // 5. If Desc has a [[Writable]] field, then\n  if (\"writable\" in Desc) {\n    invariant(Desc.writable !== undefined);\n    // a. Perform CreateDataProperty(obj, \"writable\", Desc.[[Writable]]).\n    success = CreateDataProperty(realm, obj, \"writable\", new BooleanValue(realm, Desc.writable)) && success;\n  }\n\n  // 6. If Desc has a [[Get]] field, then\n  if (\"get\" in Desc) {\n    invariant(Desc.get !== undefined);\n    // a. Perform CreateDataProperty(obj, \"get\", Desc.[[Get]]).\n    success = CreateDataProperty(realm, obj, \"get\", Desc.get) && success;\n  }\n\n  // 7. If Desc has a [[Set]] field, then\n  if (\"set\" in Desc) {\n    invariant(Desc.set !== undefined);\n    // a. Perform CreateDataProperty(obj, \"set\", Desc.[[Set]]).\n    success = CreateDataProperty(realm, obj, \"set\", Desc.set) && success;\n  }\n\n  // 8. If Desc has an [[Enumerable]] field, then\n  if (\"enumerable\" in Desc) {\n    invariant(Desc.enumerable !== undefined);\n    // a. Perform CreateDataProperty(obj, \"enumerable\", Desc.[[Enumerable]]).\n    success = CreateDataProperty(realm, obj, \"enumerable\", new BooleanValue(realm, Desc.enumerable)) && success;\n  }\n\n  // 9. If Desc has a [[Configurable]] field, then\n  if (\"configurable\" in Desc) {\n    invariant(Desc.configurable !== undefined);\n    // a. Perform CreateDataProperty(obj, \"configurable\", Desc.[[Configurable]]).\n    success = CreateDataProperty(realm, obj, \"configurable\", new BooleanValue(realm, Desc.configurable)) && success;\n  }\n\n  // 10. Assert: all of the above CreateDataProperty operations return true.\n  invariant(success, \"fails to create data property\");\n\n  // 11. Return obj.\n  return obj;\n}\n\n//\nexport function OrdinaryDelete(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected a property key\");\n\n  // 2. Let desc be ? O.[[GetOwnProperty]](P).\n  let desc = O.$GetOwnProperty(P);\n\n  // 3. If desc is undefined, return true.\n  if (!desc) return true;\n\n  // 4. If desc.[[Configurable]] is true, then\n  if (desc.configurable) {\n    // a. Remove the own property with name P from O.\n    let key = InternalGetPropertiesKey(P);\n    let map = InternalGetPropertiesMap(O, P);\n    let propertyBinding = map.get(key);\n    invariant(propertyBinding !== undefined);\n    realm.recordModifiedProperty(propertyBinding);\n    propertyBinding.descriptor = undefined;\n    InternalUpdatedProperty(realm, O, P, desc);\n\n    // b. Return true.\n    return true;\n  }\n\n  // 5. Return false.\n  return false;\n}\n\n// ECMA262 7.3.8\nexport function DeletePropertyOrThrow(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue, \"expected an object\");\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected a property key\");\n\n  // 3. Let success be ? O.[[Delete]](P).\n  let success = O.$Delete(P);\n\n  // 4. If success is false, throw a TypeError exception.\n  if (!success) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"couldn't delete property\");\n  }\n\n  // 5. Return success.\n  return success;\n}\n\n// ECMA262 6.2.4.6\nexport function CompletePropertyDescriptor(realm: Realm, Desc: Descriptor): Descriptor {\n  // 1. Assert: Desc is a Property Descriptor.\n\n  // 2. Let like be Record{[[Value]]: undefined, [[Writable]]: false, [[Get]]: undefined, [[Set]]: undefined, [[Enumerable]]: false, [[Configurable]]: false}.\n  let like = {\n    value: realm.intrinsics.undefined,\n    get: realm.intrinsics.undefined,\n    set: realm.intrinsics.undefined,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  };\n\n  // 3. If either IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then\n  if (IsGenericDescriptor(realm, Desc) || IsDataDescriptor(realm, Desc)) {\n    // a. If Desc does not have a [[Value]] field, set Desc.[[Value]] to like.[[Value]].\n    if (!(\"value\" in Desc)) Desc.value = like.value;\n    // b. If Desc does not have a [[Writable]] field, set Desc.[[Writable]] to like.[[Writable]].\n    if (!(\"writable\" in Desc)) Desc.writable = like.writable;\n  } else {\n    // 4. Else,\n    // a. If Desc does not have a [[Get]] field, set Desc.[[Get]] to like.[[Get]].\n    if (!(\"get\" in Desc)) Desc.get = like.get;\n    // b. If Desc does not have a [[Set]] field, set Desc.[[Set]] to like.[[Set]].\n    if (!(\"set\" in Desc)) Desc.set = like.set;\n  }\n\n  // 5. If Desc does not have an [[Enumerable]] field, set Desc.[[Enumerable]] to like.[[Enumerable]].\n  if (!(\"enumerable\" in Desc)) Desc.enumerable = like.enumerable;\n\n  // 6. If Desc does not have a [[Configurable]] field, set Desc.[[Configurable]] to like.[[Configurable]].\n  if (!(\"configurable\" in Desc)) Desc.configurable = like.configurable;\n\n  // 7. Return Desc.\n  return Desc;\n}\n\n// ECMA262 9.1.6.2\nexport function IsCompatiblePropertyDescriptor(\n  realm: Realm,\n  extensible: boolean,\n  Desc: Descriptor,\n  current: ?Descriptor\n): boolean {\n  // 1. Return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current).\n  return ValidateAndApplyPropertyDescriptor(realm, undefined, undefined, extensible, Desc, current);\n}\n\n// ECMA262 9.1.6.3\nexport function ValidateAndApplyPropertyDescriptor(\n  realm: Realm,\n  O: void | ObjectValue,\n  P: void | PropertyKeyValue,\n  extensible: boolean,\n  Desc: Descriptor,\n  current: ?Descriptor\n): boolean {\n  // 1. Assert: If O is not undefined, then IsPropertyKey(P) is true.\n  if (O !== undefined) {\n    invariant(P !== undefined);\n    invariant(IsPropertyKey(realm, P));\n  }\n\n  // 2. If current is undefined, then\n  if (!current) {\n    // a. If extensible is false, return false.\n    if (!extensible) return false;\n\n    // b. Assert: extensible is true.\n    invariant(extensible === true, \"expected extensible to be true\");\n\n    // c. If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, then\n    if (IsGenericDescriptor(realm, Desc) || IsDataDescriptor(realm, Desc)) {\n      // i. If O is not undefined, create an own data property named P of object O whose [[Value]],\n      //    [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the\n      //    value of an attribute field of Desc is absent, the attribute of the newly created property is set\n      //    to its default value.\n      if (O !== undefined) {\n        invariant(P !== undefined);\n        InternalSetProperty(realm, O, P, {\n          value: \"value\" in Desc ? Desc.value : realm.intrinsics.undefined,\n          writable: \"writable\" in Desc ? Desc.writable : false,\n          enumerable: \"enumerable\" in Desc ? Desc.enumerable : false,\n          configurable: \"configurable\" in Desc ? Desc.configurable : false,\n        });\n        InternalUpdatedProperty(realm, O, P, undefined);\n      }\n    } else {\n      // d. Else Desc must be an accessor Property Descriptor,\n      // i. If O is not undefined, create an own accessor property named P of object O whose [[Get]],\n      //    [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value\n      //    of an attribute field of Desc is absent, the attribute of the newly created property is set to its\n      //    default value.\n      if (O !== undefined) {\n        invariant(P !== undefined);\n        InternalSetProperty(realm, O, P, {\n          get: \"get\" in Desc ? Desc.get : realm.intrinsics.undefined,\n          set: \"set\" in Desc ? Desc.set : realm.intrinsics.undefined,\n          enumerable: \"enumerable\" in Desc ? Desc.enumerable : false,\n          configurable: \"configurable\" in Desc ? Desc.configurable : false,\n        });\n        InternalUpdatedProperty(realm, O, P, undefined);\n      }\n    }\n\n    // e. Return true.\n    return true;\n  }\n  ThrowIfMightHaveBeenDeleted(current.value);\n\n  // 3. Return true, if every field in Desc is absent.\n  if (!Object.keys(Desc).length) return true;\n\n  // 4. Return true, if every field in Desc also occurs in current and the value of every field in Desc is the\n  // same value as the corresponding field in current when compared using the SameValue algorithm.\n  let identical = true;\n  for (let field in Desc) {\n    if (!(field in current)) {\n      identical = false;\n    } else {\n      let dval = InternalDescriptorPropertyToValue(realm, Desc[field]);\n      let cval = InternalDescriptorPropertyToValue(realm, current[field]);\n      if (dval instanceof ConcreteValue && cval instanceof ConcreteValue) identical = SameValue(realm, dval, cval);\n      else {\n        identical = dval === cval;\n        // This might be false now but true at runtime. This does not\n        // matter because the logic for non identical values will still\n        // do the right thing in the cases below that does not blow up\n        // when dealing with an abstract value.\n      }\n    }\n    if (!identical) break;\n  }\n  if (identical) {\n    return true;\n  }\n\n  // 5. If the [[Configurable]] field of current is false, then\n  if (!current.configurable) {\n    // a. Return false, if the [[Configurable]] field of Desc is true.\n    if (Desc.configurable) return false;\n\n    // b. Return false, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.\n    if (\"enumerable\" in Desc && Desc.enumerable !== current.enumerable) {\n      return false;\n    }\n  }\n\n  let oldDesc = current;\n  current = cloneDescriptor(current);\n  invariant(current !== undefined);\n\n  // 6. If IsGenericDescriptor(Desc) is true, no further validation is required.\n  if (IsGenericDescriptor(realm, Desc)) {\n  } else if (IsDataDescriptor(realm, current) !== IsDataDescriptor(realm, Desc)) {\n    // 7. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then\n    // a. Return false, if the [[Configurable]] field of current is false.\n    if (!current.configurable) return false;\n\n    // b. If IsDataDescriptor(current) is true, then\n    if (IsDataDescriptor(realm, current)) {\n      // i. If O is not undefined, convert the property named P of object O from a data property to an accessor property.\n      // Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.\n      if (O !== undefined) {\n        invariant(P !== undefined);\n        let key = InternalGetPropertiesKey(P);\n        let propertyBinding = InternalGetPropertiesMap(O, P).get(key);\n        invariant(propertyBinding !== undefined);\n        delete current.writable;\n        delete current.value;\n        current.get = realm.intrinsics.undefined;\n        current.set = realm.intrinsics.undefined;\n      }\n    } else {\n      // c. Else,\n      // i. If O is not undefined, convert the property named P of object O from an accessor property to a data property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.\n      if (O !== undefined) {\n        invariant(P !== undefined);\n        let key = InternalGetPropertiesKey(P);\n        let propertyBinding = InternalGetPropertiesMap(O, P).get(key);\n        invariant(propertyBinding !== undefined);\n        delete current.get;\n        delete current.set;\n        current.writable = false;\n        current.value = realm.intrinsics.undefined;\n      }\n    }\n  } else if (IsDataDescriptor(realm, current) && IsDataDescriptor(realm, Desc)) {\n    // 8. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then\n    // a. If the [[Configurable]] field of current is false, then\n    if (!current.configurable) {\n      // i. Return false, if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.\n      if (!current.writable && Desc.writable) return false;\n\n      // ii. If the [[Writable]] field of current is false, then\n      if (!current.writable) {\n        // 1. Return false, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false.\n        if (Desc.value && !SameValuePartial(realm, Desc.value, current.value || realm.intrinsics.undefined)) {\n          return false;\n        }\n      }\n    } else {\n      // b. Else the [[Configurable]] field of current is true, so any change is acceptable.\n    }\n  } else {\n    // 9. Else IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true,\n    // a. If the [[Configurable]] field of current is false, then\n    if (!current.configurable) {\n      // i. Return false, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false.\n      if (Desc.set && !SameValuePartial(realm, Desc.set, current.set || realm.intrinsics.undefined)) return false;\n\n      // ii. Return false, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false.\n      if (Desc.get && !SameValuePartial(realm, Desc.get, current.get || realm.intrinsics.undefined)) return false;\n    }\n  }\n\n  // 10. If O is not undefined, then\n  if (O !== undefined) {\n    invariant(P !== undefined);\n    let key = InternalGetPropertiesKey(P);\n    let map = InternalGetPropertiesMap(O, P);\n    let propertyBinding = map.get(key);\n    if (propertyBinding === undefined) {\n      propertyBinding = { descriptor: undefined, object: O, key: key };\n      realm.recordModifiedProperty(propertyBinding);\n      propertyBinding.descriptor = current;\n      map.set(key, propertyBinding);\n    } else if (propertyBinding.descriptor === undefined) {\n      realm.recordModifiedProperty(propertyBinding);\n      propertyBinding.descriptor = current;\n    } else {\n      realm.recordModifiedProperty(propertyBinding);\n      propertyBinding.descriptor = current;\n    }\n\n    // a. For each field of Desc that is present, set the corresponding attribute of the property named P of\n    //    object O to the value of the field.\n    for (let field in Desc) current[field] = Desc[field];\n    InternalUpdatedProperty(realm, O, P, oldDesc);\n  }\n\n  // 11. Return true.\n  return true;\n}\n\n// ECMA262 9.1.6.1\nexport function OrdinaryDefineOwnProperty(\n  realm: Realm,\n  O: ObjectValue,\n  P: PropertyKeyValue,\n  Desc: Descriptor\n): boolean {\n  invariant(O instanceof ObjectValue);\n\n  // 1. Let current be ? O.[[GetOwnProperty]](P).\n  let current = O.$GetOwnProperty(P);\n\n  // 2. Let extensible be the value of the [[Extensible]] internal slot of O.\n  let extensible = O.getExtensible();\n\n  // 3. Return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current).\n  return ValidateAndApplyPropertyDescriptor(realm, O, P, extensible, Desc, current);\n}\n\n// ECMA262 19.1.2.3.1\nexport function ObjectDefineProperties(realm: Realm, O: Value, Properties: Value): ObjectValue | AbstractObjectValue {\n  // 1. If Type(O) is not Object, throw a TypeError exception.\n  if (!(O instanceof ObjectValue || O instanceof AbstractObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // 2. Let props be ? ToObject(Properties).\n  let props = ToObject(realm, Properties.throwIfNotConcrete());\n\n  // 3. Let keys be ? props.[[OwnPropertyKeys]]().\n  let keys = props.$OwnPropertyKeys();\n\n  // 4. Let descriptors be a new empty List.\n  let descriptors = [];\n\n  // 5. Repeat for each element nextKey of keys in List order,\n  for (let nextKey of keys) {\n    // a. Let propDesc be ? props.[[GetOwnProperty]](nextKey).\n    let propDesc = props.$GetOwnProperty(nextKey);\n\n    // b. If propDesc is not undefined and propDesc.[[Enumerable]] is true, then\n    if (propDesc && propDesc.enumerable) {\n      ThrowIfMightHaveBeenDeleted(propDesc.value);\n\n      // i. Let descObj be ? Get(props, nextKey).\n      let descObj = Get(realm, props, nextKey);\n\n      // ii. Let desc be ? ToPropertyDescriptor(descObj).\n      let desc = ToPropertyDescriptor(realm, descObj);\n\n      // iii. Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.\n      descriptors.push([nextKey, desc]);\n    }\n  }\n\n  // 6. For each pair from descriptors in list order,\n  for (let pair of descriptors) {\n    // a. Let P be the first element of pair.\n    let P = pair[0];\n\n    // b. Let desc be the second element of pair.\n    let desc = pair[1];\n\n    // c. Perform ? DefinePropertyOrThrow(O, P, desc).\n    DefinePropertyOrThrow(realm, O, P, desc);\n  }\n\n  // 7. Return O.\n  return O;\n}\n\n// ECMA262 7.3.3\nexport function Set(\n  realm: Realm,\n  O: ObjectValue | AbstractObjectValue,\n  P: PropertyKeyValue,\n  V: Value,\n  Throw: boolean\n): boolean {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue || O instanceof AbstractObjectValue, \"expected object value\");\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 3. Assert: Type(Throw) is Boolean.\n  invariant(typeof Throw === \"boolean\", \"expected boolean\");\n\n  // 4. Let success be ? O.[[Set]](P, V, O).\n  let success = O.$Set(P, V, O);\n\n  // 5. If success is false and Throw is true, throw a TypeError exception.\n  if (success === false && Throw === true) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // 6. Return success.\n  return success;\n}\n\n// ECMA262 7.3.7\nexport function DefinePropertyOrThrow(\n  realm: Realm,\n  O: ObjectValue | AbstractObjectValue,\n  P: PropertyKeyValue,\n  desc: Descriptor\n): boolean {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue || O instanceof AbstractObjectValue, \"expected object\");\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(typeof P === \"string\" || IsPropertyKey(realm, P), \"expected property key\");\n\n  // 3. Let success be ? O.[[DefineOwnProperty]](P, desc).\n  let success = O.$DefineOwnProperty(P, desc);\n\n  // 4. If success is false, throw a TypeError exception.\n  if (success === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // 5. Return success.\n  return success;\n}\n\n// ECMA262 6.2.3.2\nexport function PutValue(realm: Realm, V: Value | Reference, W: Value) {\n  W = W.promoteEmptyToUndefined();\n  // The following two steps are not necessary as we propagate completions with exceptions.\n  // 1. ReturnIfAbrupt(V).\n  // 2. ReturnIfAbrupt(W).\n\n  // 3. If Type(V) is not Reference, throw a ReferenceError exception.\n  if (!(V instanceof Reference)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, \"can't put a value to a non-reference\");\n  }\n\n  // 4. Let base be GetBase(V).\n  let base = GetBase(realm, V);\n\n  // 5. If IsUnresolvableReference(V) is true, then\n  if (IsUnresolvableReference(realm, V)) {\n    // a. If IsStrictReference(V) is true, then\n    if (IsStrictReference(realm, V)) {\n      // i. Throw a ReferenceError exception.\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // b. Let globalObj be GetGlobalObject().\n    let globalObj = GetGlobalObject(realm);\n\n    // c. Return ? Set(globalObj, GetReferencedName(V), W, false).\n    return Set(realm, globalObj, GetReferencedName(realm, V), W, false);\n  }\n\n  // 6. Else if IsPropertyReference(V) is true, then\n  if (IsPropertyReference(realm, V)) {\n    // a. If HasPrimitiveBase(V) is true, then\n    if (HasPrimitiveBase(realm, V)) {\n      // i. Assert: In realm case, base will never be null or undefined.\n      invariant(base instanceof Value && !HasSomeCompatibleType(base, UndefinedValue, NullValue));\n\n      // ii. Set base to ToObject(base).\n      base = ToObjectPartial(realm, base);\n    }\n    invariant(base instanceof ObjectValue || base instanceof AbstractObjectValue);\n\n    // b. Let succeeded be ? base.[[Set]](GetReferencedName(V), W, GetThisValue(V)).\n    let succeeded = base.$SetPartial(GetReferencedNamePartial(realm, V), W, GetThisValue(realm, V));\n\n    // c. If succeeded is false and IsStrictReference(V) is true, throw a TypeError exception.\n    if (succeeded === false && IsStrictReference(realm, V)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // d. Return.\n    return;\n  }\n\n  // 7. Else base must be an Environment Record,\n  if (base instanceof EnvironmentRecord) {\n    // a. Return ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (see 8.1.1).\n    let referencedName = GetReferencedName(realm, V);\n    invariant(typeof referencedName === \"string\");\n    return base.SetMutableBinding(referencedName, W, IsStrictReference(realm, V));\n  }\n\n  invariant(false);\n}\n\n// ECMA262 9.4.2.4\nexport function ArraySetLength(realm: Realm, A: ArrayValue, Desc: Descriptor): boolean {\n  // 1. If the [[Value]] field of Desc is absent, then\n  let DescValue = Desc.value;\n  if (!DescValue) {\n    // a. Return OrdinaryDefineOwnProperty(A, \"length\", Desc).\n    return OrdinaryDefineOwnProperty(realm, A, \"length\", Desc);\n  }\n\n  // 2. Let newLenDesc be a copy of Desc.\n  let newLenDesc = Object.assign({}, Desc);\n\n  // 3. Let newLen be ? ToUint32(Desc.[[Value]]).\n  let newLen = ToUint32(realm, DescValue);\n\n  // 4. Let numberLen be ? ToNumber(Desc.[[Value]]).\n  let numberLen = ToNumber(realm, DescValue);\n\n  // 5. If newLen ≠ numberLen, throw a RangeError exception.\n  if (newLen !== numberLen) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"should be a uint\");\n  }\n\n  // 6. Set newLenDesc.[[Value]] to newLen.\n  newLenDesc.value = new NumberValue(realm, newLen);\n\n  // 7. Let oldLenDesc be OrdinaryGetOwnProperty(A, \"length\").\n  let oldLenDesc = OrdinaryGetOwnProperty(realm, A, \"length\");\n\n  // 8. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created\n  //    with a length data property that cannot be deleted or reconfigured.\n  invariant(\n    oldLenDesc !== undefined && !IsAccessorDescriptor(realm, oldLenDesc),\n    \"cannot be undefined or an accessor descriptor\"\n  );\n\n  // 9. Let oldLen be oldLenDesc.[[Value]].\n  let oldLen = oldLenDesc.value;\n  invariant(oldLen !== undefined);\n  oldLen = oldLen.throwIfNotConcrete();\n  invariant(oldLen instanceof NumberValue, \"should be a number\");\n  oldLen = (oldLen.value: number);\n\n  // 10. If newLen ≥ oldLen, then\n  if (newLen >= oldLen) {\n    // a. Return OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n    return OrdinaryDefineOwnProperty(realm, A, \"length\", newLenDesc);\n  }\n\n  // 11. If oldLenDesc.[[Writable]] is false, return false.\n  if (!oldLenDesc.writable) return false;\n\n  // 12. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.\n  let newWritable;\n  if (!(\"writable\" in newLenDesc) || newLenDesc.writable === true) {\n    newWritable = true;\n  } else {\n    // 13. Else,\n    // a. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.\n\n    // b. Let newWritable be false.\n    newWritable = false;\n\n    // c. Set newLenDesc.[[Writable]] to true.\n    newLenDesc.writable = true;\n  }\n\n  // 14. Let succeeded be ! OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n  let succeeded = OrdinaryDefineOwnProperty(realm, A, \"length\", newLenDesc);\n\n  // 15. If succeeded is false, return false.\n  if (succeeded === false) return false;\n\n  // Here we diverge from the spec: instead of traversing all indices from\n  // oldLen to newLen, only the indices that are actually present are touched.\n  let oldLenCopy = oldLen;\n  let keys = Array.from(A.properties.keys())\n    .map(x => parseInt(x, 10))\n    .filter(x => newLen <= x && x <= oldLenCopy)\n    .sort()\n    .reverse();\n\n  // 16. While newLen < oldLen repeat,\n  for (let key of keys) {\n    // a. Set oldLen to oldLen - 1.\n    oldLen = key;\n\n    // b. Let deleteSucceeded be ! A.[[Delete]](! ToString(oldLen)).\n    let deleteSucceeded = A.$Delete(oldLen + \"\");\n\n    // c. If deleteSucceeded is false, then\n    if (deleteSucceeded === false) {\n      // i. Set newLenDesc.[[Value]] to oldLen + 1.\n      newLenDesc.value = new NumberValue(realm, oldLen + 1);\n\n      // ii. If newWritable is false, set newLenDesc.[[Writable]] to false.\n      if (newWritable === false) newLenDesc.writable = false;\n\n      // iii. Let succeeded be ! OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n      succeeded = OrdinaryDefineOwnProperty(realm, A, \"length\", newLenDesc);\n\n      // iv. Return false.\n      return false;\n    }\n  }\n\n  // 17. If newWritable is false, then\n  if (!newWritable) {\n    // a. Return OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor{[[Writable]]: false}). This call will always return true.\n    return OrdinaryDefineOwnProperty(realm, A, \"length\", {\n      writable: false,\n    });\n  }\n\n  // 18. Return true.\n  return true;\n}\n\n// ECMA262 9.1.5.1\nexport function OrdinaryGetOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue): Descriptor | void {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected a property key\");\n\n  // 2. If O does not have an own property with key P, return undefined.\n  let existingBinding = InternalGetPropertiesMap(O, P).get(InternalGetPropertiesKey(P));\n  if (!existingBinding) {\n    if (O.isPartial() && !O.isSimple()) {\n      AbstractValue.reportIntrospectionError(O, P);\n      throw new FatalError();\n    }\n    return undefined;\n  }\n  realm.callReportPropertyAccess(existingBinding);\n  if (!existingBinding.descriptor) return undefined;\n\n  // 3. Let D be a newly created Property Descriptor with no fields.\n  let D = {};\n\n  // 4. Let X be O's own property whose key is P.\n  let X = existingBinding.descriptor;\n  invariant(X !== undefined);\n\n  // 5. If X is a data property, then\n  if (IsDataDescriptor(realm, X)) {\n    let value = X.value;\n    if (O.isPartial() && value instanceof AbstractValue && value.kind !== \"resolved\") {\n      let realmGenerator = realm.generator;\n      invariant(realmGenerator);\n      value = realmGenerator.derive(value.types, value.values, value.args, value._buildNode, { kind: \"resolved\" });\n      InternalSetProperty(realm, O, P, {\n        value: value,\n        writable: \"writable\" in X ? X.writable : false,\n        enumerable: \"enumerable\" in X ? X.enumerable : false,\n        configurable: \"configurable\" in X ? X.configurable : false,\n      });\n    }\n\n    // a. Set D.[[Value]] to the value of X's [[Value]] attribute.\n    D.value = value;\n\n    // b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.\n    D.writable = X.writable;\n  } else {\n    // 6. Else X is an accessor property,\n    invariant(IsAccessorDescriptor(realm, X), \"expected accessor property\");\n\n    // a. Set D.[[Get]] to the value of X's [[Get]] attribute.\n    D.get = X.get;\n\n    // b. Set D.[[Set]] to the value of X's [[Set]] attribute.\n    D.set = X.set;\n  }\n\n  // 7. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.\n  D.enumerable = X.enumerable;\n\n  // 8. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.\n  D.configurable = X.configurable;\n\n  // 9. Return D.\n  return D;\n}\n\n// ECMA262 9.1.2.1\nexport function OrdinarySetPrototypeOf(realm: Realm, O: ObjectValue, V: ObjectValue | NullValue): boolean {\n  // 1. Assert: Either Type(V) is Object or Type(V) is Null.\n  invariant(V instanceof ObjectValue || V instanceof NullValue);\n\n  // 2. Let extensible be the value of the [[Extensible]] internal slot of O.\n  let extensible = O.getExtensible();\n\n  // 3. Let current be the value of the [[Prototype]] internal slot of O.\n  let current = O.$Prototype;\n\n  // 4. If SameValue(V, current) is true, return true.\n  if (SameValue(realm, V, current)) return true;\n\n  // 5. If extensible is false, return false.\n  if (!extensible) return false;\n\n  // 6. Let p be V.\n  let p = V;\n\n  // 7. Let done be false.\n  let done = false;\n\n  // 8. Repeat while done is false,\n  while (!done) {\n    // a. If p is null, let done be true.\n    if (p instanceof NullValue) {\n      done = true;\n    } else if (SameValue(realm, p, O)) {\n      // b. Else if SameValue(p, O) is true, return false.\n      return false;\n    } else {\n      // c. Else,\n      // TODO i. If the [[GetPrototypeOf]] internal method of p is not the ordinary object internal method defined in 9.1.1, let done be true.\n\n      // ii. Else, let p be the value of p's [[Prototype]] internal slot.\n      p = p.$Prototype;\n    }\n  }\n\n  // 9. Set the value of the [[Prototype]] internal slot of O to V.\n  O.$Prototype = V;\n\n  // 10. Return true.\n  return true;\n}\n\n// ECMA262 13.7.5.15\nexport function EnumerateObjectProperties(realm: Realm, O: ObjectValue) {\n  /*global global*/\n  let visited = new global.Set();\n  let obj = O;\n  let keys = O.$OwnPropertyKeys();\n  let index = 0;\n\n  let iterator = new ObjectValue(realm);\n  iterator.defineNativeMethod(\"next\", 0, () => {\n    while (true) {\n      if (index >= keys.length) {\n        let proto = obj.$GetPrototypeOf();\n        if (proto instanceof NullValue) {\n          return CreateIterResultObject(realm, realm.intrinsics.undefined, true);\n        }\n        obj = proto;\n        keys = obj.$OwnPropertyKeys();\n        index = 0;\n      }\n\n      let key = keys[index];\n\n      // Omit symbols.\n      if (!(key instanceof StringValue)) {\n        index += 1;\n        continue;\n      }\n\n      // Omit non-enumerable properties.\n      let desc = obj.$GetOwnProperty(key);\n      if (desc && !desc.enumerable) {\n        ThrowIfMightHaveBeenDeleted(desc.value);\n        index += 1;\n        visited.add(key.value);\n        continue;\n      }\n\n      // Omit duplicates.\n      if (visited.has(key.value)) {\n        index += 1;\n        continue;\n      }\n      visited.add(key.value);\n\n      // Yield the key.\n      return CreateIterResultObject(realm, key, false);\n    }\n  });\n  return iterator;\n}\n\nexport function ThrowIfMightHaveBeenDeleted(value: void | Value): void {\n  if (value === undefined) return;\n  if (!value.mightHaveBeenDeleted()) return;\n  invariant(value instanceof AbstractValue); // real empty values should never get here\n  AbstractValue.reportIntrospectionError(value);\n  throw new FatalError();\n}\n\nexport function ThrowIfInternalSlotNotWritable<T: ObjectValue>(realm: Realm, object: T, key: string): T {\n  if (!realm.isNewObject(object)) {\n    AbstractValue.reportIntrospectionError(object, key);\n    throw new FatalError();\n  }\n  return object;\n}\n\n// ECMA 14.3.9\nexport function PropertyDefinitionEvaluation(\n  realm: Realm,\n  MethodDefinition: BabelNodeObjectMethod | BabelNodeClassMethod,\n  object: ObjectValue,\n  env: LexicalEnvironment,\n  strictCode: boolean,\n  enumerable: boolean\n) {\n  // MethodDefinition : PropertyName ( StrictFormalParameters ) { FunctionBody }\n  if (MethodDefinition.kind === \"method\") {\n    // 1. Let methodDef be DefineMethod of MethodDefinition with argument object.\n    let methodDef = DefineMethod(realm, MethodDefinition, object, env, strictCode);\n\n    // 2. ReturnIfAbrupt(methodDef).\n\n    // 3. Perform SetFunctionName(methodDef.[[closure]], methodDef.[[key]]).\n    SetFunctionName(realm, methodDef.$Closure, methodDef.$Key);\n\n    // 4. Let desc be the Property Descriptor{[[Value]]: methodDef.[[closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n    let desc: Descriptor = { value: methodDef.$Closure, writable: true, enumerable: enumerable, configurable: true };\n\n    // 5. Return DefinePropertyOrThrow(object, methodDef.[[key]], desc).\n    return DefinePropertyOrThrow(realm, object, methodDef.$Key, desc);\n  } else if (MethodDefinition.kind === \"generator\") {\n    // MethodDefinition : GeneratorMethod\n    // See 14.4.\n    // ECMA 14.4.13\n    // 1. Let propKey be the result of evaluating PropertyName.\n    let propKey = EvalPropertyName(MethodDefinition, env, realm, strictCode);\n\n    // 2. ReturnIfAbrupt(propKey).\n    // 3. If the function code for this GeneratorMethod is strict mode code, let strict be true. Otherwise let strict be false.\n    let strict = strictCode || IsStrict(MethodDefinition.body);\n\n    // 4. Let scope be the running execution context’s LexicalEnvironment.\n    let scope = env;\n\n    // 5. Let closure be GeneratorFunctionCreate(Method, StrictFormalParameters, GeneratorBody, scope, strict).\n    let closure = GeneratorFunctionCreate(\n      realm,\n      \"method\",\n      MethodDefinition.params,\n      MethodDefinition.body,\n      scope,\n      strict\n    );\n\n    // 6. Perform MakeMethod(closure, object).\n    MakeMethod(realm, closure, object);\n\n    // 7. Let prototype be ObjectCreate(%GeneratorPrototype%).\n    let prototype = ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n    prototype.originalConstructor = closure;\n\n    // 8. Perform MakeConstructor(closure, true, prototype).\n    MakeConstructor(realm, closure, true, prototype);\n\n    // 9. Perform SetFunctionName(closure, propKey).\n    SetFunctionName(realm, closure, propKey);\n\n    // 10. Let desc be the Property Descriptor{[[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n    let desc: Descriptor = { value: closure, writable: true, enumerable: enumerable, configurable: true };\n\n    // 11. Return DefinePropertyOrThrow(object, propKey, desc).\n    return DefinePropertyOrThrow(realm, object, propKey, desc);\n  } else if (MethodDefinition.kind === \"get\") {\n    // 1. Let propKey be the result of evaluating PropertyName.\n    let propKey = EvalPropertyName(MethodDefinition, env, realm, strictCode);\n\n    // 2. ReturnIfAbrupt(propKey).\n\n    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n    let strict = strictCode || IsStrict(MethodDefinition.body);\n\n    // 4. Let scope be the running execution context's LexicalEnvironment.\n    let scope = env;\n\n    // 5. Let formalParameterList be the production FormalParameters:[empty] .\n    let formalParameterList = [];\n\n    // 6. Let closure be FunctionCreate(Method, formalParameterList, FunctionBody, scope, strict).\n    let closure = FunctionCreate(realm, \"method\", formalParameterList, MethodDefinition.body, scope, strict);\n\n    // 7. Perform MakeMethod(closure, object).\n    MakeMethod(realm, closure, object);\n\n    // 8. Perform SetFunctionName(closure, propKey, \"get\").\n    SetFunctionName(realm, closure, propKey, \"get\");\n\n    // 9. Let desc be the PropertyDescriptor{[[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n    let desc = {\n      get: closure,\n      enumerable: true,\n      configurable: true,\n    };\n\n    // 10. Return ? DefinePropertyOrThrow(object, propKey, desc).\n    DefinePropertyOrThrow(realm, object, propKey, desc);\n  } else if (MethodDefinition.kind === \"set\") {\n    // 1. Let propKey be the result of evaluating PropertyName.\n    let propKey = EvalPropertyName(MethodDefinition, env, realm, strictCode);\n\n    // 2. ReturnIfAbrupt(propKey).\n\n    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n    let strict = strictCode || IsStrict(MethodDefinition.body);\n\n    // 4. Let scope be the running execution context's LexicalEnvironment.\n    let scope = env;\n\n    // 5. Let closure be FunctionCreate(Method, PropertySetParameterList, FunctionBody, scope, strict).\n    let closure = FunctionCreate(realm, \"method\", MethodDefinition.params, MethodDefinition.body, scope, strict);\n\n    // 6. Perform MakeMethod(closure, object).\n    MakeMethod(realm, closure, object);\n\n    // 7. Perform SetFunctionName(closure, propKey, \"set\").\n    SetFunctionName(realm, closure, propKey, \"set\");\n\n    // 8. Let desc be the PropertyDescriptor{[[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n    let desc = {\n      set: closure,\n      enumerable: true,\n      configurable: true,\n    };\n\n    // 9. Return ? DefinePropertyOrThrow(object, propKey, desc).\n    DefinePropertyOrThrow(realm, object, propKey, desc);\n  }\n}\n"]}