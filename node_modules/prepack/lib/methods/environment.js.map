{"version":3,"sources":["../../src/methods/environment.js"],"names":["IsSuperReference","HasPrimitiveBase","GetReferencedName","GetReferencedNamePartial","GetValue","IsStrictReference","IsPropertyReference","GetBase","IsUnresolvableReference","NewDeclarativeEnvironment","BoundNames","ContainsExpression","ResolveBinding","GetIdentifierReference","InitializeReferencedBinding","BlockDeclarationInstantiation","NewGlobalEnvironment","NewObjectEnvironment","NewFunctionEnvironment","GetActiveScriptOrModule","GetThisEnvironment","ResolveThisBinding","BindingInitialization","IteratorBindingInitialization","InitializeBoundName","IsDestructuring","KeyedBindingInitialization","t","realm","V","thisValue","undefined","base","type","getType","referencedName","reportIntrospectionError","createErrorThrowCompletion","intrinsics","ReferenceError","toString","$GetPartial","GetBindingValue","strict","E","env","envRec","environmentRecord","parent","node","Object","keys","getOuterBindingIdentifiers","properties","prop","elements","elem","argument","name","getRunningContext","lexicalEnvironment","lex","exists","HasBinding","outer","W","InitializeBinding","strictCode","body","declarations","kind","push","d","dn","SyntaxError","CreateImmutableBinding","CreateMutableBinding","fn","fo","evaluate","G","objRec","dclRec","globalRec","$ObjectRecord","$GlobalThisValue","$DeclarativeRecord","$VarNames","O","F","newTarget","$FunctionObject","$ThisMode","$ThisBindingStatus","home","$HomeObject","$NewTarget","$Environment","contextStack","length","ec","i","function","$ScriptOrModule","ScriptOrModule","HasThisBinding","GetThisBinding","value","environment","iterator","iteratorRecord","$Iterator","$Done","result","error","completion","property","P","decl","id","formals","restEl","lastFormal","slice","param","next","e","Initializer","right","left","bindingId","lhs","v","defaultValue","hasNameProperty","A","n","nextValue","status","ast","propertyName"],"mappings":"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","file":"environment.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport {\n  AbstractValue,\n  UndefinedValue,\n  NullValue,\n  NumberValue,\n  BooleanValue,\n  SymbolValue,\n  ECMAScriptFunctionValue,\n  ObjectValue,\n  StringValue,\n  Value,\n  AbstractObjectValue,\n} from \"../values/index.js\";\nimport {\n  ObjectEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  EnvironmentRecord,\n  DeclarativeEnvironmentRecord,\n  GlobalEnvironmentRecord,\n  Reference,\n  LexicalEnvironment,\n} from \"../environment.js\";\nimport { NormalCompletion, AbruptCompletion } from \"../completions.js\";\nimport { FatalError } from \"../errors.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport {\n  GetV,\n  GetThisValue,\n  ToObjectPartial,\n  PutValue,\n  RequireObjectCoercible,\n  HasSomeCompatibleType,\n  GetIterator,\n  IteratorStep,\n  IteratorValue,\n  IteratorClose,\n  CreateDataProperty,\n  ArrayCreate,\n  IsAnonymousFunctionDefinition,\n  HasOwnProperty,\n  SetFunctionName,\n} from \"./index.js\";\nimport type {\n  BabelNode,\n  BabelNodeVariableDeclaration,\n  BabelNodeIdentifier,\n  BabelNodeRestElement,\n  BabelNodeObjectPattern,\n  BabelNodeArrayPattern,\n  BabelNodeStatement,\n  BabelNodeLVal,\n  BabelNodePattern,\n} from \"babel-types\";\n\n// ECMA262 6.2.3\n// IsSuperReference(V). Returns true if this reference has a thisValue component.\nexport function IsSuperReference(realm: Realm, V: Reference): boolean {\n  return V.thisValue !== undefined;\n}\n\n// ECMA262 6.2.3\n// HasPrimitiveBase(V). Returns true if Type(base) is Boolean, String, Symbol, or Number.\nexport function HasPrimitiveBase(realm: Realm, V: Reference): boolean {\n  let base = GetBase(realm, V);\n  // void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord | AbstractValue;\n  if (!base || base instanceof EnvironmentRecord) return false;\n  if (base instanceof ObjectValue || base instanceof AbstractObjectValue) return false;\n  let type = base.getType();\n  return type === BooleanValue || type === StringValue || type === SymbolValue || type === NumberValue;\n}\n\n// ECMA262 6.2.3\n// GetReferencedName(V). Returns the referenced name component of the reference V.\nexport function GetReferencedName(realm: Realm, V: Reference): string | SymbolValue {\n  if (V.referencedName instanceof AbstractValue) {\n    AbstractValue.reportIntrospectionError(V.referencedName);\n    throw new FatalError();\n  }\n  return V.referencedName;\n}\n\nexport function GetReferencedNamePartial(realm: Realm, V: Reference): AbstractValue | string | SymbolValue {\n  return V.referencedName;\n}\n\n// ECMA262 6.2.3.1\nexport function GetValue(realm: Realm, V: Reference | Value): Value {\n  // This step is not necessary as we propagate completions with exceptions.\n  // 1. ReturnIfAbrupt(V).\n\n  // 2. If Type(V) is not Reference, return V.\n  if (!(V instanceof Reference)) return V;\n\n  // 3. Let base be GetBase(V).\n  let base = GetBase(realm, V);\n\n  // 4. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.\n  if (IsUnresolvableReference(realm, V)) {\n    throw realm.createErrorThrowCompletion(\n      realm.intrinsics.ReferenceError,\n      `${V.referencedName.toString()} is not defined`\n    );\n  }\n\n  // 5. If IsPropertyReference(V) is true, then\n  if (IsPropertyReference(realm, V)) {\n    // a. If HasPrimitiveBase(V) is true, then\n    if (HasPrimitiveBase(realm, V)) {\n      // i. Assert: In this case, base will never be null or undefined.\n      invariant(base instanceof Value && !HasSomeCompatibleType(base, UndefinedValue, NullValue));\n\n      // ii. Let base be ToObject(base).\n      base = ToObjectPartial(realm, base);\n    }\n    invariant(base instanceof ObjectValue || base instanceof AbstractObjectValue);\n\n    // b. Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).\n    return base.$GetPartial(GetReferencedNamePartial(realm, V), GetThisValue(realm, V));\n  }\n\n  // 6. Else base must be an Environment Record,\n  if (base instanceof EnvironmentRecord) {\n    // a. Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).\n    let referencedName = GetReferencedName(realm, V);\n    invariant(typeof referencedName === \"string\");\n    return base.GetBindingValue(referencedName, IsStrictReference(realm, V));\n  }\n\n  invariant(false);\n}\n\n// ECMA262 6.2.3\n// IsStrictReference(V). Returns the strict reference flag component of the reference V.\nexport function IsStrictReference(realm: Realm, V: Reference): boolean {\n  return V.strict;\n}\n\n// ECMA262 6.2.3\n// IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.\nexport function IsPropertyReference(realm: Realm, V: Reference): boolean {\n  // V.base is AbstractValue | void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord;\n  return V.base instanceof AbstractValue || V.base instanceof ObjectValue || HasPrimitiveBase(realm, V);\n}\n\n// ECMA262 6.2.3\n// GetBase(V). Returns the base value component of the reference V.\nexport function GetBase(realm: Realm, V: Reference): void | Value | EnvironmentRecord {\n  return V.base;\n}\n\n// ECMA262 6.2.3\n// IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.\nexport function IsUnresolvableReference(realm: Realm, V: Reference): boolean {\n  return !V.base;\n}\n\n// ECMA262 8.1.2.2\nexport function NewDeclarativeEnvironment(realm: Realm, E: LexicalEnvironment): LexicalEnvironment {\n  // 1. Let env be a new Lexical Environment.\n  let env = new LexicalEnvironment(realm);\n\n  // 2. Let envRec be a new declarative Environment Record containing no bindings.\n  let envRec = new DeclarativeEnvironmentRecord(realm);\n\n  // 3. Set env's EnvironmentRecord to envRec.\n  env.environmentRecord = envRec;\n\n  // 4. Set the outer lexical environment reference of env to E.\n  env.parent = E;\n\n  // 5. Return env.\n  return env;\n}\n\nexport function BoundNames(realm: Realm, node: BabelNode): Array<string> {\n  return Object.keys(t.getOuterBindingIdentifiers(node));\n}\n\n// ECMA262 13.3.3.2\nexport function ContainsExpression(realm: Realm, node: ?BabelNode): boolean {\n  if (!node) {\n    return false;\n  }\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (let prop of ((node: any): BabelNodeObjectPattern).properties) {\n        if (ContainsExpression(realm, prop)) return true;\n      }\n      return false;\n    case \"ArrayPattern\":\n      for (let elem of ((node: any): BabelNodeArrayPattern).elements) {\n        if (ContainsExpression(realm, elem)) return true;\n      }\n      return false;\n    case \"RestElement\":\n      return ContainsExpression(realm, ((node: any): BabelNodeRestElement).argument);\n    case \"AssignmentPattern\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// ECMA262 8.3.2\nexport function ResolveBinding(realm: Realm, name: string, strict: boolean, env?: ?LexicalEnvironment): Reference {\n  // 1. If env was not passed or if env is undefined, then\n  if (!env) {\n    // a. Let env be the running execution context's LexicalEnvironment.\n    env = realm.getRunningContext().lexicalEnvironment;\n  }\n\n  // 2. Assert: env is a Lexical Environment.\n  invariant(env instanceof LexicalEnvironment, \"expected lexical environment\");\n\n  // 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.\n\n  // 4. Return ? GetIdentifierReference(env, name, strict).\n  return GetIdentifierReference(realm, env, name, strict);\n}\n\n// ECMA262 8.1.2.1\nexport function GetIdentifierReference(\n  realm: Realm,\n  lex: ?LexicalEnvironment,\n  name: string,\n  strict: boolean\n): Reference {\n  // 1. If lex is the value null, then\n  if (!lex) {\n    // a. Return a value of type Reference whose base value is undefined, whose referenced name is name, and whose strict reference flag is strict.\n    return new Reference(undefined, name, strict);\n  }\n\n  // 2. Let envRec be lex's EnvironmentRecord.\n  let envRec = lex.environmentRecord;\n\n  // 3. Let exists be ? envRec.HasBinding(name).\n  let exists = envRec.HasBinding(name);\n\n  // 4. If exists is true, then\n  if (exists) {\n    // a. Return a value of type Reference whose base value is envRec, whose referenced name is name, and whose strict reference flag is strict.\n    return new Reference(envRec, name, strict);\n  } else {\n    // 5. Else,\n    // a. Let outer be the value of lex's outer environment reference.\n    let outer = lex.parent;\n\n    // b. Return ? GetIdentifierReference(outer, name, strict).\n    return GetIdentifierReference(realm, outer, name, strict);\n  }\n}\n\n// ECMA262 6.2.3.4\nexport function InitializeReferencedBinding(realm: Realm, V: Reference, W: Value): Value {\n  // 1. ReturnIfAbrupt(V).\n  // 2. ReturnIfAbrupt(W).\n\n  // 3. Assert: Type(V) is Reference.\n  invariant(V instanceof Reference, \"expected reference\");\n\n  // 4. Assert: IsUnresolvableReference(V) is false.\n  invariant(!IsUnresolvableReference(realm, V), \"expected resolvable reference\");\n\n  // 5. Let base be GetBase(V).\n  let base = GetBase(realm, V);\n\n  // 6. Assert: base is an Environment Record.\n  invariant(base instanceof EnvironmentRecord, \"expected environment record\");\n\n  // 7. Return base.InitializeBinding(GetReferencedName(V), W).\n  let referencedName = GetReferencedName(realm, V);\n  invariant(typeof referencedName === \"string\");\n  return base.InitializeBinding(referencedName, W);\n}\n\n// ECMA262 13.2.14\nexport function BlockDeclarationInstantiation(\n  realm: Realm,\n  strictCode: boolean,\n  body: Array<BabelNodeStatement>,\n  env: LexicalEnvironment\n) {\n  // 1. Let envRec be env's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a declarative Environment Record.\n  invariant(envRec instanceof DeclarativeEnvironmentRecord, \"expected declarative environment record\");\n\n  // 3. Let declarations be the LexicallyScopedDeclarations of code.\n  let declarations = [];\n  for (let node of body) {\n    if (node.type === \"FunctionDeclaration\" || (node.type === \"VariableDeclaration\" && node.kind !== \"var\")) {\n      declarations.push(node);\n    }\n  }\n\n  // 4. For each element d in declarations do\n  for (let d of declarations) {\n    // a. For each element dn of the BoundNames of d do\n    for (let dn of BoundNames(realm, d)) {\n      if (envRec.HasBinding(dn)) {\n        //ECMA262 13.2.1\n        throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, dn + \" already declared\");\n      }\n      // i. If IsConstantDeclaration of d is true, then\n      if (d.type === \"VariableDeclaration\" && d.kind === \"const\") {\n        // 1. Perform ! envRec.CreateImmutableBinding(dn, true).\n        envRec.CreateImmutableBinding(dn, true);\n      } else {\n        // ii. Else,\n        // 1. Perform ! envRec.CreateMutableBinding(dn, false).\n        envRec.CreateMutableBinding(dn, false);\n      }\n    }\n\n    // b. If d is a GeneratorDeclaration production or a FunctionDeclaration production, then\n    if (d.type === \"FunctionDeclaration\") {\n      // i. Let fn be the sole element of the BoundNames of d.\n      let fn = BoundNames(realm, d)[0];\n\n      // ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env.\n      let fo = env.evaluate(d, strictCode);\n      invariant(fo instanceof Value);\n\n      // iii. Perform envRec.InitializeBinding(fn, fo).\n      envRec.InitializeBinding(fn, fo);\n    }\n  }\n}\n\n// ECMA262 8.1.2.5\nexport function NewGlobalEnvironment(\n  realm: Realm,\n  G: ObjectValue | AbstractObjectValue,\n  thisValue: ObjectValue | AbstractObjectValue\n) {\n  // 1. Let env be a new Lexical Environment.\n  let env = new LexicalEnvironment(realm);\n\n  // 2. Let objRec be a new object Environment Record containing G as the binding object.\n  let objRec = new ObjectEnvironmentRecord(realm, G);\n\n  // 3. Let dclRec be a new declarative Environment Record containing no bindings.\n  let dclRec = new DeclarativeEnvironmentRecord(realm);\n\n  // 4. Let globalRec be a new global Environment Record.\n  let globalRec = new GlobalEnvironmentRecord(realm);\n\n  // 5. Set globalRec.[[ObjectRecord]] to objRec.\n  globalRec.$ObjectRecord = objRec;\n\n  // 6. Set globalRec.[[GlobalThisValue]] to thisValue.\n  globalRec.$GlobalThisValue = thisValue;\n\n  // 7. Set globalRec.[[DeclarativeRecord]] to dclRec.\n  globalRec.$DeclarativeRecord = dclRec;\n\n  // 8. Set globalRec.[[VarNames]] to a new empty List.\n  globalRec.$VarNames = [];\n\n  // 9. Set env's EnvironmentRecord to globalRec.\n  env.environmentRecord = globalRec;\n\n  // 10. Set the outer lexical environment reference of env to null.\n  env.parent = null;\n\n  // 11. Return env.\n  return env;\n}\n\n// ECMA262 8.1.2.3\nexport function NewObjectEnvironment(\n  realm: Realm,\n  O: ObjectValue | AbstractObjectValue,\n  E: LexicalEnvironment\n): LexicalEnvironment {\n  // 1. Let env be a new Lexical Environment.\n  let env = new LexicalEnvironment(realm);\n\n  // 2. Let envRec be a new object Environment Record containing O as the binding object.\n  let envRec = new ObjectEnvironmentRecord(realm, O);\n\n  // 3. Set env's EnvironmentRecord to envRec.\n  env.environmentRecord = envRec;\n\n  // 4. Set the outer lexical environment reference of env to E.\n  env.parent = E;\n\n  // 5. Return env.\n  return env;\n}\n\n// ECMA262 8.1.2.4\nexport function NewFunctionEnvironment(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  newTarget?: ObjectValue\n): LexicalEnvironment {\n  // 1. Assert: F is an ECMAScript function.\n  invariant(F instanceof ECMAScriptFunctionValue, \"expected a function\");\n\n  // 2. Assert: Type(newTarget) is Undefined or Object.\n  invariant(\n    newTarget === undefined || newTarget instanceof ObjectValue,\n    \"expected undefined or object value for new target\"\n  );\n\n  // 3. Let env be a new Lexical Environment.\n  let env = new LexicalEnvironment(realm);\n\n  // 4. Let envRec be a new function Environment Record containing no bindings.\n  let envRec = new FunctionEnvironmentRecord(realm);\n\n  // 5. Set envRec.[[FunctionObject]] to F.\n  envRec.$FunctionObject = F;\n\n  // 6. If F's [[ThisMode]] internal slot is lexical, set envRec.[[ThisBindingStatus]] to \"lexical\".\n  if (F.$ThisMode === \"lexical\") {\n    envRec.$ThisBindingStatus = \"lexical\";\n  } else {\n    // 7. Else, set envRec.[[ThisBindingStatus]] to \"uninitialized\".\n    envRec.$ThisBindingStatus = \"uninitialized\";\n  }\n\n  // 8. Let home be the value of F's [[HomeObject]] internal slot.\n  let home = F.$HomeObject;\n\n  // 9. Set envRec.[[HomeObject]] to home.\n  envRec.$HomeObject = home;\n\n  // 10. Set envRec.[[NewTarget]] to newTarget.\n  envRec.$NewTarget = newTarget;\n\n  // 11. Set env's EnvironmentRecord to envRec.\n  env.environmentRecord = envRec;\n\n  // 12. Set the outer lexical environment reference of env to the value of F's [[Environment]] internal slot.\n  env.parent = F.$Environment;\n\n  // 13. Return env.\n  return env;\n}\n\n// ECMA262 8.3.1\nexport function GetActiveScriptOrModule(realm: Realm) {\n  // The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the active function object.\n  // GetActiveScriptOrModule performs the following steps:\n  //\n  // If the execution context stack is empty, return null.\n  if (realm.contextStack.length === 0) return null;\n  // Let ec be the topmost execution context on the execution context stack whose Function component's [[ScriptOrModule]] component is not null.\n  // If such an execution context exists, return ec's Function component's [[ScriptOrModule]] slot's value.\n  let ec;\n  for (let i = realm.contextStack.length - 1; i >= 0; i--) {\n    ec = realm.contextStack[i];\n    let F = ec.function;\n    if (F == null) continue;\n    if (F.$ScriptOrModule instanceof Object) {\n      return F.$ScriptOrModule;\n    }\n  }\n  // Otherwise, let ec be the running execution context.\n  ec = realm.getRunningContext();\n  // Assert: ec's ScriptOrModule component is not null.\n  invariant(ec.ScriptOrModule !== null);\n  // Return ec's ScriptOrModule component.\n  return ec.ScriptOrModule;\n}\n\n// ECMA262 8.3.3\nexport function GetThisEnvironment(realm: Realm): EnvironmentRecord {\n  // 1. Let lex be the running execution context's LexicalEnvironment.\n  let lex = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Repeat\n  while (true) {\n    // a. Let envRec be lex's EnvironmentRecord.\n    let envRec = lex.environmentRecord;\n\n    // b. Let exists be envRec.HasThisBinding().\n    let exists = envRec.HasThisBinding();\n\n    // c. If exists is true, return envRec.\n    if (exists) return envRec;\n\n    // d. Let outer be the value of lex's outer environment reference.\n    let outer = lex.parent;\n    invariant(outer);\n\n    // e. Let lex be outer.\n    lex = outer;\n  }\n\n  invariant(false);\n}\n\n// ECMA262 8.3.4\nexport function ResolveThisBinding(realm: Realm): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n  // 1. Let envRec be GetThisEnvironment( ).\n  let envRec = GetThisEnvironment(realm);\n\n  // 2. Return ? envRec.GetThisBinding().\n  return envRec.GetThisBinding();\n}\n\nexport function BindingInitialization(\n  realm: Realm,\n  node: BabelNodeLVal | BabelNodeVariableDeclaration,\n  value: Value,\n  strictCode: boolean,\n  environment: void | LexicalEnvironment\n) {\n  if (node.type === \"ArrayPattern\") {\n    // ECMA262 13.3.3.5\n    // 1. Let iterator be ? GetIterator(value).\n    let iterator = GetIterator(realm, value);\n\n    // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.\n    let iteratorRecord = {\n      $Iterator: iterator,\n      $Done: false,\n    };\n\n    let result;\n\n    // 3. Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment as arguments.\n    try {\n      result = IteratorBindingInitialization(realm, node.elements, iteratorRecord, strictCode, environment);\n    } catch (error) {\n      // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n      if (iteratorRecord.$Done === false && error instanceof AbruptCompletion) {\n        throw IteratorClose(realm, iterator, error);\n      }\n      throw error;\n    }\n\n    // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n    if (iteratorRecord.$Done === false) {\n      let completion = IteratorClose(realm, iterator, new NormalCompletion(realm.intrinsics.undefined));\n      if (completion instanceof AbruptCompletion) {\n        throw completion;\n      }\n    }\n\n    // 5. Return result.\n    return result;\n  } else if (node.type === \"ObjectPattern\") {\n    // ECMA262 13.3.3.5\n    // BindingPattern : ObjectBindingPattern\n\n    // 1. Perform ? RequireObjectCoercible(value).\n    RequireObjectCoercible(realm, value);\n\n    // 2. Return the result of performing BindingInitialization for ObjectBindingPattern using value and environment as arguments.\n    for (let property of node.properties) {\n      let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n\n      // 1. Let P be the result of evaluating PropertyName.\n      let P = EvalPropertyName(property, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(P).\n\n      // 3. Return the result of performing KeyedBindingInitialization for BindingElement using value, environment, and P as arguments.\n      KeyedBindingInitialization(realm, property.value, value, strictCode, environment, P);\n    }\n  } else if (node.type === \"Identifier\") {\n    // ECMA262 12.1.5\n    // 1. Let name be StringValue of Identifier.\n    let name = ((node: any): BabelNodeIdentifier).name;\n\n    // 2. Return ? InitializeBoundName(name, value, environment).\n    return InitializeBoundName(realm, name, value, environment);\n  } else {\n    invariant(node.type === \"VariableDeclaration\");\n    // ECMA262 13.7.5.9\n    for (let decl of ((node: any): BabelNodeVariableDeclaration).declarations) {\n      BindingInitialization(realm, decl.id, value, strictCode, environment);\n    }\n  }\n}\n\n// ECMA262 13.3.3.6\n// ECMA262 14.1.19\nexport function IteratorBindingInitialization(\n  realm: Realm,\n  formals: $ReadOnlyArray<BabelNodeLVal | null>,\n  iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n  strictCode: boolean,\n  environment: void | LexicalEnvironment\n) {\n  let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n\n  // Check if the last formal is a rest element. If so then we want to save the\n  // element and handle it separately after we iterate through the other\n  // formals. This also enforces that a rest element may only ever be in the\n  // last position.\n  let restEl;\n  if (formals.length > 0) {\n    let lastFormal = formals[formals.length - 1];\n    if (lastFormal !== null && lastFormal.type === \"RestElement\") {\n      restEl = lastFormal;\n      formals = formals.slice(0, -1);\n    }\n  }\n\n  for (let param of formals) {\n    if (param === null) {\n      // Elision handling in IteratorDestructuringAssignmentEvaluation\n\n      // 1. If iteratorRecord.[[Done]] is false, then\n      if (iteratorRecord.$Done === false) {\n        // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n        let next;\n        try {\n          next = IteratorStep(realm, iteratorRecord.$Iterator);\n        } catch (e) {\n          // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // c. ReturnIfAbrupt(next).\n          throw e;\n        }\n        // d. If next is false, set iteratorRecord.[[Done]] to true.\n        if (next === false) {\n          iteratorRecord.$Done = true;\n        }\n      }\n      // 2. Return NormalCompletion(empty).\n      continue;\n    }\n\n    let Initializer;\n    if (param.type === \"AssignmentPattern\") {\n      Initializer = param.right;\n      param = param.left;\n    }\n\n    if (param.type === \"Identifier\") {\n      // SingleNameBinding : BindingIdentifier Initializer\n\n      // 1. Let bindingId be StringValue of BindingIdentifier.\n      let bindingId = param.name;\n\n      // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n      let lhs = ResolveBinding(realm, param.name, strictCode, environment);\n\n      // Initialized later in the algorithm.\n      let v;\n\n      // 3. If iteratorRecord.[[Done]] is false, then\n      if (iteratorRecord.$Done === false) {\n        // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n        let next: ObjectValue | false;\n        try {\n          next = IteratorStep(realm, iteratorRecord.$Iterator);\n        } catch (e) {\n          // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // c. ReturnIfAbrupt(next).\n          throw e;\n        }\n\n        // d. If next is false, set iteratorRecord.[[Done]] to true.\n        if (next === false) {\n          iteratorRecord.$Done = true;\n          // Normally this assignment would be done in step 4, but we do it\n          // here so that Flow knows `v` will always be initialized by step 5.\n          v = realm.intrinsics.undefined;\n        } else {\n          // e. Else,\n          // i. Let v be IteratorValue(next).\n          try {\n            v = IteratorValue(realm, next);\n          } catch (e) {\n            // ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // iii. ReturnIfAbrupt(v).\n            throw e;\n          }\n        }\n      } else {\n        // 4. If iteratorRecord.[[Done]] is true, let v be undefined.\n        v = realm.intrinsics.undefined;\n      }\n\n      // 5. If Initializer is present and v is undefined, then\n      if (Initializer && v instanceof UndefinedValue) {\n        // a. Let defaultValue be the result of evaluating Initializer.\n        let defaultValue = env.evaluate(Initializer, strictCode);\n\n        // b. Let v be ? GetValue(defaultValue).\n        v = GetValue(realm, defaultValue);\n\n        // c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n        if (IsAnonymousFunctionDefinition(realm, Initializer) && v instanceof ObjectValue) {\n          // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n          let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n          // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).\n          if (hasNameProperty === false) {\n            SetFunctionName(realm, v, bindingId);\n          }\n        }\n      }\n\n      // 6. If environment is undefined, return ? PutValue(lhs, v).\n      if (!environment) {\n        PutValue(realm, lhs, v);\n        continue;\n      }\n\n      // 7. Return InitializeReferencedBinding(lhs, v).\n      InitializeReferencedBinding(realm, lhs, v);\n      continue;\n    } else {\n      invariant(param.type === \"ObjectPattern\" || param.type === \"ArrayPattern\");\n      // BindingElement : BindingPatternInitializer\n\n      // Initialized later in the algorithm.\n      let v;\n\n      // 1. If iteratorRecord.[[Done]] is false, then\n      if (iteratorRecord.$Done === false) {\n        // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n        let next;\n        try {\n          next = IteratorStep(realm, iteratorRecord.$Iterator);\n        } catch (e) {\n          // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // c. ReturnIfAbrupt(next).\n          throw e;\n        }\n\n        // d. If next is false, set iteratorRecord.[[Done]] to true.\n        if (next === false) {\n          iteratorRecord.$Done = true;\n          // Normally this assignment would be done in step 2, but we do it\n          // here so that Flow knows `v` will always be initialized by step 3.\n          v = realm.intrinsics.undefined;\n        } else {\n          // e. Else,\n          // i. Let v be IteratorValue(next).\n          try {\n            v = IteratorValue(realm, next);\n          } catch (e) {\n            // ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // iii. ReturnIfAbrupt(v).\n            throw e;\n          }\n        }\n      } else {\n        // 2. If iteratorRecord.[[Done]] is true, let v be undefined.\n        v = realm.intrinsics.undefined;\n      }\n\n      // 3. If Initializer is present and v is undefined, then\n      if (Initializer && v instanceof UndefinedValue) {\n        // a. Let defaultValue be the result of evaluating Initializer.\n        let defaultValue = env.evaluate(Initializer, strictCode);\n\n        // b. Let v be ? GetValue(defaultValue).\n        v = GetValue(realm, defaultValue);\n      }\n\n      // 4. Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.\n      BindingInitialization(realm, param, v, strictCode, environment);\n      continue;\n    }\n  }\n\n  // Handle the rest element if we have one.\n  if (restEl && restEl.argument.type === \"Identifier\") {\n    // BindingRestElement : ...BindingIdentifier\n\n    // 1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).\n    let lhs = ResolveBinding(realm, restEl.argument.name, strictCode, environment);\n\n    // 2. Let A be ArrayCreate(0).\n    let A = ArrayCreate(realm, 0);\n\n    // 3. Let n be 0.\n    let n = 0;\n\n    // 4. Repeat,\n    while (true) {\n      // Initialized later in the algorithm.\n      let next: ObjectValue | false;\n\n      // a. If iteratorRecord.[[Done]] is false, then\n      if (iteratorRecord.$Done === false) {\n        // i. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n        try {\n          next = IteratorStep(realm, iteratorRecord.$Iterator);\n        } catch (e) {\n          // ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // iii. ReturnIfAbrupt(next).\n          throw e;\n        }\n        // iv. If next is false, set iteratorRecord.[[Done]] to true.\n        if (next === false) {\n          iteratorRecord.$Done = true;\n        }\n      }\n\n      // b. If iteratorRecord.[[Done]] is true, then\n      if (iteratorRecord.$Done === true) {\n        // i. If environment is undefined, return ? PutValue(lhs, A).\n        if (!environment) {\n          PutValue(realm, lhs, A);\n          break;\n        }\n\n        // ii. Return InitializeReferencedBinding(lhs, A).\n        InitializeReferencedBinding(realm, lhs, A);\n        break;\n      }\n\n      // Given the nature of the algorithm this should always be true, however\n      // it is difficult to arrange the code in such a way where Flow's control\n      // flow analysis will pick that up, so we add an invariant here.\n      invariant(next instanceof ObjectValue);\n\n      // c. Let nextValue be IteratorValue(next).\n      let nextValue;\n      try {\n        nextValue = IteratorValue(realm, next);\n      } catch (e) {\n        // d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (e instanceof AbruptCompletion) {\n          iteratorRecord.$Done = true;\n        }\n        // e. ReturnIfAbrupt(nextValue).\n        throw e;\n      }\n\n      // f. Let status be CreateDataProperty(A, ! ToString(n), nextValue).\n      let status = CreateDataProperty(realm, A, n.toString(), nextValue);\n\n      // g. Assert: status is true.\n      invariant(status, \"expected to create data property\");\n\n      // h. Increment n by 1.\n      n += 1;\n    }\n  } else if (restEl) {\n    invariant(restEl.argument.type === \"ArrayPattern\" || restEl.argument.type === \"ObjectPattern\");\n    // 1. Let A be ArrayCreate(0).\n    let A = ArrayCreate(realm, 0);\n\n    // 2. Let n be 0.\n    let n = 0;\n\n    // 3. Repeat,\n    while (true) {\n      // Initialized later in the algorithm.\n      let next;\n\n      // a. If iteratorRecord.[[Done]] is false, then\n      if (iteratorRecord.$Done === false) {\n        // i. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n        try {\n          next = IteratorStep(realm, iteratorRecord.$Iterator);\n        } catch (e) {\n          // ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // iii. ReturnIfAbrupt(next).\n          throw e;\n        }\n        // iv. If next is false, set iteratorRecord.[[Done]] to true.\n        if (next === false) {\n          iteratorRecord.$Done = true;\n        }\n      }\n\n      // b. If iteratorRecord.[[Done]] is true, then\n      if (iteratorRecord.$Done === true) {\n        // i. Return the result of performing BindingInitialization of BindingPattern with A and environment as the arguments.\n        BindingInitialization(realm, restEl.argument, A, strictCode, environment);\n        break;\n      }\n\n      // Given the nature of the algorithm this should always be true, however\n      // it is difficult to arrange the code in such a way where Flow's control\n      // flow analysis will pick that up, so we add an invariant here.\n      invariant(next instanceof ObjectValue);\n\n      // c. Let nextValue be IteratorValue(next).\n      let nextValue;\n      try {\n        nextValue = IteratorValue(realm, next);\n      } catch (e) {\n        // d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (e instanceof AbruptCompletion) {\n          iteratorRecord.$Done = true;\n        }\n        // e. ReturnIfAbrupt(nextValue).\n        throw e;\n      }\n\n      // f. Let status be CreateDataProperty(A, ! ToString(n), nextValue).\n      let status = CreateDataProperty(realm, A, n.toString(), nextValue);\n\n      // g. Assert: status is true.\n      invariant(status, \"expected to create data property\");\n\n      // h. Increment n by 1.\n      n += 1;\n    }\n  }\n}\n\n// ECMA262 12.1.5.1\nexport function InitializeBoundName(realm: Realm, name: string, value: Value, environment: void | LexicalEnvironment) {\n  // 1. Assert: Type(name) is String.\n  invariant(typeof name === \"string\", \"expected name to be a string\");\n\n  // 2. If environment is not undefined, then\n  if (environment) {\n    // a. Let env be the EnvironmentRecord component of environment.\n    let env = environment.environmentRecord;\n\n    // b. Perform env.InitializeBinding(name, value).\n    env.InitializeBinding(name, value);\n\n    // c. Return NormalCompletion(undefined).\n    return realm.intrinsics.undefined;\n  } else {\n    // 3. Else,\n    // a. Let lhs be ResolveBinding(name).\n    // Note that the undefined environment implies non-strict.\n    let lhs = ResolveBinding(realm, name, false);\n\n    // b. Return ? PutValue(lhs, value).\n    return PutValue(realm, lhs, value);\n  }\n}\n\n// ECMA262 12.3.1.3 and 13.7.5.6\nexport function IsDestructuring(ast: BabelNode) {\n  switch (ast.type) {\n    case \"VariableDeclaration\":\n      for (let decl of ((ast: any): BabelNodeVariableDeclaration).declarations) {\n        switch (decl.type) {\n          case \"VariableDeclarator\":\n            switch (decl.id.type) {\n              case \"ArrayPattern\":\n              case \"AssignmentPattern\":\n              case \"ObjectPattern\":\n                return true;\n              default:\n                break;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      return false;\n    case \"ArrayLiteral\":\n    case \"ObjectLiteral\":\n      return true;\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// ECMA262 13.3.3.7\nexport function KeyedBindingInitialization(\n  realm: Realm,\n  node: BabelNodeIdentifier | BabelNodePattern,\n  value: Value,\n  strictCode: boolean,\n  environment: ?LexicalEnvironment,\n  propertyName: PropertyKeyValue\n) {\n  let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n\n  let Initializer;\n  if (node.type === \"AssignmentPattern\") {\n    Initializer = node.right;\n    node = node.left;\n  }\n\n  if (node.type === \"Identifier\") {\n    // SingleNameBinding : BindingIdentifier Initializer\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    let bindingId = node.name;\n\n    // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n    let lhs = ResolveBinding(realm, bindingId, strictCode, environment);\n\n    // 3. Let v be ? GetV(value, propertyName).\n    let v = GetV(realm, value, propertyName);\n\n    // 4. If Initializer is present and v is undefined, then\n    if (Initializer && v instanceof UndefinedValue) {\n      // a. Let defaultValue be the result of evaluating Initializer.\n      let defaultValue = env.evaluate(Initializer, strictCode);\n\n      // b. Let v be ? GetValue(defaultValue).\n      v = GetValue(realm, defaultValue);\n\n      // c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n      if (IsAnonymousFunctionDefinition(realm, Initializer) && v instanceof ObjectValue) {\n        // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n        // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).\n        if (hasNameProperty === false) {\n          SetFunctionName(realm, v, bindingId);\n        }\n      }\n    }\n\n    // 5. If environment is undefined, return ? PutValue(lhs, v).\n    if (!environment) return PutValue(realm, lhs, v);\n\n    // 6. Return InitializeReferencedBinding(lhs, v).\n    return InitializeReferencedBinding(realm, lhs, v);\n  } else if (node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\") {\n    // BindingElement : BindingPattern Initializer\n\n    // 1. Let v be ? GetV(value, propertyName).\n    let v = GetV(realm, value, propertyName);\n\n    // 2. If Initializer is present and v is undefined, then\n    if (Initializer && v instanceof UndefinedValue) {\n      // a. Let defaultValue be the result of evaluating Initializer.\n      let defaultValue = env.evaluate(Initializer, strictCode);\n\n      // b. Let v be ? GetValue(defaultValue).\n      v = GetValue(realm, defaultValue);\n    }\n\n    // 3. Return the result of performing BindingInitialization for BindingPattern passing v and environment as arguments.\n    return BindingInitialization(realm, node, v, strictCode, environment);\n  }\n}\n"]}