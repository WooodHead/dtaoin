{"version":3,"sources":["../../src/methods/has.js"],"names":["HasName","HasProperty","HasOwnProperty","OrdinaryHasProperty","HasCompatibleType","HasSomeCompatibleType","realm","ast","type","id","Error","O","P","$HasProperty","desc","$GetOwnProperty","undefined","value","hasOwn","parent","$GetPrototypeOf","valueType","getType","reportIntrospectionError","isTypeCompatibleWith","manyTypes","some","bind"],"mappings":"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","file":"has.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { ThrowIfMightHaveBeenDeleted, IsPropertyKey } from \"./index.js\";\nimport { Value, AbstractValue, ObjectValue, NullValue, AbstractObjectValue } from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeExpression } from \"babel-types\";\n\n// 12.2.1.2 Static Semantics: HasName\n// 14.1.9 Static Semantics: HasName\n// 14.2.7 Static Semantics: HasName\n// 14.5.6 Static Semantics: HasName\n// 14.2.7 Static Semantics: HasName\n\nexport function HasName(realm: Realm, ast: BabelNodeExpression): boolean {\n  // 12.2.1.2 Static Semantics: HasName\n  // CoverParenthesizedExpressionAndArrowParameterList\n\n  // 14.2.7 Static Semantics: HasName\n  if (ast.type === \"ArrowFunctionExpression\") return false;\n\n  // 14.1.9 Static Semantics: HasName\n  if (ast.type === \"FunctionExpression\") {\n    // FunctionExpression: function (FormalParameters) {FunctionBody}\n    if (ast.id === null)\n      // 1. Return false.\n      return false;\n    // FunctionExpression: functionBindingIdentifier (FormalParameters) {FunctionBody}\n    if (ast.id !== null)\n      // 2. Return true\n      return true;\n  }\n\n  // 14.5.6 Static Semantics: HasName\n  if (ast.type === \"ClassExpression\") {\n    // ClassExpression : class ClassTail\n    if (ast.id === null)\n      //1. Return false.\n      return false;\n    // ClassExpression : class BindingIdentifier ClassTail\n    if (ast.id !== null)\n      //1. return true;\n      return true;\n  }\n  // 14.4.7 Static Semantics: HasName\n  // GeneratorExpression\n  throw Error(\"Unexpected AST node type  : \" + ast.type);\n}\n\n// ECMA262 7.3.10\nexport function HasProperty(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue): boolean {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue || O instanceof AbstractObjectValue, \"expected object\");\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 3. Return ? O.[[HasProperty]](P).\n  return O.$HasProperty(P);\n}\n\n// ECMA262 7.3.11\nexport function HasOwnProperty(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue): boolean {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue || O instanceof AbstractObjectValue, \"not an object\");\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"not a valid property key\");\n\n  // 3. Let desc be ? O.[[GetOwnProperty]](P).\n  let desc = O.$GetOwnProperty(P);\n\n  // 4. If desc is undefined, return false.\n  if (desc === undefined) return false;\n  ThrowIfMightHaveBeenDeleted(desc.value);\n\n  // 5. Return true.\n  return true;\n}\n\n// ECMA262 9.1.7.1\nexport function OrdinaryHasProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(typeof P === \"string\" || IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let hasOwn be ? O.[[GetOwnProperty]](P).\n  let hasOwn = O.$GetOwnProperty(P);\n\n  // 3. If hasOwn is not undefined, return true.\n  if (hasOwn !== undefined) {\n    ThrowIfMightHaveBeenDeleted(hasOwn.value);\n    return true;\n  }\n\n  // 4. Let parent be ? O.[[GetPrototypeOf]]().\n  let parent = O.$GetPrototypeOf();\n\n  // 5. If parent is not null, then\n  if (!(parent instanceof NullValue)) {\n    invariant(parent instanceof ObjectValue);\n\n    // a. Return ? parent.[[HasProperty]](P).\n    return parent.$HasProperty(P);\n  }\n\n  // 6. Return false.\n  return false;\n}\n\n// Checks if the given value is equal to or a subtype of the given type.\n// If the value is an abstract value without precise type information,\n// an introspection error is thrown.\nexport function HasCompatibleType(value: Value, type: typeof Value): boolean {\n  let valueType = value.getType();\n  if (valueType === Value) {\n    invariant(value instanceof AbstractValue);\n    AbstractValue.reportIntrospectionError(value);\n    throw new FatalError();\n  }\n  return Value.isTypeCompatibleWith(valueType, type);\n}\n\nexport function HasSomeCompatibleType(value: Value, ...manyTypes: Array<typeof Value>): boolean {\n  let valueType = value.getType();\n  if (valueType === Value) {\n    invariant(value instanceof AbstractValue);\n    AbstractValue.reportIntrospectionError(value);\n    throw new FatalError();\n  }\n  return manyTypes.some(Value.isTypeCompatibleWith.bind(null, valueType));\n}\n"]}