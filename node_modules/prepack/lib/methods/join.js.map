{"version":3,"sources":["../../src/methods/join.js"],"names":["stopEffectCaptureAndJoinCompletions","unbundleNormalCompletion","composeNormalCompletions","composePossiblyNormalCompletions","updatePossiblyNormalCompletionWithValue","joinPossiblyNormalCompletionWithAbruptCompletion","joinPossiblyNormalCompletionWithValue","joinValueWithPossiblyNormalCompletion","joinAndRemoveNestedReturnCompletions","joinEffectsAndRemoveNestedReturnCompletions","unbundleReturnCompletion","joinEffects","joinMaps","joinBindings","joinValues","joinValuesAsConditional","joinPropertyBindings","joinDescriptors","joinBooleans","t","c1","c2","realm","e","getCapturedEffects","undefined","stopEffectCaptureAndUndoEffects","joined_effects","applyEffects","result","completionOrValue","completion","value","leftCompletion","rightCompletion","resultValue","pnc","c","empty_effects","consequent","alternate","joinCondition","consequentEffects","new_alternate","alternateEffects","new_consequent","v","ac","alternate_effects","consequent_effects","joinResults","nested_effects","e1","e2","intrinsics","currentLocation","result1","gen1","bindings1","properties1","createdObj1","result2","gen2","bindings2","properties2","createdObj2","bindings","properties","createdObjects","Set","forEach","add","o","generator","joinGenerators","getAbstractValue","v1","v2","reportIntrospectionError","target","empty","expressionLocation","val","location","generator1","generator2","body","push","args","buildNode","context","cond","block1","serializeBody","block2","ifStatement","unaryExpression","dependencies","statements","serializeGenerator","blockStatement","m1","m2","join","m3","Map","val1","key","map1","val2","get","val3","set","map2","has","b","throwIfNotConcrete","condition","types","values","createAbstract","conditionalExpression","mightBeEmpty","mightHaveBeenDeleted","d1","d2","object","descriptor","clone_with_abstract_value","d","dc","d3","writable","enumerable","configurable","hasOwnProperty"],"mappings":"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","file":"join.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeBlockStatement } from \"babel-types\";\nimport type { Binding } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport type { Bindings, Effects, EvaluationResult, PropertyBindings, CreatedObjects, Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\n\nimport {\n  AbruptCompletion,\n  BreakCompletion,\n  Completion,\n  ContinueCompletion,\n  PossiblyNormalCompletion,\n  JoinedAbruptCompletions,\n  NormalCompletion,\n  ReturnCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { cloneDescriptor, IsDataDescriptor, StrictEqualityComparison } from \"../methods/index.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport type { SerializationContext } from \"../utils/generator.js\";\nimport { AbstractValue, Value } from \"../values/index.js\";\n\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\nexport function stopEffectCaptureAndJoinCompletions(\n  c1: PossiblyNormalCompletion,\n  c2: AbruptCompletion,\n  realm: Realm\n): Completion {\n  let e = realm.getCapturedEffects();\n  invariant(e !== undefined);\n  realm.stopEffectCaptureAndUndoEffects();\n  e[0] = c2;\n  let joined_effects = joinPossiblyNormalCompletionWithAbruptCompletion(realm, c1, c2, e);\n  realm.applyEffects(joined_effects);\n  let result = joined_effects[0];\n  invariant(result instanceof Completion);\n  return result;\n}\n\nexport function unbundleNormalCompletion(\n  completionOrValue: Completion | Value | Reference\n): [void | NormalCompletion, Value | Reference] {\n  let completion, value;\n  if (completionOrValue instanceof NormalCompletion) {\n    completion = completionOrValue;\n    value = completionOrValue.value;\n  } else {\n    invariant(completionOrValue instanceof Value || completionOrValue instanceof Reference);\n    value = completionOrValue;\n  }\n  return [completion, value];\n}\n\nexport function composeNormalCompletions(\n  leftCompletion: void | NormalCompletion,\n  rightCompletion: void | NormalCompletion,\n  resultValue: Value,\n  realm: Realm\n): PossiblyNormalCompletion | Value {\n  if (leftCompletion instanceof PossiblyNormalCompletion) {\n    if (rightCompletion instanceof PossiblyNormalCompletion) {\n      updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);\n      return composePossiblyNormalCompletions(realm, leftCompletion, rightCompletion);\n    }\n    updatePossiblyNormalCompletionWithValue(realm, leftCompletion, resultValue);\n    return leftCompletion;\n  } else if (rightCompletion instanceof PossiblyNormalCompletion) {\n    updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);\n    return rightCompletion;\n  } else {\n    invariant(leftCompletion === undefined && rightCompletion === undefined);\n    return resultValue;\n  }\n}\n\nexport function composePossiblyNormalCompletions(\n  realm: Realm,\n  pnc: PossiblyNormalCompletion,\n  c: PossiblyNormalCompletion\n): PossiblyNormalCompletion {\n  let empty_effects = construct_empty_effects(realm);\n  if (pnc.consequent instanceof AbruptCompletion) {\n    if (pnc.alternate instanceof Value) {\n      return new PossiblyNormalCompletion(\n        c.value,\n        pnc.joinCondition,\n        pnc.consequent,\n        pnc.consequentEffects,\n        c,\n        empty_effects\n      );\n    }\n    invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n    let new_alternate = composePossiblyNormalCompletions(realm, pnc.alternate, c);\n    return new PossiblyNormalCompletion(\n      new_alternate.value,\n      pnc.joinCondition,\n      pnc.consequent,\n      pnc.consequentEffects,\n      new_alternate,\n      empty_effects\n    );\n  } else {\n    invariant(pnc.alternate instanceof AbruptCompletion);\n    if (pnc.consequent instanceof Value) {\n      return new PossiblyNormalCompletion(\n        c.value,\n        pnc.joinCondition,\n        c,\n        empty_effects,\n        pnc.alternate,\n        pnc.alternateEffects\n      );\n    }\n    invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n    let new_consequent = composePossiblyNormalCompletions(realm, pnc.consequent, c);\n    return new PossiblyNormalCompletion(\n      new_consequent.value,\n      pnc.joinCondition,\n      new_consequent,\n      empty_effects,\n      pnc.alternate,\n      pnc.alternateEffects\n    );\n  }\n}\n\nexport function updatePossiblyNormalCompletionWithValue(realm: Realm, pnc: PossiblyNormalCompletion, v: Value) {\n  pnc.value = v;\n  if (pnc.consequent instanceof AbruptCompletion) {\n    if (pnc.alternate instanceof Value) {\n      pnc.alternate = v;\n    } else {\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      updatePossiblyNormalCompletionWithValue(realm, pnc.alternate, v);\n    }\n  } else {\n    if (pnc.consequent instanceof Value) {\n      pnc.consequent = v;\n    } else {\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      updatePossiblyNormalCompletionWithValue(realm, pnc.consequent, v);\n    }\n  }\n}\n\nexport function joinPossiblyNormalCompletionWithAbruptCompletion(\n  realm: Realm,\n  pnc: PossiblyNormalCompletion,\n  ac: AbruptCompletion,\n  e: Effects\n): Effects {\n  if (pnc.consequent instanceof AbruptCompletion) {\n    if (pnc.alternate instanceof Value) return joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, e);\n    invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n    let alternate_effects = joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.alternate, ac, e);\n    invariant(pnc.consequent instanceof AbruptCompletion);\n    return joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, alternate_effects);\n  } else {\n    invariant(pnc.alternate instanceof AbruptCompletion);\n    if (pnc.consequent instanceof Value) return joinEffects(realm, pnc.joinCondition, e, pnc.alternateEffects);\n    invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n    let consequent_effects = joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.consequent, ac, e);\n    invariant(pnc.alternate instanceof AbruptCompletion);\n    return joinEffects(realm, pnc.joinCondition, consequent_effects, pnc.alternateEffects);\n  }\n}\n\nexport function joinPossiblyNormalCompletionWithValue(\n  realm: Realm,\n  joinCondition: AbstractValue,\n  pnc: PossiblyNormalCompletion,\n  v: Value\n) {\n  if (pnc.consequent instanceof AbruptCompletion) {\n    if (pnc.alternate instanceof Value) {\n      pnc.alternate = joinValuesAsConditional(realm, joinCondition, pnc.alternate, v);\n    } else {\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc.alternate, v);\n    }\n  } else {\n    if (pnc.consequent instanceof Value) {\n      pnc.consequent = joinValuesAsConditional(realm, joinCondition, pnc.consequent, v);\n    } else {\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc.consequent, v);\n    }\n  }\n}\n\nexport function joinValueWithPossiblyNormalCompletion(\n  realm: Realm,\n  joinCondition: AbstractValue,\n  pnc: PossiblyNormalCompletion,\n  v: Value\n) {\n  if (pnc.consequent instanceof AbruptCompletion) {\n    if (pnc.alternate instanceof Value) {\n      pnc.alternate = joinValuesAsConditional(realm, joinCondition, v, pnc.alternate);\n    } else {\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc.alternate, v);\n    }\n  } else {\n    if (pnc.consequent instanceof Value) {\n      pnc.consequent = joinValuesAsConditional(realm, joinCondition, v, pnc.consequent);\n    } else {\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc.consequent, v);\n    }\n  }\n}\n\nexport function joinAndRemoveNestedReturnCompletions(\n  realm: Realm,\n  c: AbruptCompletion\n): AbruptCompletion | PossiblyNormalCompletion | Value {\n  if (c instanceof ReturnCompletion) {\n    return c.value;\n  }\n  if (c instanceof JoinedAbruptCompletions) {\n    let c1 = joinAndRemoveNestedReturnCompletions(realm, c.consequent);\n    let c2 = joinAndRemoveNestedReturnCompletions(realm, c.alternate);\n    return joinResults(realm, c.joinCondition, c1, c2, c.consequentEffects, c.alternateEffects);\n  }\n  return c;\n}\n\nexport function joinEffectsAndRemoveNestedReturnCompletions(\n  realm: Realm,\n  c: Completion | Value,\n  e: Effects,\n  nested_effects?: Effects\n): Effects {\n  if (c instanceof Value) return e;\n  if (c instanceof AbruptCompletion) {\n    invariant(nested_effects !== undefined);\n    return nested_effects;\n  }\n  if (c instanceof PossiblyNormalCompletion) {\n    let e1 = joinEffectsAndRemoveNestedReturnCompletions(realm, c.consequent, e, c.consequentEffects);\n    let e2 = joinEffectsAndRemoveNestedReturnCompletions(realm, c.alternate, e, c.alternateEffects);\n    if (e1[0] instanceof AbruptCompletion) {\n      if (!(e2[0] instanceof ReturnCompletion)) {\n        invariant(e2[0] instanceof Value); // otherwise c cannot possibly be normal\n        e2[0] = new ReturnCompletion(realm.intrinsics.undefined, realm.currentLocation);\n      }\n      return joinEffects(realm, c.joinCondition, e1, e2);\n    } else if (e2[0] instanceof AbruptCompletion) {\n      invariant(e1[0] instanceof Value); // otherwise c cannot possibly be normal\n      e1[0] = new ReturnCompletion(realm.intrinsics.undefined, realm.currentLocation);\n      return joinEffects(realm, c.joinCondition, e1, e2);\n    }\n  }\n  invariant(false);\n}\n\nexport function unbundleReturnCompletion(\n  realm: Realm,\n  c: JoinedAbruptCompletions\n): [Effects, PossiblyNormalCompletion] {\n  let empty_effects = construct_empty_effects(realm);\n  if (c.consequent instanceof ReturnCompletion) {\n    let v = c.consequent.value;\n    let pnc = new PossiblyNormalCompletion(v, c.joinCondition, v, empty_effects, c.alternate, c.alternateEffects);\n    return [c.consequentEffects, pnc];\n  } else if (c.alternate instanceof ReturnCompletion) {\n    let v = c.alternate.value;\n    let pnc = new PossiblyNormalCompletion(v, c.joinCondition, c.consequent, c.consequentEffects, v, empty_effects);\n    return [c.alternateEffects, pnc];\n  } else {\n    invariant(false, \"unbundleReturnCompletion needs an argument that contains a non nested return completion\");\n  }\n}\n\nexport function joinEffects(realm: Realm, joinCondition: AbstractValue, e1: Effects, e2: Effects): Effects {\n  let [result1, gen1, bindings1, properties1, createdObj1] = e1;\n  let [result2, gen2, bindings2, properties2, createdObj2] = e2;\n\n  let result = joinResults(realm, joinCondition, result1, result2, e1, e2);\n  if (result1 instanceof AbruptCompletion) {\n    if (!(result2 instanceof AbruptCompletion)) {\n      invariant(result instanceof PossiblyNormalCompletion);\n      return [result, gen2, bindings2, properties2, createdObj2];\n    }\n  } else if (result2 instanceof AbruptCompletion) {\n    invariant(result instanceof PossiblyNormalCompletion);\n    return [result, gen1, bindings1, properties1, createdObj1];\n  }\n\n  let bindings = joinBindings(realm, joinCondition, bindings1, bindings2);\n  let properties = joinPropertyBindings(realm, joinCondition, properties1, properties2, createdObj1, createdObj2);\n  let createdObjects = new Set();\n  createdObj1.forEach(o => {\n    createdObjects.add(o);\n  });\n  createdObj2.forEach(o => {\n    createdObjects.add(o);\n  });\n\n  let generator = joinGenerators(realm, joinCondition, gen1, gen2, result1, result2);\n\n  return [result, generator, bindings, properties, createdObjects];\n}\n\nfunction joinResults(\n  realm: Realm,\n  joinCondition: AbstractValue,\n  result1: EvaluationResult,\n  result2: EvaluationResult,\n  e1: Effects,\n  e2: Effects\n): AbruptCompletion | PossiblyNormalCompletion | Value {\n  function getAbstractValue(v1: void | Value, v2: void | Value): AbstractValue {\n    return joinValuesAsConditional(realm, joinCondition, v1, v2);\n  }\n  if (result1 instanceof Reference || result2 instanceof Reference) {\n    AbstractValue.reportIntrospectionError(joinCondition);\n    throw new FatalError();\n  }\n  if (result1 instanceof BreakCompletion && result2 instanceof BreakCompletion && result1.target === result2.target) {\n    return new BreakCompletion(realm.intrinsics.empty, joinCondition.expressionLocation, result1.target);\n  }\n  if (\n    result1 instanceof ContinueCompletion &&\n    result2 instanceof ContinueCompletion &&\n    result1.target === result2.target\n  ) {\n    return new ContinueCompletion(realm.intrinsics.empty, joinCondition.expressionLocation, result1.target);\n  }\n  if (result1 instanceof ReturnCompletion && result2 instanceof ReturnCompletion) {\n    let val = joinValues(realm, result1.value, result2.value, getAbstractValue);\n    return new ReturnCompletion(val, joinCondition.expressionLocation);\n  }\n  if (result1 instanceof ThrowCompletion && result2 instanceof ThrowCompletion) {\n    let val = joinValues(realm, result1.value, result2.value, getAbstractValue);\n    return new ThrowCompletion(val, result1.location);\n  }\n  if (result1 instanceof AbruptCompletion && result2 instanceof AbruptCompletion) {\n    return new JoinedAbruptCompletions(realm, joinCondition, result1, e1, result2, e2);\n  }\n  if (result1 instanceof Value && result2 instanceof Value) {\n    return joinValues(realm, result1, result2, getAbstractValue);\n  }\n  if (result1 instanceof PossiblyNormalCompletion && result2 instanceof PossiblyNormalCompletion) {\n    return composePossiblyNormalCompletions(realm, result1, result2);\n  }\n  if (result1 instanceof AbruptCompletion) {\n    let value = result2;\n    if (result2 instanceof Completion) value = result2.value;\n    invariant(value instanceof Value);\n    return new PossiblyNormalCompletion(value, joinCondition, result1, e1, result2, e2);\n  }\n  if (result2 instanceof AbruptCompletion) {\n    let value = result1;\n    if (result1 instanceof Completion) value = result1.value;\n    invariant(value instanceof Value);\n    return new PossiblyNormalCompletion(value, joinCondition, result1, e1, result2, e2);\n  }\n  if (result1 instanceof PossiblyNormalCompletion) {\n    invariant(result2 instanceof Value);\n    joinPossiblyNormalCompletionWithValue(realm, joinCondition, result1, result2);\n    return result1;\n  }\n  if (result2 instanceof PossiblyNormalCompletion) {\n    invariant(result1 instanceof Value);\n    joinValueWithPossiblyNormalCompletion(realm, joinCondition, result2, result1);\n    return result2;\n  }\n  invariant(false);\n}\n\nfunction joinGenerators(\n  realm: Realm,\n  joinCondition: AbstractValue,\n  generator1: Generator,\n  generator2: Generator,\n  result1: EvaluationResult,\n  result2: EvaluationResult\n): Generator {\n  let result = new Generator(realm);\n  if (!generator1.empty() || !generator2.empty()) {\n    result.body.push({\n      args: [joinCondition],\n      buildNode: function([cond], context) {\n        let block1 = generator1.empty() ? null : serializeBody(generator1, context);\n        let block2 = generator2.empty() ? null : serializeBody(generator2, context);\n        if (block1) return t.ifStatement(cond, block1, block2);\n        invariant(block2);\n        return t.ifStatement(t.unaryExpression(\"!\", cond), block2);\n      },\n      dependencies: [generator1, generator2],\n    });\n  }\n  return result;\n}\n\nfunction serializeBody(generator: Generator, context: SerializationContext): BabelNodeBlockStatement {\n  let statements = context.serializeGenerator(generator);\n  return t.blockStatement(statements);\n}\n\n// Creates a single map that joins together maps m1 and m2 using the given join\n// operator. If an entry is present in one map but not the other, the missing\n// entry is treated as if it were there and its value were undefined.\nexport function joinMaps<K, V>(\n  m1: Map<K, void | V>,\n  m2: Map<K, void | V>,\n  join: (K, void | V, void | V) => V\n): Map<K, void | V> {\n  let m3: Map<K, void | V> = new Map();\n  m1.forEach((val1, key, map1) => {\n    let val2 = m2.get(key);\n    let val3 = join(key, val1, val2);\n    m3.set(key, val3);\n  });\n  m2.forEach((val2, key, map2) => {\n    if (!m1.has(key)) {\n      m3.set(key, join(key, undefined, val2));\n    }\n  });\n  return m3;\n}\n\n// Creates a single map that has an key, value pair for the union of the key\n// sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]\n// where the join is defined to be just m1[key] if m1[key] === m2[key] and\n// and abstract value with expression \"joinCondition ? m1[key] : m2[key]\" if not.\nexport function joinBindings(realm: Realm, joinCondition: AbstractValue, m1: Bindings, m2: Bindings): Bindings {\n  function getAbstractValue(v1: void | Value, v2: void | Value): AbstractValue {\n    return joinValuesAsConditional(realm, joinCondition, v1, v2);\n  }\n  function join(b: Binding, v1: void | Value, v2: void | Value) {\n    if (v1 === undefined) v1 = b.value;\n    if (v2 === undefined) v2 = b.value;\n    return joinValues(realm, v1, v2, getAbstractValue);\n  }\n  return joinMaps(m1, m2, join);\n}\n\n// If v1 is known and defined and v1 === v2 return v1,\n// otherwise return getAbstractValue(v1, v2)\nexport function joinValues(\n  realm: Realm,\n  v1: void | Value,\n  v2: void | Value,\n  getAbstractValue: (void | Value, void | Value) => AbstractValue\n): Value {\n  if (\n    v1 !== undefined &&\n    v2 !== undefined &&\n    !(v1 instanceof AbstractValue) &&\n    !(v2 instanceof AbstractValue) &&\n    StrictEqualityComparison(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())\n  ) {\n    return v1;\n  } else {\n    return getAbstractValue(v1, v2);\n  }\n}\n\nexport function joinValuesAsConditional(\n  realm: Realm,\n  condition: AbstractValue,\n  v1: void | Value,\n  v2: void | Value\n): AbstractValue {\n  let types = TypesDomain.joinValues(v1, v2);\n  let values = ValuesDomain.joinValues(realm, v1, v2);\n  let result = realm.createAbstract(\n    types,\n    values,\n    [condition, v1 || realm.intrinsics.undefined, v2 || realm.intrinsics.undefined],\n    args => t.conditionalExpression(args[0], args[1], args[2]),\n    \"conditional\"\n  );\n  if (v1) result.mightBeEmpty = v1.mightHaveBeenDeleted();\n  if (v2 && !result.mightBeEmpty) result.mightBeEmpty = v2.mightHaveBeenDeleted();\n  return result;\n}\n\nexport function joinPropertyBindings(\n  realm: Realm,\n  joinCondition: AbstractValue,\n  m1: PropertyBindings,\n  m2: PropertyBindings,\n  c1: CreatedObjects,\n  c2: CreatedObjects\n): PropertyBindings {\n  function getAbstractValue(v1: void | Value, v2: void | Value): AbstractValue {\n    return joinValuesAsConditional(realm, joinCondition, v1, v2);\n  }\n  function join(b: PropertyBinding, d1: void | Descriptor, d2: void | Descriptor) {\n    // If the PropertyBinding object has been freshly allocated do not join\n    if (d1 === undefined) {\n      if (c2.has(b.object)) return d2; // no join\n      if (b.descriptor !== undefined && m1.has(b)) {\n        // property was deleted\n        d1 = cloneDescriptor(b.descriptor);\n        invariant(d1 !== undefined);\n        d1.value = realm.intrinsics.empty;\n      } else {\n        // no write to property\n        d1 = b.descriptor; //Get value of property before the split\n      }\n    }\n    if (d2 === undefined) {\n      if (c1.has(b.object)) return d1; // no join\n      if (b.descriptor !== undefined && m2.has(b)) {\n        // property was deleted\n        d2 = cloneDescriptor(b.descriptor);\n        invariant(d2 !== undefined);\n        d2.value = realm.intrinsics.empty;\n      } else {\n        // no write to property\n        d2 = b.descriptor; //Get value of property before the split\n      }\n    }\n    return joinDescriptors(realm, d1, d2, getAbstractValue);\n  }\n  return joinMaps(m1, m2, join);\n}\n\n// Returns a field by field join of two descriptors.\n// Descriptors with get/set are not yet supported.\nexport function joinDescriptors(\n  realm: Realm,\n  d1: void | Descriptor,\n  d2: void | Descriptor,\n  getAbstractValue: (void | Value, void | Value) => AbstractValue\n): void | Descriptor {\n  function clone_with_abstract_value(d: Descriptor) {\n    if (!IsDataDescriptor(realm, d)) throw new FatalError(\"TODO: join computed properties\");\n    let dc = cloneDescriptor(d);\n    invariant(dc !== undefined);\n    dc.value = getAbstractValue(d.value, realm.intrinsics.empty);\n    return dc;\n  }\n  if (d1 === undefined) {\n    if (d2 === undefined) return undefined;\n    // d2 is a new property created in only one branch, join with empty\n    return clone_with_abstract_value(d2);\n  } else if (d2 === undefined) {\n    // d1 is a new property created in only one branch, join with empty\n    return clone_with_abstract_value(d1);\n  } else {\n    let d3: Descriptor = {};\n    let writable = joinBooleans(d1.writable, d2.writable);\n    if (writable !== undefined) d3.writable = writable;\n    let enumerable = joinBooleans(d1.enumerable, d2.enumerable);\n    if (enumerable !== undefined) d3.enumerable = enumerable;\n    let configurable = joinBooleans(d1.configurable, d2.configurable);\n    if (configurable !== undefined) d3.configurable = configurable;\n    if (IsDataDescriptor(realm, d1) || IsDataDescriptor(realm, d2))\n      d3.value = joinValues(realm, d1.value, d2.value, getAbstractValue);\n    if (d1.hasOwnProperty(\"get\") || d2.hasOwnProperty(\"get\"))\n      d3.get = (joinValues(realm, d1.get, d2.get, getAbstractValue): any);\n    if (d1.hasOwnProperty(\"set\") || d2.hasOwnProperty(\"set\"))\n      d3.set = (joinValues(realm, d1.set, d2.set, getAbstractValue): any);\n    return d3;\n  }\n}\n\n// Returns v1 || v2, treating undefined as false,\n// but returns undefined if both v1 and v2 are undefined.\nexport function joinBooleans(v1: void | boolean, v2: void | boolean): void | boolean {\n  if (v1 === undefined) {\n    return v2;\n  } else if (v2 === undefined) {\n    return v1;\n  } else {\n    return v1 || v2;\n  }\n}\n"]}