{"version":3,"sources":["../../src/methods/function.js"],"names":["FindVarScopedDeclarations","FunctionDeclarationInstantiation","SetFunctionName","FunctionInitialize","GeneratorFunctionCreate","AddRestrictedFunctionProperties","$Call","$Construct","FunctionAllocate","BoundFunctionCreate","PerformEval","EvaluateStatements","PartiallyEvaluateStatements","FunctionCreate","EvalDeclarationInstantiation","MakeMethod","DefineMethod","t","ast_node","FindVarScopedDeclarationsFor","ast","level","statements","type","body","astIfStatement","consequent","alternate","astForStatement","init","astForInStatement","left","astForOfStatement","cases","switchCase","concat","astTryStatement","block","finalizer","push","handler","kind","decls","statement","realm","func","argumentsList","calleeContext","getRunningContext","env","lexicalEnvironment","envRec","environmentRecord","code","$ECMAScriptCode","undefined","strict","$Strict","formals","$FormalParameters","parameterNames","Object","create","param","paramBindings","getBindingIdentifiers","name","hasDuplicates","identifiers","length","keys","simpleParameterList","hasParameterExpressions","varNames","node","varDeclarations","lexicalNames","functionNames","functionsToInitialize","reverse","d","fn","indexOf","unshift","argumentsObjectNeeded","$ThisMode","paramName","alreadyDeclared","HasBinding","CreateMutableBinding","InitializeBinding","intrinsics","ao","CreateImmutableBinding","iteratorRecord","$Iterator","$Done","varEnv","varEnvRec","instantiatedVarNames","slice","n","variableEnvironment","initialValue","GetBindingValue","lexEnv","lexEnvRec","lexDeclarations","dn","f","fo","evaluate","SetMutableBinding","empty","F","prefix","getExtensible","description","$Description","emptyString","throwIfNotConcreteString","value","prefixVal","createAbstract","topVal","lnode","rnode","binaryExpression","enumerable","writable","configurable","ParameterList","Body","Scope","isNewObject","len","FormalParameter","Strict","$Environment","$ScriptOrModule","functionPrototype","Generator","thrower","ThrowTypeError","desc","get","set","thisArgument","argsList","InternalCall","tracerIndex","tracer","tracers","nextIndex","detourResult","detourCall","$FunctionKind","createErrorThrowCompletion","TypeError","callerContext","result","t1","beforeCall","popContext","savedCompletion","captureEffects","t2","afterCall","newTarget","InternalConstruct","$ConstructorKind","constructorEnv","mightBeObject","throwIfNotConcreteObject","mightBeUndefined","throwIfNotConcrete","envRecThisBinding","GetThisBinding","functionKind","needsConstruct","$Prototype","setExtensible","$Realm","$BoundCall","target","$BoundTargetFunction","boundThis","$BoundThis","boundArgs","$BoundArguments","args","$BoundConstruct","targetFunction","proto","$GetPrototypeOf","obj","x","evalRealm","strictCaller","direct","script","program","blockStatement","directives","strictEval","ctx","$GlobalEnv","suspend","evalCxt","isStrict","setFunction","setRealm","ScriptOrModule","pushContext","e","directive","resume","blockValue","strictCode","blockEnv","res","evaluateAbstractCompletion","context","getCapturedEffects","stopEffectCaptureAndUndoEffects","joined_effects","applyEffects","statementAsts","partiallyEvaluateCompletionDeref","nast","nio","ioAst","jres","prototype","FunctionPrototype","allocKind","HasLexicalDeclaration","SyntaxError","thisLex","thisEnvRec","parent","declaredFunctionNames","fnDefinable","CanDeclareGlobalFunction","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","s","CreateGlobalFunctionBinding","bindingExists","CreateGlobalVarBinding","homeObject","$HomeObject","prop","propKey","scope","closure","params","$Key","$Closure"],"mappings":"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","file":"function.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { ECMAScriptFunctionValue } from \"../values/index.js\";\nimport {\n  Completion,\n  ReturnCompletion,\n  AbruptCompletion,\n  JoinedAbruptCompletions,\n  NormalCompletion,\n  PossiblyNormalCompletion,\n} from \"../completions.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { ExecutionContext } from \"../realm.js\";\nimport { GlobalEnvironmentRecord, ObjectEnvironmentRecord, Reference } from \"../environment.js\";\nimport {\n  AbstractValue,\n  Value,\n  BoundFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  ECMAScriptSourceFunctionValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  NumberValue,\n} from \"../values/index.js\";\nimport { DefinePropertyOrThrow, NewDeclarativeEnvironment } from \"./index.js\";\nimport { OrdinaryCreateFromConstructor, CreateUnmappedArgumentsObject, CreateMappedArgumentsObject } from \"./create.js\";\nimport { OrdinaryCallEvaluateBody, OrdinaryCallBindThis, PrepareForOrdinaryCall, Call } from \"./call.js\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport { IteratorBindingInitialization } from \"../methods/environment.js\";\nimport {\n  composePossiblyNormalCompletions,\n  joinAndRemoveNestedReturnCompletions,\n  joinPossiblyNormalCompletionWithAbruptCompletion,\n  stopEffectCaptureAndJoinCompletions,\n  updatePossiblyNormalCompletionWithValue,\n  BoundNames,\n  ContainsExpression,\n  GetActiveScriptOrModule,\n  UpdateEmpty,\n} from \"../methods/index.js\";\nimport { CreateListIterator } from \"../methods/iterator.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport invariant from \"../invariant.js\";\nimport parse from \"../utils/parse.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNode,\n  BabelNodeLVal,\n  BabelNodeStatement,\n  BabelNodeBlockStatement,\n  BabelNodeProgram,\n  BabelNodeDoWhileStatement,\n  BabelNodeWhileStatement,\n  BabelNodeLabeledStatement,\n  BabelNodeWithStatement,\n  BabelNodeSwitchStatement,\n  BabelNodeIfStatement,\n  BabelNodeForStatement,\n  BabelNodeForInStatement,\n  BabelNodeForOfStatement,\n  BabelNodeTryStatement,\n  BabelNodeObjectMethod,\n  BabelNodeClassMethod,\n} from \"babel-types\";\n\nexport function FindVarScopedDeclarations(ast_node: BabelNode): Array<BabelNode> {\n  function FindVarScopedDeclarationsFor(ast: BabelNode, level: number) {\n    let statements = [];\n    switch (ast.type) {\n      case \"Program\":\n        statements = ((ast: any): BabelNodeProgram).body;\n        break;\n      case \"BlockStatement\":\n        statements = ((ast: any): BabelNodeBlockStatement).body;\n        break;\n      case \"DoWhileStatement\":\n        statements = [((ast: any): BabelNodeDoWhileStatement).body];\n        break;\n      case \"WhileStatement\":\n        statements = [((ast: any): BabelNodeWhileStatement).body];\n        break;\n      case \"IfStatement\":\n        let astIfStatement: BabelNodeIfStatement = (ast: any);\n        statements = [astIfStatement.consequent, astIfStatement.alternate];\n        break;\n      case \"ForStatement\":\n        let astForStatement: BabelNodeForStatement = (ast: any);\n        statements = [astForStatement.init, astForStatement.body];\n        break;\n      case \"ForInStatement\":\n        let astForInStatement: BabelNodeForInStatement = (ast: any);\n        statements = [astForInStatement.left, astForInStatement.body];\n        break;\n      case \"ForOfStatement\":\n        let astForOfStatement: BabelNodeForOfStatement = (ast: any);\n        statements = [astForOfStatement.left, astForOfStatement.body];\n        break;\n      case \"LabeledStatement\":\n        statements = [((ast: any): BabelNodeLabeledStatement).body];\n        break;\n      case \"WithStatement\":\n        statements = [((ast: any): BabelNodeWithStatement).body];\n        break;\n      case \"SwitchStatement\":\n        for (let switchCase of ((ast: any): BabelNodeSwitchStatement).cases) {\n          statements = statements.concat(switchCase.consequent);\n        }\n        break;\n      case \"TryStatement\":\n        let astTryStatement: BabelNodeTryStatement = (ast: any);\n        statements = [astTryStatement.block];\n        if (astTryStatement.finalizer) statements.push(astTryStatement.finalizer);\n        if (astTryStatement.handler) statements.push(astTryStatement.handler.body);\n        break;\n      case \"VariableDeclaration\":\n        return ast.kind === \"var\" ? [ast] : [];\n      case \"FunctionDeclaration\":\n        return level < 2 ? [ast] : [];\n      default:\n        return [];\n    }\n\n    let decls = [];\n    for (let statement of statements) {\n      if (statement) {\n        decls = decls.concat(FindVarScopedDeclarationsFor(statement, level + 1));\n      }\n    }\n\n    return decls;\n  }\n  return FindVarScopedDeclarationsFor(ast_node, 0);\n}\n\n// ECMA262 9.2.12\nexport function FunctionDeclarationInstantiation(\n  realm: Realm,\n  func: ECMAScriptSourceFunctionValue,\n  argumentsList: Array<Value>\n): EmptyValue {\n  // 1. Let calleeContext be the running execution context.\n  let calleeContext = realm.getRunningContext();\n\n  // 2. Let env be the LexicalEnvironment of calleeContext.\n  let env = calleeContext.lexicalEnvironment;\n\n  // 3. Let envRec be env's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 4. Let code be the value of the [[ECMAScriptCode]] internal slot of func.\n  let code = func.$ECMAScriptCode;\n  invariant(code !== undefined);\n\n  // 5. Let strict be the value of the [[Strict]] internal slot of func.\n  let strict = func.$Strict;\n\n  // 6. Let formals be the value of the [[FormalParameters]] internal slot of func.\n  let formals = func.$FormalParameters;\n  invariant(formals !== undefined);\n\n  // 7. Let parameterNames be the BoundNames of formals.\n  let parameterNames = Object.create(null);\n  for (let param of formals) {\n    let paramBindings = t.getBindingIdentifiers(param, true);\n\n    for (let name in paramBindings) {\n      parameterNames[name] = (parameterNames[name] || []).concat(paramBindings[name]);\n    }\n  }\n\n  // 8. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.\n  let hasDuplicates = false;\n  for (let name in parameterNames) {\n    let identifiers = parameterNames[name];\n    if (identifiers.length > 1) hasDuplicates = true;\n  }\n  parameterNames = Object.keys(parameterNames);\n\n  // 9. Let simpleParameterList be IsSimpleParameterList of formals.\n  let simpleParameterList = true;\n  for (let param of formals) {\n    if (param.type !== \"Identifier\") {\n      simpleParameterList = false;\n      break;\n    }\n  }\n\n  // 10. Let hasParameterExpressions be ContainsExpression of formals.\n  let hasParameterExpressions = false;\n  invariant(formals !== undefined);\n  for (let param of formals) {\n    if (ContainsExpression(realm, param)) {\n      hasParameterExpressions = true;\n      break;\n    }\n  }\n\n  // 11. Let varNames be the VarDeclaredNames of code.\n  let varNames = [];\n  traverseFast(code, node => {\n    if (node.type === \"VariableDeclaration\" && node.kind === \"var\") {\n      varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n    }\n\n    if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n      return true;\n    }\n\n    return false;\n  });\n\n  // 12. Let varDeclarations be the VarScopedDeclarations of code.\n  let varDeclarations = FindVarScopedDeclarations(code);\n\n  // 13. Let lexicalNames be the LexicallyDeclaredNames of code.\n  let lexicalNames = [];\n\n  // 14. Let functionNames be an empty List.\n  let functionNames = [];\n\n  // 15. Let functionsToInitialize be an empty List.\n  let functionsToInitialize = [];\n\n  // 16. For each d in varDeclarations, in reverse list order do\n  for (let d of varDeclarations.reverse()) {\n    // a. If d is neither a VariableDeclaration or a ForBinding, then\n    if (d.type !== \"VariableDeclaration\") {\n      // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n      invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n      // ii. Let fn be the sole element of the BoundNames of d.\n      let fn = BoundNames(realm, d)[0];\n      // iii. If fn is not an element of functionNames, then\n      if (functionNames.indexOf(fn) < 0) {\n        // 1. Insert fn as the first element of functionNames.\n        functionNames.unshift(fn);\n        // 2. NOTE If there are multiple FunctionDeclarations or GeneratorDeclarations for the same name, the last declaration is used.\n        // 3. Insert d as the first element of functionsToInitialize.\n        functionsToInitialize.unshift(d);\n      }\n    }\n  }\n\n  // 17. Let argumentsObjectNeeded be true.\n  let argumentsObjectNeeded = true;\n\n  // 18. If the value of the [[realmMode]] internal slot of func is lexical, then\n  if (func.$ThisMode === \"lexical\") {\n    // a. NOTE Arrow functions never have an arguments objects.\n    // b. Let argumentsObjectNeeded be false.\n    argumentsObjectNeeded = false;\n  } else if (parameterNames.indexOf(\"arguments\") >= 0) {\n    // 19. Else if \"arguments\" is an element of parameterNames, then\n    // a. Let argumentsObjectNeeded be false.\n    argumentsObjectNeeded = false;\n  } else if (hasParameterExpressions === false) {\n    // 20. Else if hasParameterExpressions is false, then\n    // a. If \"arguments\" is an element of functionNames or if \"arguments\" is an element of lexicalNames, then\n    if (functionNames.indexOf(\"arguments\") >= 0 || lexicalNames.indexOf(\"arguments\") >= 0) {\n      // i. Let argumentsObjectNeeded be false.\n      argumentsObjectNeeded = true;\n    }\n  }\n\n  // 21. For each String paramName in parameterNames, do\n  for (let paramName of parameterNames) {\n    // a. Let alreadyDeclared be envRec.HasBinding(paramName).\n    let alreadyDeclared = envRec.HasBinding(paramName);\n\n    // b. NOTE Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.\n\n    // c. If alreadyDeclared is false, then\n    if (alreadyDeclared === false) {\n      // i. Perform ! envRec.CreateMutableBinding(paramName, false).\n      envRec.CreateMutableBinding(paramName, false);\n\n      // ii. If hasDuplicates is true, then\n      if (hasDuplicates === true) {\n        // 1. Perform ! envRec.InitializeBinding(paramName, undefined).\n        envRec.InitializeBinding(paramName, realm.intrinsics.undefined);\n      }\n    }\n  }\n\n  // 22. If argumentsObjectNeeded is true, then\n  if (argumentsObjectNeeded === true) {\n    let ao;\n\n    // a. If strict is true or if simpleParameterList is false, then\n    if (strict === true || simpleParameterList === false) {\n      // i. Let ao be CreateUnmappedArgumentsObject(argumentsList).\n      ao = CreateUnmappedArgumentsObject(realm, argumentsList);\n    } else {\n      // b. Else,\n      // i. NOTE mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.\n      // ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).\n      invariant(formals !== undefined);\n      ao = CreateMappedArgumentsObject(realm, func, formals, argumentsList, envRec);\n    }\n\n    // c. If strict is true, then\n    if (strict === true) {\n      // i. Perform ! envRec.CreateImmutableBinding(\"arguments\", false).\n      envRec.CreateImmutableBinding(\"arguments\", false);\n    } else {\n      // d. Else,\n      // i. Perform ! envRec.CreateMutableBinding(\"arguments\", false).\n      envRec.CreateMutableBinding(\"arguments\", false);\n    }\n\n    // e. Call envRec.InitializeBinding(\"arguments\", ao).\n    envRec.InitializeBinding(\"arguments\", ao);\n\n    // f. Append \"arguments\" to parameterNames.\n    parameterNames.push(\"arguments\");\n  }\n\n  // 23. Let iteratorRecord be Record {[[Iterator]]: CreateListIterator(argumentsList), [[Done]]: false}.\n  let iteratorRecord = {\n    $Iterator: CreateListIterator(realm, argumentsList),\n    $Done: false,\n  };\n\n  // 24. If hasDuplicates is true, then\n  if (hasDuplicates === true) {\n    // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.\n    invariant(formals !== undefined);\n    IteratorBindingInitialization(realm, formals, iteratorRecord, strict);\n  } else {\n    // 25. Else,\n    // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.\n    invariant(formals !== undefined);\n    IteratorBindingInitialization(realm, formals, iteratorRecord, strict, env);\n  }\n\n  // 26. If hasParameterExpressions is false, then\n  let varEnv, varEnvRec;\n  if (hasParameterExpressions === false) {\n    // a. NOTE Only a single lexical environment is needed for the parameters and top-level vars.\n    // b. Let instantiatedVarNames be a copy of the List parameterNames.\n    let instantiatedVarNames = parameterNames.slice();\n\n    // c. For each n in varNames, do\n    for (let n of varNames) {\n      // i. If n is not an element of instantiatedVarNames, then\n      if (instantiatedVarNames.indexOf(n) < 0) {\n        // 1. Append n to instantiatedVarNames.\n        instantiatedVarNames.push(n);\n\n        // 2. Perform ! envRec.CreateMutableBinding(n, false).\n        envRec.CreateMutableBinding(n, false);\n\n        // 3. Call envRec.InitializeBinding(n, undefined).\n        envRec.InitializeBinding(n, realm.intrinsics.undefined);\n      }\n    }\n\n    // e. Let varEnv be env.\n    varEnv = env;\n\n    // f. Let varEnvRec be envRec.\n    varEnvRec = envRec;\n  } else {\n    // 27. Else,\n    // a. NOTE A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.\n\n    // b. Let varEnv be NewDeclarativeEnvironment(env).\n    varEnv = NewDeclarativeEnvironment(realm, env);\n\n    // c. Let varEnvRec be varEnv's EnvironmentRecord.\n    varEnvRec = varEnv.environmentRecord;\n\n    // d. Set the VariableEnvironment of calleeContext to varEnv.\n    calleeContext.variableEnvironment = varEnv;\n\n    // e. Let instantiatedVarNames be a new empty List.\n    let instantiatedVarNames = [];\n\n    // f. For each n in varNames, do\n    for (let n of varNames) {\n      // i. If n is not an element of instantiatedVarNames, then\n      if (instantiatedVarNames.indexOf(n) < 0) {\n        // 1. Append n to instantiatedVarNames.\n        instantiatedVarNames.push(n);\n\n        // 2. Perform ! varEnvRec.CreateMutableBinding(n, false).\n        varEnvRec.CreateMutableBinding(n, false);\n\n        // 3. If n is not an element of parameterNames or if n is an element of functionNames, let initialValue be undefined.\n        let initialValue;\n        if (parameterNames.indexOf(n) < 0 || functionNames.indexOf(n) < 0) {\n          initialValue = realm.intrinsics.undefined;\n        } else {\n          // 4. Else,\n          // a. Let initialValue be ! envRec.GetBindingValue(n, false).\n          initialValue = envRec.GetBindingValue(n, false);\n        }\n\n        // 5. Call varEnvRec.InitializeBinding(n, initialValue).\n        varEnvRec.InitializeBinding(n, initialValue);\n\n        // 6. NOTE vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.\n      }\n    }\n  }\n\n  // 28. NOTE: Annex B.3.3.1 adds additional steps at realm point.\n\n  let lexEnv;\n\n  // 29. If strict is false, then\n  if (strict === false) {\n    // a. Let lexEnv be NewDeclarativeEnvironment(varEnv).\n    lexEnv = NewDeclarativeEnvironment(realm, varEnv);\n\n    // b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval (see 12.3.4.1) can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. realm is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.\n  } else {\n    // 30. Else, let lexEnv be varEnv.\n    lexEnv = varEnv;\n  }\n\n  // 31. Let lexEnvRec be lexEnv's EnvironmentRecord.\n  let lexEnvRec = lexEnv.environmentRecord;\n\n  // 32. Set the LexicalEnvironment of calleeContext to lexEnv.\n  calleeContext.lexicalEnvironment = lexEnv;\n\n  // 33. Let lexDeclarations be the LexicallyScopedDeclarations of code.\n  let lexDeclarations = [];\n\n  // 34. For each element d in lexDeclarations do\n  for (let d of lexDeclarations) {\n    // a. NOTE A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.\n    // b. For each element dn of the BoundNames of d do\n    for (let dn of BoundNames(realm, d)) {\n      // i. If IsConstantDeclaration of d is true, then\n      if (d.kind === \"const\") {\n        // 1. Perform ! lexEnvRec.CreateImmutableBinding(dn, true).\n        lexEnvRec.CreateImmutableBinding(dn, true);\n      } else {\n        // ii. Else,\n        // 1. Perform ! lexEnvRec.CreateMutableBinding(dn, false).\n        lexEnvRec.CreateMutableBinding(dn, false);\n      }\n    }\n  }\n\n  // 35. For each parsed grammar phrase f in functionsToInitialize, do\n  for (let f of functionsToInitialize) {\n    // a. Let fn be the sole element of the BoundNames of f.\n    let fn = BoundNames(realm, f)[0];\n    // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n    let fo = lexEnv.evaluate(f, strict);\n    invariant(fo instanceof Value);\n    // c. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n    varEnvRec.SetMutableBinding(fn, fo, false);\n  }\n\n  // 36. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n\n// ECMA262 9.2.11\nexport function SetFunctionName(\n  realm: Realm,\n  F: ObjectValue,\n  name: PropertyKeyValue | AbstractValue,\n  prefix?: string\n): boolean {\n  // 1. Assert: F is an extensible object that does not have a name own property.\n  invariant(F.getExtensible(), \"expected object to be extensible and not have a name property\");\n\n  // 2. Assert: Type(name) is either Symbol or String.\n  invariant(\n    typeof name === \"string\" ||\n      name instanceof StringValue ||\n      name instanceof SymbolValue ||\n      name instanceof AbstractValue,\n    \"expected name to be a string or symbol\"\n  );\n  if (typeof name === \"string\") name = new StringValue(realm, name);\n\n  // 3. Assert: If prefix was passed, then Type(prefix) is String.\n  invariant(prefix === undefined || typeof prefix === \"string\", \"expected prefix to be a string if passed\");\n\n  // 4. If Type(name) is Symbol, then\n  if (name instanceof SymbolValue) {\n    // a. Let description be name's [[Description]] value.\n    let description = name.$Description;\n\n    // b. If description is undefined, let name be the empty String.\n    if (description === undefined) {\n      name = realm.intrinsics.emptyString;\n    } else {\n      // c. Else, let name be the concatenation of \"[\", description, and \"]\".\n      invariant(description instanceof Value);\n      name = new StringValue(realm, `[${description.throwIfNotConcreteString().value}]`);\n    }\n  }\n\n  // 5. If prefix was passed, then\n  if (prefix) {\n    // a. Let name be the concatenation of prefix, code unit 0x0020 (SPACE), and name.\n    if (name instanceof AbstractValue) {\n      let prefixVal = new StringValue(realm, prefix + \" \");\n      name = realm.createAbstract(\n        new TypesDomain(StringValue),\n        ValuesDomain.topVal,\n        [prefixVal, name],\n        ([lnode, rnode]) => t.binaryExpression(\"+\", lnode, rnode)\n      );\n    } else {\n      name = new StringValue(realm, `${prefix} ${name.value}`);\n    }\n  }\n\n  // 6. Return ! DefinePropertyOrThrow(F, \"name\", PropertyDescriptor{[[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n  return DefinePropertyOrThrow(realm, F, \"name\", {\n    value: name,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n  });\n}\n\n// ECMA262 9.2.3\nexport function FunctionInitialize(\n  realm: Realm,\n  F: ECMAScriptSourceFunctionValue,\n  kind: \"normal\" | \"method\" | \"arrow\",\n  ParameterList: Array<BabelNodeLVal>,\n  Body: BabelNodeBlockStatement,\n  Scope: LexicalEnvironment\n): ECMAScriptSourceFunctionValue {\n  // Note that F is a new object, and we can thus write to internal slots\n  invariant(realm.isNewObject(F));\n\n  // 1. Assert: F is an extensible object that does not have a length own property.\n  invariant(F.getExtensible(), \"expected to be extensible and no length property\");\n\n  // 2. Let len be the ExpectedArgumentCount of ParameterList.\n  let len = 0;\n  for (let FormalParameter of ParameterList) {\n    if (FormalParameter.type === \"AssignmentPattern\") {\n      break;\n    }\n    len += 1;\n  }\n\n  // 3. Perform ! DefinePropertyOrThrow(F, \"length\", PropertyDescriptor{[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n  DefinePropertyOrThrow(realm, F, \"length\", {\n    value: new NumberValue(realm, len),\n    writable: false,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // 4. Let Strict be the value of the [[Strict]] internal slot of F.\n  let Strict = F.$Strict;\n\n  // 5. Set the [[Environment]] internal slot of F to the value of Scope.\n  F.$Environment = Scope;\n\n  // 6. Set the [[FormalParameters]] internal slot of F to ParameterList.\n  F.$FormalParameters = ParameterList;\n\n  // 7. Set the [[ECMAScriptCode]] internal slot of F to Body.\n  F.$ECMAScriptCode = Body;\n\n  // 8. Set the [[ScriptOrModule]] internal slot of F to GetActiveScriptOrModule().\n  F.$ScriptOrModule = GetActiveScriptOrModule(realm);\n\n  // 9. If kind is Arrow, set the [[realmMode]] internal slot of F to lexical.\n  if (kind === \"arrow\") {\n    F.$ThisMode = \"lexical\";\n  } else if (Strict === true) {\n    // 10. Else if Strict is true, set the [[realmMode]] internal slot of F to strict.\n    F.$ThisMode = \"strict\";\n  } else {\n    // 11. Else set the [[realmMode]] internal slot of F to global.\n    F.$ThisMode = \"global\";\n  }\n\n  // Return F.\n  return F;\n}\n\n// ECMA262 9.2.6\nexport function GeneratorFunctionCreate(\n  realm: Realm,\n  kind: \"normal\" | \"method\",\n  ParameterList: Array<BabelNodeLVal>,\n  Body: BabelNodeBlockStatement,\n  Scope: LexicalEnvironment,\n  Strict: boolean\n): ECMAScriptSourceFunctionValue {\n  // 1. Let functionPrototype be the intrinsic object %Generator%.\n  let functionPrototype = realm.intrinsics.Generator;\n\n  // 2. Let F be FunctionAllocate(functionPrototype, Strict, \"generator\").\n  let F = FunctionAllocate(realm, functionPrototype, Strict, \"generator\");\n\n  // 3. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n  return FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n}\n\n// ECMA262 9.2.7\nexport function AddRestrictedFunctionProperties(F: FunctionValue, realm: Realm) {\n  // 1. Assert: realm.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.\n  // 2. Let thrower be realm.[[Intrinsics]].[[%ThrowTypeError%]].\n  let thrower = realm.intrinsics.ThrowTypeError;\n  invariant(thrower);\n\n  let desc = {\n    get: thrower,\n    set: thrower,\n    enumerable: false,\n    configurable: true,\n  };\n  // 3. Return ! DefinePropertyOrThrow(F, \"arguments\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).\n  return DefinePropertyOrThrow(realm, F, \"arguments\", desc);\n}\n\n// ECMA262 9.2.1\nexport function $Call(realm: Realm, F: ECMAScriptFunctionValue, thisArgument: Value, argsList: Array<Value>): Value {\n  return InternalCall(realm, F, thisArgument, argsList, 0);\n}\n\nfunction InternalCall(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  thisArgument: Value,\n  argsList: Array<Value>,\n  tracerIndex: number\n): Value {\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"expected function value\");\n\n  // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n  while (tracerIndex < realm.tracers.length) {\n    let tracer = realm.tracers[tracerIndex];\n    let nextIndex = ++tracerIndex;\n    let detourResult = tracer.detourCall(F, thisArgument, argsList, undefined, () =>\n      InternalCall(realm, F, thisArgument, argsList, nextIndex)\n    );\n    if (detourResult instanceof Value) return detourResult;\n  }\n\n  // 2. If F's [[FunctionKind]] internal slot is \"classConstructor\", throw a TypeError exception.\n  if (F.$FunctionKind === \"classConstructor\")\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n\n  // 3. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).\n  let calleeContext = PrepareForOrdinaryCall(realm, F, undefined);\n\n  let result;\n  try {\n    for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argsList, undefined);\n\n    // 5. Assert: calleeContext is now the running execution context.\n    invariant(realm.getRunningContext() === calleeContext, \"calleeContext should be current execution context\");\n\n    // 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n\n    // 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    result = OrdinaryCallEvaluateBody(realm, F, argsList);\n  } finally {\n    // 8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.popContext(calleeContext);\n    invariant(realm.getRunningContext() === callerContext);\n    if (calleeContext.savedCompletion !== undefined) {\n      if (callerContext.savedCompletion !== undefined)\n        callerContext.savedCompletion = composePossiblyNormalCompletions(\n          realm,\n          callerContext.savedCompletion,\n          calleeContext.savedCompletion\n        );\n      else callerContext.savedCompletion = calleeContext.savedCompletion;\n      realm.captureEffects();\n    }\n\n    for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argsList, undefined, (result: any));\n  }\n\n  // 9. If result.[[Type]] is return, return NormalCompletion(result.[[Value]]).\n  if (result instanceof ReturnCompletion) {\n    return result.value;\n  }\n  if (result instanceof JoinedAbruptCompletions) {\n    result = joinAndRemoveNestedReturnCompletions(realm, result);\n  }\n\n  // 10. ReturnIfAbrupt(result).  or if possibly abrupt\n  if (result instanceof Completion) {\n    throw result;\n  }\n\n  // 11. Return NormalCompletion(undefined).\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 9.2.2\nexport function $Construct(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue\n): ObjectValue {\n  return InternalConstruct(realm, F, argumentsList, newTarget, undefined, 0);\n}\n\nfunction InternalConstruct(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue,\n  thisArgument: void | ObjectValue,\n  tracerIndex: number\n): ObjectValue {\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"expected function\");\n\n  // 2. Assert: Type(newTarget) is Object.\n  invariant(newTarget instanceof ObjectValue, \"expected object\");\n\n  // 3. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 4. Let kind be F's [[ConstructorKind]] internal slot.\n  let kind = F.$ConstructorKind;\n\n  // 5. If kind is \"base\", then\n  if (thisArgument === undefined && kind === \"base\") {\n    // a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\").\n    thisArgument = OrdinaryCreateFromConstructor(realm, newTarget, \"ObjectPrototype\");\n  }\n\n  // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n  while (tracerIndex < realm.tracers.length) {\n    let tracer = realm.tracers[tracerIndex];\n    let nextIndex = ++tracerIndex;\n    let detourResult = tracer.detourCall(F, thisArgument, argumentsList, newTarget, () =>\n      InternalConstruct(realm, F, argumentsList, newTarget, thisArgument, nextIndex)\n    );\n    if (detourResult instanceof ObjectValue) return detourResult;\n    invariant(detourResult === undefined);\n  }\n\n  // 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).\n  let calleeContext = PrepareForOrdinaryCall(realm, F, newTarget);\n\n  // 7. Assert: calleeContext is now the running execution context.\n  invariant(realm.getRunningContext() === calleeContext, \"expected calleeContext to be running context\");\n\n  let result, envRec;\n  try {\n    for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argumentsList, newTarget);\n\n    // 8. If kind is \"base\", perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    if (kind === \"base\") {\n      invariant(thisArgument, \"this wasn't initialized for some reason\");\n      OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n    }\n\n    // 9. Let constructorEnv be the LexicalEnvironment of calleeContext.\n    let constructorEnv = calleeContext.lexicalEnvironment;\n\n    // 10. Let envRec be constructorEnv's EnvironmentRecord.\n    envRec = constructorEnv.environmentRecord;\n\n    // 11. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    result = OrdinaryCallEvaluateBody(realm, F, argumentsList);\n  } finally {\n    // 12. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.popContext(calleeContext);\n    invariant(realm.getRunningContext() === callerContext);\n\n    for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argumentsList, newTarget, result);\n  }\n\n  // 13. If result.[[Type]] is return, then\n  if (result instanceof ReturnCompletion) {\n    // a. If Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).\n    if (result.value.mightBeObject()) {\n      return result.value.throwIfNotConcreteObject();\n    }\n\n    // b. If kind is \"base\", return NormalCompletion(thisArgument).\n    if (kind === \"base\") {\n      invariant(thisArgument, \"this wasn't initialized for some reason\");\n      return thisArgument;\n    }\n\n    // c. If result.[[Value]] is not undefined, throw a TypeError exception.\n    if (!result.value.mightBeUndefined())\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"constructor must return Object\");\n    result.value.throwIfNotConcrete();\n  } else if (result instanceof AbruptCompletion) {\n    // 14. Else, ReturnIfAbrupt(result).\n    throw result;\n  }\n\n  // 15. Return ? envRec.GetThisBinding().\n  let envRecThisBinding = envRec.GetThisBinding();\n  invariant(envRecThisBinding instanceof ObjectValue);\n  return envRecThisBinding;\n}\n\n// ECMA262 9.2.3\nexport function FunctionAllocate(\n  realm: Realm,\n  functionPrototype: ObjectValue,\n  strict: boolean,\n  functionKind: \"normal\" | \"non-constructor\" | \"generator\"\n): ECMAScriptSourceFunctionValue {\n  // 1. Assert: Type(functionPrototype) is Object.\n  invariant(functionPrototype instanceof ObjectValue, \"expected functionPrototype to be an object\");\n\n  // 2. Assert: functionKind is either \"normal\", \"non-constructor\" or \"generator\".\n  invariant(\n    functionKind === \"normal\" || functionKind === \"non-constructor\" || functionKind === \"generator\",\n    \"invalid functionKind\"\n  );\n\n  // 3. If functionKind is \"normal\", let needsConstruct be true.\n  let needsConstruct;\n  if (functionKind === \"normal\") {\n    needsConstruct = true;\n  } else {\n    // 4. Else, let needsConstruct be false.\n    needsConstruct = false;\n  }\n\n  // 5. If functionKind is \"non-constructor\", let functionKind be \"normal\".\n  if (functionKind === \"non-constructor\") {\n    functionKind = \"normal\";\n  }\n\n  // 6. Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal slots are initialized to undefined.\n  let F = new ECMAScriptSourceFunctionValue(realm);\n\n  // 7. Set F's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n  // 8. Set F's [[Call]] internal method to the definition specified in 9.2.1.\n  F.$Call = (thisArgument, argsList) => {\n    return $Call(realm, F, thisArgument, argsList);\n  };\n\n  // 9. If needsConstruct is true, then\n  if (needsConstruct === true) {\n    // a. Set F's [[Construct]] internal method to the definition specified in 9.2.2.\n    F.$Construct = (argumentsList, newTarget) => {\n      return $Construct(realm, F, argumentsList, newTarget);\n    };\n\n    // b. Set the [[ConstructorKind]] internal slot of F to \"base\".\n    F.$ConstructorKind = \"base\";\n  }\n\n  // 10. Set the [[Strict]] internal slot of F to strict.\n  F.$Strict = strict;\n\n  // 11. Set the [[FunctionKind]] internal slot of F to functionKind.\n  F.$FunctionKind = functionKind;\n\n  // 12. Set the [[Prototype]] internal slot of F to functionPrototype.\n  F.$Prototype = functionPrototype;\n\n  // 13. Set the [[Extensible]] internal slot of F to true.\n  F.setExtensible(true);\n\n  // 14. Set the [[Realm]] internal slot of F to the current Realm Record.\n  F.$Realm = realm;\n\n  // 15. Return F.\n  return F;\n}\n\n// ECMA262 9.4.1.1\nfunction $BoundCall(realm: Realm, F: BoundFunctionValue, thisArgument: Value, argumentsList: Array<Value>): Value {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Let boundThis be the value of F's [[BoundThis]] internal slot.\n  let boundThis = F.$BoundThis;\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. Return ? Call(target, boundThis, args).\n  return Call(realm, target, boundThis, args);\n}\n\n// ECMA262 9.4.1.2\nfunction $BoundConstruct(\n  realm: Realm,\n  F: BoundFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue\n): ObjectValue {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Assert: target has a [[Construct]] internal method.\n  invariant(target.$Construct !== undefined, \"doesn't have a construct internal method\");\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. If SameValue(F, newTarget) is true, let newTarget be target.\n  if (SameValue(realm, F, newTarget)) newTarget = target;\n\n  // 6. Return ? Construct(target, args, newTarget).\n  return Construct(realm, target, args, newTarget);\n}\n\n// ECMA262 9.4.1.3\nexport function BoundFunctionCreate(\n  realm: Realm,\n  targetFunction: ObjectValue,\n  boundThis: Value,\n  boundArgs: Array<Value>\n): ObjectValue {\n  // 1. Assert: Type(targetFunction) is Object.\n  invariant(targetFunction instanceof ObjectValue, \"expected an object\");\n\n  // 2. Let proto be ? targetFunction.[[GetPrototypeOf]]().\n  let proto = targetFunction.$GetPrototypeOf();\n\n  // 3. Let obj be a newly created object.\n  let obj = new BoundFunctionValue(realm);\n\n  // 4. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n  // 5. Set the [[Call]] internal method of obj as described in 9.4.1.1.\n  obj.$Call = (thisArgument, argsList) => {\n    return $BoundCall(realm, obj, thisArgument, argsList);\n  };\n\n  // 6. If targetFunction has a [[Construct]] internal method, then\n  if (targetFunction.$Construct) {\n    // a. Set the [[Construct]] internal method of obj as described in 9.4.1.2.\n    obj.$Construct = (thisArgument, argsList) => {\n      return $BoundConstruct(realm, obj, thisArgument, argsList);\n    };\n  }\n\n  // 7. Set the [[Prototype]] internal slot of obj to proto.\n  obj.$Prototype = proto;\n\n  // 8. Set the [[Extensible]] internal slot of obj to true.\n  obj.setExtensible(true);\n\n  // 9. Set the [[BoundTargetFunction]] internal slot of obj to targetFunction.\n  obj.$BoundTargetFunction = targetFunction;\n\n  // 10. Set the [[BoundThis]] internal slot of obj to the value of boundThis.\n  obj.$BoundThis = boundThis;\n\n  // 11. Set the [[BoundArguments]] internal slot of obj to boundArgs.\n  obj.$BoundArguments = boundArgs;\n\n  // 12. Return obj.\n  return obj;\n}\n\n// ECMA262 18.2.1.1\nexport function PerformEval(realm: Realm, x: Value, evalRealm: Realm, strictCaller: boolean, direct: boolean): Value {\n  // 1. Assert: If direct is false, then strictCaller is also false.\n  if (direct === false) invariant(strictCaller === false, \"strictCaller is only allowed on direct eval\");\n\n  // 2. If Type(x) is not String, return x.\n  if (!(x instanceof StringValue)) return x;\n\n  // 3. Let script be the ECMAScript code that is the result of parsing x, interpreted as UTF-16 encoded Unicode text\n  //    as described in 6.1.4, for the goal symbol Script. If the parse fails, throw a SyntaxError exception. If any\n  //    early errors are detected, throw a SyntaxError or a ReferenceError exception, depending on the type of the\n  //    error (but see also clause 16). Parsing and early error detection may be interweaved in an implementation\n  //    dependent manner.\n  let ast = parse(realm, x.value, \"eval\", \"script\");\n  let script = ast.program;\n\n  // 4. If script Contains ScriptBody is false, return undefined.\n  if (!script.body) return realm.intrinsics.undefined;\n\n  // 5. Let body be the ScriptBody of script.\n  let body = t.blockStatement(script.body, script.directives);\n\n  // 6. If strictCaller is true, let strictEval be true.\n  let strictEval;\n  if (strictCaller) {\n    strictEval = true;\n  } else {\n    // 7. Else, let strictEval be IsStrict of script.\n    strictEval = IsStrict(script);\n  }\n\n  // 8. Let ctx be the running execution context. If direct is true, ctx will be the execution context that\n  //    performed the direct eval. If direct is false, ctx will be the execution context for the invocation of\n  //    the eval function.\n  let ctx = realm.getRunningContext();\n\n  // 9. If direct is true, then\n  let lexEnv, varEnv;\n  if (direct) {\n    // a. Let lexEnv be NewDeclarativeEnvironment(ctx's LexicalEnvironment).\n    lexEnv = NewDeclarativeEnvironment(realm, ctx.lexicalEnvironment);\n\n    // b. Let varEnv be ctx's VariableEnvironment.\n    varEnv = ctx.variableEnvironment;\n  } else {\n    // 10. Else,\n    // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).\n    lexEnv = NewDeclarativeEnvironment(realm, evalRealm.$GlobalEnv);\n\n    // b. Let varEnv be evalRealm.[[GlobalEnv]].\n    varEnv = evalRealm.$GlobalEnv;\n  }\n\n  // 11. If strictEval is true, let varEnv be lexEnv.\n  if (strictEval) varEnv = lexEnv;\n\n  // 12. If ctx is not already suspended, suspend ctx.\n  ctx.suspend();\n\n  // 13. Let evalCxt be a new ECMAScript code execution context.\n  let evalCxt = new ExecutionContext();\n  evalCxt.isStrict = strictEval;\n\n  // 14. Set the evalCxt's Function to null.\n  evalCxt.setFunction(null);\n\n  // 15. Set the evalCxt's Realm to evalRealm.\n  evalCxt.setRealm(evalRealm);\n\n  // 16. Set the evalCxt's ScriptOrModule to ctx's ScriptOrModule.\n  evalCxt.ScriptOrModule = ctx.ScriptOrModule;\n\n  // 17. Set the evalCxt's VariableEnvironment to varEnv.\n  evalCxt.variableEnvironment = varEnv;\n\n  // 18. Set the evalCxt's LexicalEnvironment to lexEnv.\n  evalCxt.lexicalEnvironment = lexEnv;\n\n  // 19. Push evalCxt on to the execution context stack; evalCxt is now the running execution context.\n  realm.pushContext(evalCxt);\n\n  let result;\n  try {\n    // 20. Let result be EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval).\n    invariant(varEnv);\n    try {\n      result = EvalDeclarationInstantiation(realm, body, varEnv, lexEnv, strictEval);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        result = e;\n      } else {\n        throw e;\n      }\n    }\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n    // 21. If result.[[Type]] is normal, then\n    if (result instanceof Value) {\n      // Evaluate expressions that passed for directives.\n      if (script.directives) {\n        for (let directive of script.directives) {\n          result = new StringValue(realm, directive.value.value);\n        }\n      }\n\n      // a. Let result be the result of evaluating body.\n      result = EvaluateStatements(script.body, result, strictEval, lexEnv, realm);\n    }\n\n    // 22. If result.[[Type]] is normal and result.[[Value]] is empty, then\n    if (result instanceof EmptyValue) {\n      // a. Let result be NormalCompletion(undefined).\n      result = realm.intrinsics.undefined;\n    }\n  } finally {\n    // 23. Suspend evalCxt and remove it from the execution context stack.\n    evalCxt.suspend();\n    realm.popContext(evalCxt);\n  }\n\n  // 24. Resume the context that is now on the top of the execution context stack as the running execution context.\n  invariant(realm.getRunningContext() === ctx);\n  ctx.resume();\n\n  // 25. Return Completion(result).\n  if (result instanceof Value) {\n    return result;\n  } else {\n    invariant(result instanceof AbruptCompletion);\n    throw result;\n  }\n}\n\nexport function EvaluateStatements(\n  body: Array<BabelNodeStatement>,\n  blockValue: void | NormalCompletion | Value,\n  strictCode: boolean,\n  blockEnv: LexicalEnvironment,\n  realm: Realm\n): NormalCompletion | Value {\n  for (let node of body) {\n    if (node.type !== \"FunctionDeclaration\") {\n      let res = blockEnv.evaluateAbstractCompletion(node, strictCode);\n      let context = realm.getRunningContext();\n      let savedCompletion = context.savedCompletion;\n      if (savedCompletion !== undefined) {\n        context.savedCompletion = undefined;\n        if (res instanceof Value) res = updatePossiblyNormalCompletionWithValue(realm, savedCompletion, res);\n        else if (res instanceof PossiblyNormalCompletion)\n          res = composePossiblyNormalCompletions(realm, savedCompletion, res);\n        else {\n          invariant(res instanceof AbruptCompletion);\n          let e = realm.getCapturedEffects();\n          invariant(e !== undefined);\n          realm.stopEffectCaptureAndUndoEffects();\n          invariant(context.savedCompletion !== undefined);\n          e[0] = res;\n          let joined_effects = joinPossiblyNormalCompletionWithAbruptCompletion(realm, savedCompletion, res, e);\n          realm.applyEffects(joined_effects);\n          res = joined_effects[0];\n          invariant(res instanceof AbruptCompletion);\n          throw res;\n        }\n      }\n      invariant(!(res instanceof Reference));\n      if (!(res instanceof EmptyValue)) {\n        if (blockValue === undefined || blockValue instanceof Value) {\n          if (res instanceof AbruptCompletion) throw UpdateEmpty(realm, res, blockValue || realm.intrinsics.empty);\n          invariant(res instanceof NormalCompletion || res instanceof Value);\n          blockValue = res;\n        } else {\n          invariant(blockValue instanceof PossiblyNormalCompletion);\n          if (res instanceof AbruptCompletion) {\n            throw stopEffectCaptureAndJoinCompletions(blockValue, res, realm);\n          } else {\n            if (res instanceof Value) blockValue.value = res;\n            else {\n              invariant(blockValue instanceof PossiblyNormalCompletion);\n              invariant(res instanceof PossiblyNormalCompletion);\n              blockValue = composePossiblyNormalCompletions(realm, blockValue, res);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // 7. Return blockValue.\n  return blockValue || realm.intrinsics.empty;\n}\n\nexport function PartiallyEvaluateStatements(\n  body: Array<BabelNodeStatement>,\n  blockValue: void | NormalCompletion | Value,\n  strictCode: boolean,\n  blockEnv: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, Array<BabelNodeStatement>] {\n  let statementAsts = [];\n  for (let node of body) {\n    if (node.type !== \"FunctionDeclaration\") {\n      let [res, nast, nio] = blockEnv.partiallyEvaluateCompletionDeref(node, strictCode);\n      for (let ioAst of nio) statementAsts.push(ioAst);\n      statementAsts.push((nast: any));\n      if (!(res instanceof EmptyValue)) {\n        if (blockValue === undefined || blockValue instanceof Value) {\n          if (res instanceof AbruptCompletion)\n            return [UpdateEmpty(realm, res, blockValue || realm.intrinsics.empty), statementAsts];\n          invariant(res instanceof NormalCompletion || res instanceof Value);\n          blockValue = res;\n        } else {\n          invariant(blockValue instanceof PossiblyNormalCompletion);\n          if (res instanceof AbruptCompletion) {\n            let e = realm.getCapturedEffects();\n            invariant(e !== undefined);\n            realm.stopEffectCaptureAndUndoEffects();\n            invariant(blockValue instanceof PossiblyNormalCompletion);\n            e[0] = res;\n            let joined_effects = joinPossiblyNormalCompletionWithAbruptCompletion(realm, blockValue, res, e);\n            realm.applyEffects(joined_effects);\n            let jres = joined_effects[0];\n            invariant(jres instanceof Value || jres instanceof Completion);\n            return [jres, statementAsts];\n          } else {\n            if (res instanceof Value) blockValue.value = res;\n            else {\n              invariant(blockValue instanceof PossiblyNormalCompletion);\n              invariant(res instanceof PossiblyNormalCompletion);\n              blockValue = composePossiblyNormalCompletions(realm, blockValue, res);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // 7. Return blockValue.\n  return [blockValue || realm.intrinsics.empty, statementAsts];\n}\n\n// ECMA262 9.2.5\nexport function FunctionCreate(\n  realm: Realm,\n  kind: \"normal\" | \"arrow\" | \"method\",\n  ParameterList: Array<BabelNodeLVal>,\n  Body: BabelNodeBlockStatement,\n  Scope: LexicalEnvironment,\n  Strict: boolean,\n  prototype?: ObjectValue\n): ECMAScriptSourceFunctionValue {\n  // 1. If the prototype argument was not passed, then\n  if (!prototype) {\n    // a. Let prototype be the intrinsic object %FunctionPrototype%.\n    prototype = realm.intrinsics.FunctionPrototype;\n  }\n\n  // 2. If kind is not Normal, let allocKind be \"non-constructor\".\n  let allocKind;\n  if (kind !== \"normal\") {\n    allocKind = \"non-constructor\";\n  } else {\n    // 3. Else, let allocKind be \"normal\".\n    allocKind = \"normal\";\n  }\n\n  // 4. Let F be FunctionAllocate(prototype, Strict, allocKind).\n  let F = FunctionAllocate(realm, prototype, Strict, allocKind);\n\n  // ECMAScript 2016, section 17:\n  //   \"Every other data property described in clauses 18 through 26 and in Annex B.2 has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } unless otherwise specified.\"\n  // Because we call `AddRestrictedFunctionProperties` on `FunctionPrototype`, accessing property \"arguments\" will raise a `TypeError` by default.\n  // However, in non-strict mode this behavior is not desired, so we will add them as own properties of each `FunctionValue`, in accordance with ECMA 17.\n  // Note: \"arguments\" ***MUST NOT*** be set if the function is in strict mode or is an arrow, method, constructor, or generator function.\n  //   See 16.2 \"Forbidden Extensions\"\n  if (!Strict && kind === \"normal\") {\n    DefinePropertyOrThrow(realm, F, \"arguments\", {\n      value: realm.intrinsics.undefined,\n      enumerable: false,\n      writable: true,\n      configurable: true,\n    });\n  }\n\n  // 5. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n  return FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n}\n\n// ECMA262 18.2.1.2\nexport function EvalDeclarationInstantiation(\n  realm: Realm,\n  body: BabelNodeBlockStatement,\n  varEnv: LexicalEnvironment,\n  lexEnv: LexicalEnvironment,\n  strict: boolean\n) {\n  // 1. Let varNames be the VarDeclaredNames of body.\n  let varNames = [];\n  traverseFast(body, node => {\n    if (node.type === \"VariableDeclaration\" && node.kind === \"var\") {\n      varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n    }\n\n    if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n      return true;\n    }\n\n    return false;\n  });\n\n  // 2. Let varDeclarations be the VarScopedDeclarations of body.\n  let varDeclarations = FindVarScopedDeclarations(body);\n\n  // 3. Let lexEnvRec be lexEnv's EnvironmentRecord.\n  let lexEnvRec = lexEnv.environmentRecord;\n\n  // 4. Let varEnvRec be varEnv's EnvironmentRecord.\n  let varEnvRec = varEnv.environmentRecord;\n\n  // 5. If strict is false, then\n  if (!strict) {\n    // a. If varEnvRec is a global Environment Record, then\n    if (varEnvRec instanceof GlobalEnvironmentRecord) {\n      // i. For each name in varNames, do\n      for (let name of varNames) {\n        // 1. If varEnvRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n        if (varEnvRec.HasLexicalDeclaration(name)) {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.SyntaxError,\n            new StringValue(realm, name + \" global object is restricted\")\n          );\n        }\n        // 2. NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.\n      }\n    }\n    // b. Let thisLex be lexEnv.\n    let thisLex = lexEnv;\n    // c. Assert: The following loop will terminate.\n    // d. Repeat while thisLex is not the same as varEnv,\n    while (thisLex !== varEnv) {\n      // i. Let thisEnvRec be thisLex's EnvironmentRecord.\n      let thisEnvRec = thisLex.environmentRecord;\n      // ii. If thisEnvRec is not an object Environment Record, then\n      if (!(thisEnvRec instanceof ObjectEnvironmentRecord)) {\n        // 1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.\n        // 2. For each name in varNames, do\n        for (let name of varNames) {\n          // a. If thisEnvRec.HasBinding(name) is true, then\n          if (thisEnvRec.HasBinding(name)) {\n            // i. Throw a SyntaxError exception.\n            throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + \" global object is restricted\");\n            // ii. NOTE: Annex B.3.5 defines alternate semantics for the above step.\n          }\n          // b. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.\n        }\n      }\n      // iii. Let thisLex be thisLex's outer environment reference.\n      thisLex = thisLex.parent;\n      invariant(thisLex !== null);\n    }\n  }\n\n  // 6. Let functionsToInitialize be a new empty List.\n  let functionsToInitialize = [];\n\n  // 7. Let declaredFunctionNames be a new empty List.\n  let declaredFunctionNames = [];\n\n  // 8. For each d in varDeclarations, in reverse list order do\n  for (let d of varDeclarations.reverse()) {\n    // a. If d is neither a VariableDeclaration or a ForBinding, then\n    if (d.type !== \"VariableDeclaration\") {\n      // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n      invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n      // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n      // iii. Let fn be the sole element of the BoundNames of d.\n      let fn = BoundNames(realm, d)[0];\n      // iv. If fn is not an element of declaredFunctionNames, then\n      if (declaredFunctionNames.indexOf(fn) < 0) {\n        // 1. If varEnvRec is a global Environment Record, then\n        if (varEnvRec instanceof GlobalEnvironmentRecord) {\n          // a. Let fnDefinable be ? varEnvRec.CanDeclareGlobalFunction(fn).\n          let fnDefinable = varEnvRec.CanDeclareGlobalFunction(fn);\n          // b. If fnDefinable is false, throw a TypeError exception.\n          if (!fnDefinable) {\n            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, fn + \" is not definable\");\n          }\n        }\n        // 2. Append fn to declaredFunctionNames.\n        declaredFunctionNames.push(fn);\n        // 3. Insert d as the first element of functionsToInitialize.\n        functionsToInitialize.unshift(d);\n      }\n    }\n  }\n\n  // 9. NOTE: Annex B.3.3.3 adds additional steps at this point.\n\n  // 10. Let declaredVarNames be a new empty List.\n  let declaredVarNames = [];\n\n  // 11. For each d in varDeclarations, do\n  for (let d of varDeclarations) {\n    // a. If d is a VariableDeclaration or a ForBinding, then\n    if (d.type === \"VariableDeclaration\") {\n      // i. For each String vn in the BoundNames of d, do\n      for (let vn of BoundNames(realm, d)) {\n        // 1. If vn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(vn) < 0) {\n          // a. If varEnvRec is a global Environment Record, then\n          if (varEnvRec instanceof GlobalEnvironmentRecord) {\n            // i. Let vnDefinable be ? varEnvRec.CanDeclareGlobalVar(vn).\n            let vnDefinable = varEnvRec.CanDeclareGlobalVar(vn);\n            // ii. If vnDefinable is false, throw a TypeError exception.\n            if (!vnDefinable) {\n              throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, vn + \" is not definable\");\n            }\n          }\n          // b. If vn is not an element of declaredVarNames, then\n          if (declaredVarNames.indexOf(vn) < 0) {\n            // i. Append vn to declaredVarNames.\n            declaredVarNames.push(vn);\n          }\n        }\n      }\n    }\n  }\n\n  // 12. NOTE: No abnormal terminations occur after this algorithm step unless varEnvRec is a global Environment Record and the global object is a Proxy exotic object.\n\n  // 13. Let lexDeclarations be the LexicallyScopedDeclarations of body.\n  let lexDeclarations = [];\n  for (let s of body.body) {\n    if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n      lexDeclarations.push(s);\n    }\n  }\n\n  // 14. For each element d in lexDeclarations do\n  for (let d of lexDeclarations) {\n    // a. NOTE Lexically declared names are only instantiated here but not initialized.\n    // b. For each element dn of the BoundNames of d do\n    for (let dn of BoundNames(realm, d)) {\n      // c. If IsConstantDeclaration of d is true, then\n      if (d.kind === \"const\") {\n        // i. Perform ? lexEnvRec.CreateImmutableBinding(dn, true).\n        lexEnvRec.CreateImmutableBinding(dn, true);\n      } else {\n        // d. Else,\n        // i. Perform ? lexEnvRec.CreateMutableBinding(dn, false).\n        lexEnvRec.CreateMutableBinding(dn, false);\n      }\n    }\n  }\n\n  // 15. For each production f in functionsToInitialize, do\n  for (let f of functionsToInitialize) {\n    // a. Let fn be the sole element of the BoundNames of f.\n    let fn = BoundNames(realm, f)[0];\n    // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n    let fo = lexEnv.evaluate(f, strict);\n    invariant(fo instanceof Value);\n    // c. If varEnvRec is a global Environment Record, then\n    if (varEnvRec instanceof GlobalEnvironmentRecord) {\n      // i. Perform ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true).\n      varEnvRec.CreateGlobalFunctionBinding(fn, fo, true);\n    } else {\n      // d. Else,\n      // i. Let bindingExists be varEnvRec.HasBinding(fn).\n      let bindingExists = varEnvRec.HasBinding(fn);\n      // ii. If bindingExists is false, then\n      if (!bindingExists) {\n        // 1. Let status be ! varEnvRec.CreateMutableBinding(fn, true).\n        varEnvRec.CreateMutableBinding(fn, true);\n        // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n        // 3. Perform ! varEnvRec.InitializeBinding(fn, fo).\n        varEnvRec.InitializeBinding(fn, fo);\n      } else {\n        // iii. Else,\n        // 1. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n        varEnvRec.SetMutableBinding(fn, fo, false);\n      }\n    }\n  }\n\n  // 16. For each String vn in declaredVarNames, in list order do\n  for (let vn of declaredVarNames) {\n    // a. If varEnvRec is a global Environment Record, then\n    if (varEnvRec instanceof GlobalEnvironmentRecord) {\n      // i. Perform ? varEnvRec.CreateGlobalVarBinding(vn, true).\n      varEnvRec.CreateGlobalVarBinding(vn, true);\n    } else {\n      // b. Else,\n      // i. Let bindingExists be varEnvRec.HasBinding(vn).\n      let bindingExists = varEnvRec.HasBinding(vn);\n      // ii. If bindingExists is false, then\n      if (!bindingExists) {\n        // 1. Let status be ! varEnvRec.CreateMutableBinding(vn, true).\n        varEnvRec.CreateMutableBinding(vn, true);\n        // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n        // 3. Perform ! varEnvRec.InitializeBinding(vn, undefined).\n        varEnvRec.InitializeBinding(vn, realm.intrinsics.undefined);\n      }\n    }\n  }\n\n  // 17. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n\n// ECMA 9.2.10\nexport function MakeMethod(realm: Realm, F: ECMAScriptSourceFunctionValue, homeObject: ObjectValue) {\n  // Note that F is a new object, and we can thus write to internal slots\n  invariant(realm.isNewObject(F));\n\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof ECMAScriptSourceFunctionValue, \"F is an ECMAScript function object.\");\n\n  // 2. Assert: Type(homeObject) is Object.\n  invariant(homeObject instanceof ObjectValue, \"Type(homeObject) is Object.\");\n\n  // 3. Set the [[HomeObject]] internal slot of F to homeObject.\n  F.$HomeObject = homeObject;\n\n  // 4. Return NormalCompletion(undefined).\n  return realm.intrinsics.undefined;\n}\n\n// ECMA 14.3.8\nexport function DefineMethod(\n  realm: Realm,\n  prop: BabelNodeObjectMethod | BabelNodeClassMethod,\n  obj: ObjectValue,\n  env: LexicalEnvironment,\n  strictCode: boolean,\n  functionPrototype?: ObjectValue\n) {\n  // 1. Let propKey be the result of evaluating PropertyName.\n  let propKey = EvalPropertyName(prop, env, realm, strictCode);\n\n  // 2. ReturnIfAbrupt(propKey).\n\n  // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n  let strict = strictCode || IsStrict(prop.body);\n\n  // 4. Let scope be the running execution context's LexicalEnvironment.\n  let scope = env;\n\n  // 5. If functionPrototype was passed as a parameter, let kind be Normal; otherwise let kind be Method.\n  let kind;\n  if (functionPrototype) {\n    // let kind be Normal;\n    kind = \"normal\";\n  } else {\n    // otherwise let kind be Method.\n    kind = \"method\";\n  }\n\n  // 6. Let closure be FunctionCreate(kind, StrictFormalParameters, FunctionBody, scope, strict). If functionPrototype was passed as a parameter, then pass its value as the prototype optional argument of FunctionCreate.\n  let closure = FunctionCreate(realm, kind, prop.params, prop.body, scope, strict, functionPrototype);\n\n  // 7. Perform MakeMethod(closure, object).\n  MakeMethod(realm, closure, obj);\n\n  // 8. Return the Record{[[Key]]: propKey, [[Closure]]: closure}.\n  return { $Key: propKey, $Closure: closure };\n}\n"]}