{"version":3,"sources":["../../../src/intrinsics/ecma262/NumberPrototype.js"],"names":["realm","obj","$NumberData","intrinsics","zero","defineNativeMethod","context","fractionDigits","x","value","throwIfNotConcrete","f","isNaN","s","Infinity","createErrorThrowCompletion","RangeError","positiveResultString","toExponential","undefined","toFixed","useAbstractInterpretation","deriveAbstract","topVal","n","buildToLocaleString","preludeGenerator","VALUE","toLocaleString","precision","num","p","toPrecision","radix","target","getType","codeTemplate","createAbstract","a","A","radixNumber","TypeError","toString"],"mappings":"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","file":"NumberPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport { ObjectValue, StringValue, UndefinedValue, AbstractValue, NumberValue } from \"../../values/index.js\";\nimport { ToInteger, ToString, thisNumberValue } from \"../../methods/index.js\";\nimport { TypesDomain, ValuesDomain } from \"../../domains/index.js\";\nimport invariant from \"../../invariant.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\n\nlet buildToLocaleString = buildExpressionTemplate(\"(VALUE).toLocaleString()\");\n\nexport default function(realm: Realm, obj: ObjectValue): void {\n  // ECMA262 20.1.3\n  obj.$NumberData = realm.intrinsics.zero;\n\n  // ECMA262 20.1.3.2\n  obj.defineNativeMethod(\"toExponential\", 1, (context, [fractionDigits]) => {\n    // 1. Let x be ? thisNumberValue(this value).\n    let x = thisNumberValue(realm, context).value;\n\n    // 2. Let f be ? ToInteger(fractionDigits).\n    fractionDigits = fractionDigits.throwIfNotConcrete();\n    let f = ToInteger(realm, fractionDigits);\n\n    // 3. Assert: f is 0, when fractionDigits is undefined.\n    invariant(f === 0 || !(fractionDigits instanceof UndefinedValue));\n\n    // 4. If x is NaN, return the String \"NaN\".\n    if (isNaN(x)) return new StringValue(realm, \"NaN\");\n\n    // 5. Let s be the empty String.\n    let s = \"\";\n\n    // 6. If x < 0, then\n    if (x < 0) {\n      // 6a. Let s be \"-\".\n      s = \"-\";\n\n      // 6b. Let x be -x.\n      x = -x;\n    }\n\n    // 7. If x = +∞, then\n    if (x === +Infinity) {\n      // 7a. Return the concatenation of the Strings s and \"Infinity\".\n      return new StringValue(realm, s + \"Infinity\");\n    }\n\n    // 8. If f < 0 or f > 20, throw a RangeError exception. However, an implementation is permitted to extend the behaviour of toExponential for values of f less than 0 or greater than 20. In this case toExponential would not necessarily throw RangeError for such values.\n    if (f < 0 || f > 20) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"f < 0 || f > 20\");\n    }\n\n    let positiveResultString = x.toExponential(fractionDigits instanceof UndefinedValue ? undefined : f);\n    return new StringValue(realm, s + positiveResultString);\n  });\n\n  // ECMA262 20.1.3.3\n  obj.defineNativeMethod(\"toFixed\", 1, (context, [fractionDigits]) => {\n    // 1. Let f be ToInteger(fractionDigits). (If fractionDigits is undefined, this step produces the value 0).\n    let f = ToInteger(realm, fractionDigits);\n\n    // 2. If f < 0 or f > 20, throw a RangeError exception.\n    if (f < 0 || f > 20) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"f < 0 || f > 20\");\n    }\n\n    // 3. Let x be this Number value.\n    let x = thisNumberValue(realm, context).value;\n\n    // 4. If x is NaN, return the String \"NaN\".\n    if (isNaN(x)) return new StringValue(realm, \"NaN\");\n\n    return new StringValue(realm, x.toFixed(f));\n  });\n\n  // ECMA262 20.1.3.4\n  obj.defineNativeMethod(\"toLocaleString\", 0, context => {\n    let x = thisNumberValue(realm, context);\n    if (realm.useAbstractInterpretation) {\n      // The locale is environment-dependent\n      return realm.deriveAbstract(new TypesDomain(StringValue), ValuesDomain.topVal, [x], ([n]) =>\n        buildToLocaleString(realm.preludeGenerator)({\n          VALUE: n,\n        })\n      );\n    } else {\n      return new StringValue(realm, x.toLocaleString());\n    }\n  });\n\n  // ECMA262 20.1.3.5\n  obj.defineNativeMethod(\"toPrecision\", 1, (context, [precision]) => {\n    // 1. Let x be ? thisNumberValue(this value).\n    let num = thisNumberValue(realm, context);\n    // 2. If precision is undefined, return ! ToString(x).\n    if (precision instanceof UndefinedValue) {\n      return new StringValue(realm, ToString(realm, num));\n    }\n    // 3. Let p be ? ToInteger(precision).\n    let p = ToInteger(realm, precision.throwIfNotConcrete());\n    // 4. If x is NaN, return the String \"NaN\".\n    let x = num.value;\n    if (isNaN(x)) {\n      return new StringValue(realm, \"NaN\");\n    }\n    // 5. Let s be the empty String.\n    let s = \"\";\n    // 6. If x < 0, then\n    if (x < 0) {\n      // a. Let s be code unit 0x002D (HYPHEN-MINUS).\n      s = \"-\";\n      // b. Let x be -x.\n      x = -x;\n    }\n    // 7. If x = +∞, then\n    if (x === +Infinity) {\n      // a. Return the String that is the concatenation of s and \"Infinity\".\n      return new StringValue(realm, s + \"Infinity\");\n    }\n    // 8. If p < 1 or p > 21, throw a RangeError exception.\n    // However, an implementation is permitted to extend the behaviour of\n    // toPrecision for values of p less than 1 or greater than 21.\n    // In this case toPrecision would not necessarily throw RangeError for such\n    // values.\n    if (p < 1 || p > 21) {\n      // for simplicity, throw the error\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"p should be in between 1 and 21 inclusive\");\n    }\n    return new StringValue(realm, s + x.toPrecision(p));\n  });\n\n  // ECMA262 20.1.3.6\n  obj.defineNativeMethod(\"toString\", 1, (context, [radix]) => {\n    if (radix instanceof UndefinedValue) {\n      const target = context instanceof ObjectValue ? context.$NumberData : context;\n      if (target instanceof AbstractValue && target.getType() === NumberValue) {\n        const codeTemplate = \"(A).toString()\";\n        return realm.createAbstract(new TypesDomain(StringValue), ValuesDomain.topVal, [target], ([a]) =>\n          buildExpressionTemplate(codeTemplate)(realm.preludeGenerator)({ A: a })\n        );\n      }\n    }\n    // 1. Let x be ? thisNumberValue(this value).\n    let x = thisNumberValue(realm, context);\n\n    // 2. If radix is not present, let radixNumber be 10.\n    // 3. Else if radix is undefined, let radixNumber be 10.\n    let radixNumber;\n    if (!radix || radix instanceof UndefinedValue) {\n      radixNumber = 10;\n    } else {\n      // 4. Else let radixNumber be ? ToInteger(radix).\n      radixNumber = ToInteger(realm, radix.throwIfNotConcrete());\n    }\n\n    // 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.\n    if (radixNumber < 2 || radixNumber > 36) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. If radixNumber = 10, return ! ToString(x).\n    if (radixNumber === 10) return new StringValue(realm, ToString(realm, x));\n\n    // 7. Return the String representation of this Number value using the radix specified by radixNumber.\n    //    Letters a-z are used for digits with values 10 through 35. The precise algorithm is\n    //    implementation-dependent, however the algorithm should be a generalization of that specified in\n    //    7.1.12.1.\n    return new StringValue(realm, x.value.toString(radixNumber));\n  });\n\n  // ECMA262 20.1.3.7\n  obj.defineNativeMethod(\"valueOf\", 0, context => {\n    // 1. Return ? thisNumberValue(this value).\n    return thisNumberValue(realm, context);\n  });\n}\n"]}