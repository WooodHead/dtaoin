{"version":3,"sources":["../../../src/intrinsics/prepack/global.js"],"names":["realm","global","$GlobalObject","$DefineOwnProperty","value","context","args","console","log","map","arg","serialize","writable","enumerable","configurable","parseTypeNameOrTemplate","typeNameOrTemplate","undefined","type","template","typeNameString","getTypeFromName","createErrorThrowCompletion","intrinsics","TypeError","isTypeCompatibleWith","ObjectPrototype","name","useAbstractInterpretation","nameString","buildNode","locString","contextStack","slice","reverse","executionContext","caller","function","lexicalEnvironment","loc","buildThrowErrorAbstractValue","preludeGenerator","LOCATION","t","stringLiteral","types","values","Set","topVal","result","createAbstract","makePartial","generator","rebuildNestedProperties","deriveNativeFunctionValue","unsafe","f","constructor","isResidual","isUnsafeResidual","deriveAbstract","concat","callExpression","nodes","_buildNode","object","$Realm","makeSimple","propertyName","invariantOptions","key","condition","objectNode","valueNode","binaryExpression","memberExpression","identifier","invariantOptionString","valueToNode","emitInvariant","objnode","$Set","intrinsicName","rebuildObjectProperty","__IntrospectionError"],"mappings":"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","file":"global.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  Value,\n  StringValue,\n  BooleanValue,\n  ObjectValue,\n  FunctionValue,\n  NativeFunctionValue,\n  AbstractValue,\n  AbstractObjectValue,\n  UndefinedValue,\n} from \"../../values/index.js\";\nimport { ToStringPartial } from \"../../methods/index.js\";\nimport { ObjectCreate } from \"../../methods/index.js\";\nimport { TypesDomain, ValuesDomain } from \"../../domains/index.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeExpression, BabelNodeSpreadElement, BabelNodeIdentifier } from \"babel-types\";\nimport invariant from \"../../invariant.js\";\nimport { describeLocation } from \"../ecma262/Error.js\";\n\nlet buildThrowErrorAbstractValue = buildExpressionTemplate(\n  \"(function(){throw new global.Error('abstract value defined at ' + LOCATION);})()\"\n);\n\nexport default function(realm: Realm): void {\n  let global = realm.$GlobalObject;\n\n  global.$DefineOwnProperty(\"dump\", {\n    value: new NativeFunctionValue(realm, \"global.dump\", \"dump\", 0, (context, args) => {\n      console.log(\"dump\", args.map(arg => arg.serialize()));\n      return context;\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  function parseTypeNameOrTemplate(typeNameOrTemplate): { type: typeof Value, template: void | ObjectValue } {\n    if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof UndefinedValue) {\n      return { type: Value, template: undefined };\n    } else if (typeNameOrTemplate instanceof StringValue) {\n      let typeNameString = ToStringPartial(realm, typeNameOrTemplate);\n      let type = Value.getTypeFromName(typeNameString);\n      if (type === undefined) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n      }\n      return {\n        type,\n        template: Value.isTypeCompatibleWith(type, ObjectValue)\n          ? ObjectCreate(realm, realm.intrinsics.ObjectPrototype)\n          : undefined,\n      };\n    } else if (typeNameOrTemplate instanceof FunctionValue) {\n      return { type: FunctionValue, template: typeNameOrTemplate };\n    } else if (typeNameOrTemplate instanceof ObjectValue) {\n      return { type: ObjectValue, template: typeNameOrTemplate };\n    } else {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"typeNameOrTemplate has unsupported type\");\n    }\n  }\n\n  // Helper function to model values that are obtained from the environment,\n  // and whose concrete values are not known at Prepack-time.\n  // __abstract(typeNameOrTemplate, name, options) creates a new abstract value\n  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.\n  // If the abstract value gets somehow embedded in the final heap,\n  // it will be referred to by the supplied name in the generated code.\n  global.$DefineOwnProperty(\"__abstract\", {\n    value: new NativeFunctionValue(\n      realm,\n      \"global.__abstract\",\n      \"__abstract\",\n      0,\n      (context, [typeNameOrTemplate, name]) => {\n        if (!realm.useAbstractInterpretation) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n        }\n\n        let { type, template } = parseTypeNameOrTemplate(typeNameOrTemplate);\n\n        let nameString = name ? ToStringPartial(realm, name) : \"\";\n        let buildNode;\n        if (nameString === \"\") {\n          let locString;\n          for (let executionContext of realm.contextStack.slice().reverse()) {\n            let caller = executionContext.caller;\n            locString = describeLocation(\n              realm,\n              caller ? caller.function : undefined,\n              caller ? caller.lexicalEnvironment : undefined,\n              executionContext.loc\n            );\n            if (locString !== undefined) break;\n          }\n\n          buildNode = () =>\n            buildThrowErrorAbstractValue(realm.preludeGenerator)({\n              LOCATION: t.stringLiteral(locString || \"(unknown location)\"),\n            });\n        } else {\n          buildNode = buildExpressionTemplate(nameString)(realm.preludeGenerator);\n        }\n\n        let types = new TypesDomain(type);\n        let values = template ? new ValuesDomain(new Set([template])) : ValuesDomain.topVal;\n        let result = realm.createAbstract(types, values, [], buildNode, undefined, nameString);\n        if (template && !(template instanceof FunctionValue)) {\n          // why exclude functions?\n          template.makePartial();\n          invariant(realm.generator);\n          if (nameString) realm.rebuildNestedProperties(result, nameString);\n        }\n        return result;\n      }\n    ),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // Maps from initialized moduleId to exports object\n  global.$DefineOwnProperty(\"__initializedModules\", {\n    value: new ObjectValue(realm),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // Helper function used to instatiate a residual function\n  function deriveNativeFunctionValue(unsafe: boolean): NativeFunctionValue {\n    return new NativeFunctionValue(\n      realm,\n      \"global.__residual\",\n      \"__residual\",\n      2,\n      (context, [typeNameOrTemplate, f, ...args]) => {\n        if (!realm.useAbstractInterpretation) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n        }\n\n        let { type, template } = parseTypeNameOrTemplate(typeNameOrTemplate);\n\n        if (!Value.isTypeCompatibleWith(f.constructor, FunctionValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"cannot determine residual function\");\n        }\n        invariant(f instanceof FunctionValue);\n        f.isResidual = true;\n        if (unsafe) f.isUnsafeResidual = true;\n        let types = new TypesDomain(type);\n        let values = template ? new ValuesDomain(new Set([template])) : ValuesDomain.topVal;\n        let result = realm.deriveAbstract(types, values, [f].concat(args), nodes =>\n          t.callExpression(nodes[0], ((nodes.slice(1): any): Array<BabelNodeExpression | BabelNodeSpreadElement>))\n        );\n        if (template) {\n          invariant(\n            result instanceof AbstractValue,\n            \"the nested properties should only be rebuilt for an abstract value\"\n          );\n          template.makePartial();\n          invariant(realm.generator);\n          realm.rebuildNestedProperties(result, ((result._buildNode: any): BabelNodeIdentifier).name);\n        }\n        return result;\n      }\n    );\n  }\n\n  // Helper function that identifies a computation that must remain part of the residual program and cannot be partially evaluated,\n  // e.g. because it contains a loop over abstract values.\n  // __residual(typeNameOrTemplate, function, arg0, arg1, ...) creates a new abstract value\n  // that is computed by invoking function(arg0, arg1, ...) in the residual program and\n  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.\n  // The function must not have side effects, and it must not access any state (besides the supplied arguments).\n  // TODO: In some distant future, Prepack should be able to figure out automatically what computations need to remain part of the residual program.\n  global.$DefineOwnProperty(\"__residual\", {\n    value: deriveNativeFunctionValue(false),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // Helper function that identifies a variant of the residual function that has implicit dependencies. This version of residual will infer the dependencies\n  // and rewrite the function body to do the same thing as the orignal residual function.\n  global.$DefineOwnProperty(\"__residual_unsafe\", {\n    value: deriveNativeFunctionValue(true),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // TODO: Remove this property. It's just here as some existing internal test cases assume that the __annotate property is exists and is readable.\n  global.$DefineOwnProperty(\"__annotate\", {\n    value: realm.intrinsics.undefined,\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // Internal helper function for tests.\n  // __isAbstract(value) checks if a given value is abstract.\n  global.$DefineOwnProperty(\"__isAbstract\", {\n    value: new NativeFunctionValue(realm, \"global.__isAbstract\", \"__isAbstract\", 1, (context, [value]) => {\n      return new BooleanValue(realm, value instanceof AbstractValue);\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // __makePartial(object) marks an (abstract) object as partial.\n  global.$DefineOwnProperty(\"__makePartial\", {\n    value: new NativeFunctionValue(realm, \"global.__makePartial\", \"__isPartial\", 1, (context, [object]) => {\n      // casting to any to avoid Flow bug\n      if ((object: any) instanceof AbstractObjectValue || (object: any) instanceof ObjectValue) {\n        (object: any).makePartial();\n        return context.$Realm.intrinsics.undefined;\n      }\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an (abstract) object\");\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // __makeSimple(object) marks an (abstract) object as one that has no getters or setters.\n  global.$DefineOwnProperty(\"__makeSimple\", {\n    value: new NativeFunctionValue(realm, \"global.__makeSimple\", \"__makeSimple\", 1, (context, [object]) => {\n      // casting to any to avoid Flow bug\n      if ((object: any) instanceof AbstractObjectValue || (object: any) instanceof ObjectValue) {\n        (object: any).makeSimple();\n        return context.$Realm.intrinsics.undefined;\n      }\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an (abstract) object\");\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // Helper function that emits a check whether a given object property has a particular value.\n  global.$DefineOwnProperty(\"__assumeDataProperty\", {\n    value: new NativeFunctionValue(\n      realm,\n      \"global.__assumeDataProperty\",\n      \"__assumeDataProperty\",\n      3,\n      (context, [object, propertyName, value, invariantOptions]) => {\n        if (!realm.useAbstractInterpretation) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n        }\n\n        let key = ToStringPartial(realm, propertyName);\n\n        // casting to any to avoid Flow bug \"*** Recursion limit exceeded ***\"\n        if ((object: any) instanceof AbstractObjectValue || (object: any) instanceof ObjectValue) {\n          let generator = realm.generator;\n          invariant(generator);\n          let condition = ([objectNode, valueNode]) =>\n            t.binaryExpression(\"!==\", t.memberExpression(objectNode, t.identifier(key)), valueNode);\n          if (invariantOptions) {\n            let invariantOptionString = ToStringPartial(realm, invariantOptions);\n            switch (invariantOptionString) {\n              case \"VALUE_DEFINED_INVARIANT\":\n                condition = ([objectNode, valueNode]) =>\n                  t.binaryExpression(\n                    \"===\",\n                    t.memberExpression(objectNode, t.identifier(key)),\n                    t.valueToNode(undefined)\n                  );\n                break;\n              case \"SKIP_INVARIANT\":\n                condition = null;\n                break;\n              case \"FULL_INVARIANT\":\n                break;\n              default:\n                invariant(false, \"Invalid invariantOption \" + invariantOptionString);\n            }\n          }\n          if (condition)\n            generator.emitInvariant([object, value, object], condition, objnode =>\n              t.memberExpression(objnode, t.identifier(key))\n            );\n          realm.generator = undefined; // don't emit code during the following $Set call\n          // casting to due to Flow workaround above\n          (object: any).$Set(key, value, object);\n          realm.generator = generator;\n          if (object.intrinsicName) realm.rebuildObjectProperty(object, key, value, object.intrinsicName);\n          return context.$Realm.intrinsics.undefined;\n        }\n\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an (abstract) object\");\n      }\n    ),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  global.$DefineOwnProperty(\"__IntrospectionError\", {\n    value: realm.intrinsics.__IntrospectionError,\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n}\n"]}