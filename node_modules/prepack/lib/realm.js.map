{"version":3,"sources":["../src/realm.js"],"names":["construct_empty_effects","t","Tracer","state","effects","F","thisArgument","argumentsList","newTarget","performCall","result","ExecutionContext","context","caller","isStrict","$Strict","function","loc","realm","value","oldReadOnly","isReadOnly","variableEnvironment","environmentRecord","lexicalEnvironment","intrinsics","undefined","empty","Map","Set","Realm","opts","contextStack","MOBILE_JSC_VERSION","useAbstractInterpretation","serialize","residual","mathRandomSeed","mathRandomGenerator","strictlyMonotonicDateNow","timeout","timeoutCounter","timeoutCounterThreshold","start","Date","now","compatibility","$TemplateMap","preludeGenerator","debugNames","uniqueSuffix","setupTrackedPropertyAccessors","tracers","$GlobalObject","evaluators","Object","create","partialEvaluators","$GlobalEnv","errorHandler","key","globrec","dclrec","$DeclarativeRecord","HasBinding","GetBindingValue","readOnlyValue","forEach","ctx","setReadOnly","total","length","push","c","pop","savedEffects","getRunningContext","addPriorEffects","callback","pushContext","popContext","name","wrapInGlobalEnv","assignToGlobal","DeleteBinding","ast","strictCode","env","evaluateForEffects","evaluateAbstractCompletion","node","evaluateNodeForEffects","nodeAst","nodeIO","partialEval","partiallyEvaluateCompletionDeref","f","savedContextEffects","getAndResetModifiedMaps","savedBindings","savedProperties","saved_generator","generator","saved_createdObjects","createdObjects","t1","beginEvaluateForEffects","modifiedBindings","modifiedProperties","astGenerator","astBindings","astProperties","astCreatedObjects","updateAbruptCompletions","stopEffectCaptureAndUndoEffects","restoreBindings","restoreProperties","t2","endEvaluateForEffects","priorEffects","subsequentEffects","pc","pg","pb","pp","po","sc","sg","sb","sp","so","clone","appendGenerator","val","m","has","set","desc","propertyBinding","ob","a","add","consequent","consequentEffects","alternate","alternateEffects","v","g","b","p","o","leadingComment","completion","bindings","properties","realmModifiedBindings","realmModifiedProperties","size","realmCreatedObjects","method","args","emitConsoleLog","console","getString","values","res","next","shift","nextString","binding","reportObjectGetOwnProperties","reportPropertyAccess","isNewObject","object","callReportPropertyAccess","descriptor","getElements","some","element","d","types","buildNode","kind","intrinsicName","Constructor","isTypeCompatibleWith","getType","propertyValue","path","isIntrinsic","_buildNode","memberExpression","identifier","rebuildNestedProperties","abstractValue","template","getTemplate","intrinsicNameGenerated","reportIntrospectionError","rebuildObjectProperty","optionalArgs","emitVoidExpression","derive","nextContextLocation","setLocation","message","currentLocation","error","handleError","type","__IntrospectionError","generatorBody","body","realmGenerator","realmGeneratorBody","i","firstEntry","nodes","n","leadingComments","declared","diagnostic","callStack","Error","stack","$Get","msg","errorCode","location","loc_start","loc_end","end","line","column","severity","log","warn"],"mappings":"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","file":"realm.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Intrinsics, PropertyBinding, Descriptor } from \"./types.js\";\nimport { CompilerDiagnostic, type ErrorHandlerResult, type ErrorHandler, FatalError } from \"./errors.js\";\nimport { NativeFunctionValue, ECMAScriptSourceFunctionValue, FunctionValue } from \"./values/index.js\";\nimport {\n  Value,\n  ObjectValue,\n  AbstractValue,\n  AbstractObjectValue,\n  StringValue,\n  ConcreteValue,\n  UndefinedValue,\n} from \"./values/index.js\";\nimport { TypesDomain, ValuesDomain } from \"./domains/index.js\";\nimport { LexicalEnvironment, Reference, GlobalEnvironmentRecord } from \"./environment.js\";\nimport type { Binding } from \"./environment.js\";\nimport { cloneDescriptor, GetValue, Construct, ThrowIfMightHaveBeenDeleted } from \"./methods/index.js\";\nimport type { NormalCompletion } from \"./completions.js\";\nimport { Completion, ThrowCompletion, AbruptCompletion, PossiblyNormalCompletion } from \"./completions.js\";\nimport type { Compatibility, RealmOptions } from \"./options.js\";\nimport invariant from \"./invariant.js\";\nimport seedrandom from \"seedrandom\";\nimport { Generator, PreludeGenerator } from \"./utils/generator.js\";\nimport type {\n  BabelNode,\n  BabelNodeSourceLocation,\n  BabelNodeLVal,\n  BabelNodeStatement,\n  BabelNodeExpression,\n} from \"babel-types\";\nimport type { EnvironmentRecord } from \"./environment.js\";\nimport * as t from \"babel-types\";\nimport { ToString } from \"./methods/to.js\";\n\nexport type Bindings = Map<Binding, void | Value>;\nexport type EvaluationResult = Completion | Reference | Value;\nexport type PropertyBindings = Map<PropertyBinding, void | Descriptor>;\n\nexport type CreatedObjects = Set<ObjectValue | AbstractObjectValue>;\nexport type Effects = [EvaluationResult, Generator, Bindings, PropertyBindings, CreatedObjects];\n\nexport class Tracer {\n  beginEvaluateForEffects(state: any) {}\n  endEvaluateForEffects(state: any, effects: void | Effects) {}\n  detourCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    performCall: () => Value\n  ): void | Value {}\n  beforeCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue\n  ) {}\n  afterCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    result: void | Reference | Value | AbruptCompletion\n  ) {}\n}\n\nexport class ExecutionContext {\n  function: ?FunctionValue;\n  caller: ?ExecutionContext;\n  loc: ?BabelNodeSourceLocation;\n  ScriptOrModule: any;\n  realm: Realm;\n  variableEnvironment: LexicalEnvironment;\n  lexicalEnvironment: LexicalEnvironment;\n  isReadOnly: boolean;\n  isStrict: boolean;\n  savedEffects: void | Effects;\n  savedCompletion: void | PossiblyNormalCompletion;\n\n  setCaller(context: ExecutionContext): void {\n    this.caller = context;\n  }\n\n  setFunction(F: null | FunctionValue) {\n    if (F instanceof ECMAScriptSourceFunctionValue) this.isStrict = F.$Strict;\n    this.function = F;\n  }\n\n  setLocation(loc: null | BabelNodeSourceLocation) {\n    if (!loc) return;\n    this.loc = loc;\n  }\n\n  setRealm(realm: Realm): void {\n    this.realm = realm;\n  }\n\n  /*\n   Read-only envs disallow:\n   - creating bindings in their scope\n   - creating or modifying objects when they are current running context\n  */\n  setReadOnly(value: boolean): boolean {\n    let oldReadOnly = this.isReadOnly;\n    if (this.variableEnvironment) this.variableEnvironment.environmentRecord.isReadOnly = value;\n    if (this.lexicalEnvironment) this.lexicalEnvironment.environmentRecord.isReadOnly = value;\n    this.isReadOnly = value;\n    return oldReadOnly;\n  }\n\n  suspend(): void {\n    // TODO: suspend\n  }\n\n  resume(): Value {\n    // TODO: resume\n    return this.realm.intrinsics.undefined;\n  }\n}\n\nexport function construct_empty_effects(realm: Realm): Effects {\n  return [realm.intrinsics.empty, new Generator(realm), new Map(), new Map(), new Set()];\n}\n\nexport class Realm {\n  constructor(opts: RealmOptions) {\n    this.isReadOnly = false;\n    this.useAbstractInterpretation = !!opts.serialize || !!opts.residual;\n    if (opts.mathRandomSeed !== undefined) {\n      this.mathRandomGenerator = seedrandom(opts.mathRandomSeed);\n    }\n    this.strictlyMonotonicDateNow = !!opts.strictlyMonotonicDateNow;\n\n    this.timeout = opts.timeout;\n    if (this.timeout) {\n      // We'll call Date.now for every this.timeoutCounterThreshold'th AST node.\n      // The threshold is there to reduce the cost of the surprisingly expensive Date.now call.\n      this.timeoutCounter = this.timeoutCounterThreshold = 1024;\n    }\n\n    this.start = Date.now();\n    this.compatibility = opts.compatibility || \"browser\";\n\n    this.$TemplateMap = [];\n\n    if (this.useAbstractInterpretation) {\n      this.preludeGenerator = new PreludeGenerator(opts.debugNames, opts.uniqueSuffix);\n      ObjectValue.setupTrackedPropertyAccessors();\n    }\n\n    this.tracers = [];\n\n    // These get initialized in construct_realm to avoid the dependency\n    this.intrinsics = ({}: any);\n    this.$GlobalObject = (({}: any): ObjectValue);\n    this.evaluators = (Object.create(null): any);\n    this.partialEvaluators = (Object.create(null): any);\n    this.$GlobalEnv = ((undefined: any): LexicalEnvironment);\n\n    this.errorHandler = opts.errorHandler;\n  }\n\n  start: number;\n  isReadOnly: boolean;\n  isStrict: boolean;\n  useAbstractInterpretation: boolean;\n  timeout: void | number;\n  mathRandomGenerator: void | (() => number);\n  strictlyMonotonicDateNow: boolean;\n\n  modifiedBindings: void | Bindings;\n  modifiedProperties: void | PropertyBindings;\n  createdObjects: void | CreatedObjects;\n  reportObjectGetOwnProperties: void | (ObjectValue => void);\n  reportPropertyAccess: void | (PropertyBinding => void);\n\n  currentLocation: ?BabelNodeSourceLocation;\n  nextContextLocation: ?BabelNodeSourceLocation;\n  contextStack: Array<ExecutionContext> = [];\n  $GlobalEnv: LexicalEnvironment;\n  intrinsics: Intrinsics;\n\n  $GlobalObject: ObjectValue | AbstractObjectValue;\n  compatibility: Compatibility;\n\n  $TemplateMap: Array<{ $Strings: Array<string>, $Array: ObjectValue }>;\n\n  generator: void | Generator;\n  preludeGenerator: void | PreludeGenerator;\n  timeoutCounter: number;\n  timeoutCounterThreshold: number;\n  evaluators: {\n    [key: string]: (\n      ast: BabelNode,\n      strictCode: boolean,\n      env: LexicalEnvironment,\n      realm: Realm,\n      metadata?: any\n    ) => NormalCompletion | Value | Reference,\n  };\n  partialEvaluators: {\n    [key: string]: (\n      ast: BabelNode,\n      strictCode: boolean,\n      env: LexicalEnvironment,\n      realm: Realm,\n      metadata?: any\n    ) => [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>],\n  };\n\n  tracers: Array<Tracer>;\n\n  MOBILE_JSC_VERSION = \"jsc-600-1-4-17\";\n\n  errorHandler: ?ErrorHandler;\n\n  // to force flow to type the annotations\n  isCompatibleWith(compatibility: Compatibility): boolean {\n    return compatibility === this.compatibility;\n  }\n\n  // Checks if there is a let binding at global scope with the given name\n  // returning it if so\n  getGlobalLetBinding(key: string): void | Value {\n    let globrec = this.$GlobalEnv.environmentRecord;\n    // GlobalEnv should have a GlobalEnvironmentRecord\n    invariant(globrec instanceof GlobalEnvironmentRecord);\n    let dclrec = globrec.$DeclarativeRecord;\n\n    return dclrec.HasBinding(key) ? dclrec.GetBindingValue(key, false) : undefined;\n  }\n\n  /*\n   Read only realms disallow:\n   - using console.log\n   - creating bindings in any existing scopes\n   - modifying object properties in any existing scopes\n   Setting a realm read-only sets all contained environments to read-only, but\n   all new environments (e.g. new ExecutionContexts) will be writeable.\n   */\n  setReadOnly(readOnlyValue: boolean) {\n    this.isReadOnly = readOnlyValue;\n    this.$GlobalEnv.environmentRecord.isReadOnly = readOnlyValue;\n    this.contextStack.forEach(ctx => {\n      ctx.setReadOnly(readOnlyValue);\n    });\n  }\n\n  testTimeout() {\n    let timeout = this.timeout;\n    if (timeout && !--this.timeoutCounter) {\n      this.timeoutCounter = this.timeoutCounterThreshold;\n      let total = Date.now() - this.start;\n      if (total > timeout) {\n        throw new FatalError(\"Timed out\");\n      }\n    }\n  }\n\n  getRunningContext(): ExecutionContext {\n    let context = this.contextStack[this.contextStack.length - 1];\n    invariant(context, \"There's no running execution context\");\n    return context;\n  }\n\n  pushContext(context: ExecutionContext): void {\n    this.contextStack.push(context);\n  }\n\n  popContext(context: ExecutionContext): void {\n    let c = this.contextStack.pop();\n    invariant(c === context);\n    let savedEffects = context.savedEffects;\n    if (savedEffects !== undefined && this.contextStack.length > 0) {\n      // when unwinding the stack after a fatal error, saved effects are not incorporated into completions\n      // and thus must be propogated to the calling context.\n      let ctx = this.getRunningContext();\n      if (ctx.savedEffects !== undefined) this.addPriorEffects(ctx.savedEffects, savedEffects);\n      ctx.savedEffects = savedEffects;\n    }\n  }\n\n  wrapInGlobalEnv<T>(callback: () => T): T {\n    let context = new ExecutionContext();\n    context.isStrict = this.isStrict;\n    context.lexicalEnvironment = this.$GlobalEnv;\n    context.variableEnvironment = this.$GlobalEnv;\n    context.realm = this;\n\n    this.pushContext(context);\n    try {\n      return callback();\n    } finally {\n      this.popContext(context);\n    }\n  }\n\n  assignToGlobal(name: BabelNodeLVal, value: Value) {\n    this.wrapInGlobalEnv(() => this.$GlobalEnv.assignToGlobal(name, value));\n  }\n\n  deleteGlobalBinding(name: string) {\n    this.$GlobalEnv.environmentRecord.DeleteBinding(name);\n  }\n\n  // Evaluate the given ast in a sandbox and return the evaluation results\n  // in the form of a completion, a code generator, a map of changed variable\n  // bindings and a map of changed property bindings.\n  evaluateNodeForEffects(ast: BabelNode, strictCode: boolean, env: LexicalEnvironment, state?: any): Effects {\n    return this.evaluateForEffects(() => env.evaluateAbstractCompletion(ast, strictCode), state);\n  }\n\n  evaluateNodeForEffectsInGlobalEnv(node: BabelNode, state?: any) {\n    return this.wrapInGlobalEnv(() => this.evaluateNodeForEffects(node, false, this.$GlobalEnv, state));\n  }\n\n  partiallyEvaluateNodeForEffects(\n    ast: BabelNode,\n    strictCode: boolean,\n    env: LexicalEnvironment\n  ): [Effects, BabelNode, Array<BabelNodeStatement>] {\n    let nodeAst, nodeIO;\n    function partialEval() {\n      let result;\n      [result, nodeAst, nodeIO] = env.partiallyEvaluateCompletionDeref(ast, strictCode);\n      return result;\n    }\n    let effects = this.evaluateForEffects(partialEval);\n    invariant(nodeAst !== undefined && nodeIO !== undefined);\n    return [effects, nodeAst, nodeIO];\n  }\n\n  evaluateForEffects(f: () => Completion | Value | Reference, state: any): Effects {\n    // Save old state and set up empty state for ast\n    let context = this.getRunningContext();\n    let savedContextEffects = context.savedEffects;\n    context.savedEffects = undefined;\n    let [savedBindings, savedProperties] = this.getAndResetModifiedMaps();\n    let saved_generator = this.generator;\n    let saved_createdObjects = this.createdObjects;\n    this.generator = new Generator(this);\n    this.createdObjects = new Set();\n\n    for (let t1 of this.tracers) t1.beginEvaluateForEffects(state);\n\n    let c;\n    let result;\n    try {\n      c = f();\n      if (c instanceof Reference) c = GetValue(this, c);\n\n      invariant(this.generator !== undefined);\n      invariant(this.modifiedBindings !== undefined);\n      invariant(this.modifiedProperties !== undefined);\n      invariant(this.createdObjects !== undefined);\n      let astGenerator = this.generator;\n      let astBindings = this.modifiedBindings;\n      let astProperties = this.modifiedProperties;\n      let astCreatedObjects = this.createdObjects;\n\n      // Return the captured state changes and evaluation result\n      result = [c, astGenerator, astBindings, astProperties, astCreatedObjects];\n      if (c instanceof PossiblyNormalCompletion) {\n        let savedEffects = context.savedEffects;\n        if (savedEffects !== undefined) {\n          // add prior effects that are not already present\n          this.addPriorEffects(savedEffects, result);\n          this.updateAbruptCompletions(savedEffects, c);\n          context.savedEffects = undefined;\n        }\n      }\n      return result;\n    } finally {\n      // Roll back the state changes\n      if (context.savedEffects !== undefined) {\n        this.stopEffectCaptureAndUndoEffects();\n      }\n      this.restoreBindings(this.modifiedBindings);\n      this.restoreProperties(this.modifiedProperties);\n      context.savedEffects = savedContextEffects;\n      this.generator = saved_generator;\n      this.modifiedBindings = savedBindings;\n      this.modifiedProperties = savedProperties;\n      this.createdObjects = saved_createdObjects;\n\n      for (let t2 of this.tracers) t2.endEvaluateForEffects(state, result);\n    }\n  }\n\n  addPriorEffects(priorEffects: Effects, subsequentEffects: Effects) {\n    let [pc, pg, pb, pp, po] = priorEffects;\n    let [sc, sg, sb, sp, so] = subsequentEffects;\n\n    pc;\n    sc;\n\n    let saved_generator = this.generator;\n    this.generator = pg.clone();\n    this.appendGenerator(sg);\n    subsequentEffects[1] = pg;\n    this.generator = saved_generator;\n\n    pb.forEach((val, key, m) => {\n      if (!sb.has(key)) sb.set(key, val);\n    });\n\n    pp.forEach((desc, propertyBinding, m) => {\n      if (!sp.has(propertyBinding)) sp.set(propertyBinding, desc);\n    });\n\n    po.forEach((ob, a) => {\n      so.add(ob);\n    });\n  }\n\n  updateAbruptCompletions(priorEffects: Effects, c: PossiblyNormalCompletion) {\n    if (c.consequent instanceof AbruptCompletion) {\n      this.addPriorEffects(priorEffects, c.consequentEffects);\n      let alternate = c.alternate;\n      if (alternate instanceof PossiblyNormalCompletion) this.updateAbruptCompletions(priorEffects, alternate);\n    } else {\n      invariant(c.alternate instanceof AbruptCompletion);\n      this.addPriorEffects(priorEffects, c.alternateEffects);\n      let consequent = c.consequent;\n      if (consequent instanceof PossiblyNormalCompletion) this.updateAbruptCompletions(priorEffects, consequent);\n    }\n  }\n\n  captureEffects() {\n    let context = this.getRunningContext();\n    if (context.savedEffects !== undefined) {\n      // Already called captureEffects in this context, just carry on\n      return;\n    }\n    context.savedEffects = [\n      this.intrinsics.undefined,\n      this.generator,\n      this.modifiedBindings,\n      this.modifiedProperties,\n      this.createdObjects,\n    ];\n    this.generator = new Generator(this);\n    this.modifiedBindings = new Map();\n    this.modifiedProperties = new Map();\n    this.createdObjects = new Set();\n  }\n\n  getCapturedEffects(v?: Value): void | Effects {\n    let context = this.getRunningContext();\n    if (context.savedEffects === undefined) return undefined;\n    if (v === undefined) v = this.intrinsics.undefined;\n    invariant(this.generator !== undefined);\n    invariant(this.modifiedBindings !== undefined);\n    invariant(this.modifiedProperties !== undefined);\n    invariant(this.createdObjects !== undefined);\n    return [v, this.generator, this.modifiedBindings, this.modifiedProperties, this.createdObjects];\n  }\n\n  stopEffectCaptureAndUndoEffects() {\n    // Roll back the state changes\n    this.restoreBindings(this.modifiedBindings);\n    this.restoreProperties(this.modifiedProperties);\n\n    // Restore saved state\n    let context = this.getRunningContext();\n    if (context.savedEffects !== undefined) {\n      let [c, g, b, p, o] = context.savedEffects;\n      c;\n      context.savedEffects = undefined;\n      this.generator = g;\n      this.modifiedBindings = b;\n      this.modifiedProperties = p;\n      this.createdObjects = o;\n    }\n  }\n\n  // Apply the given effects to the global state\n  applyEffects(effects: Effects, leadingComment: string = \"\") {\n    let [completion, generator, bindings, properties, createdObjects] = effects;\n\n    // ignore completion\n    completion;\n\n    // Add generated code for property modifications\n    this.appendGenerator(generator, leadingComment);\n\n    // Restore bindings\n    this.restoreBindings(bindings);\n    this.restoreProperties(properties);\n\n    // track bindings\n    let realmModifiedBindings = this.modifiedBindings;\n    if (realmModifiedBindings !== undefined) {\n      bindings.forEach((val, key, m) => {\n        invariant(realmModifiedBindings !== undefined);\n        if (!realmModifiedBindings.has(key)) {\n          realmModifiedBindings.set(key, val);\n        }\n      });\n    }\n    let realmModifiedProperties = this.modifiedProperties;\n    if (realmModifiedProperties !== undefined) {\n      properties.forEach((desc, propertyBinding, m) => {\n        invariant(realmModifiedProperties !== undefined);\n        if (!realmModifiedProperties.has(propertyBinding)) {\n          realmModifiedProperties.set(propertyBinding, desc);\n        }\n      });\n    }\n\n    // add created objects\n    if (createdObjects.size > 0) {\n      let realmCreatedObjects = this.createdObjects;\n      if (realmCreatedObjects === undefined) this.createdObjects = new Set(createdObjects);\n      else {\n        createdObjects.forEach((ob, a) => {\n          invariant(realmCreatedObjects !== undefined);\n          realmCreatedObjects.add(ob);\n        });\n      }\n    }\n  }\n\n  outputToConsole(method: \"log\" | \"warn\" | \"error\", args: Array<string | ConcreteValue>): void {\n    if (this.isReadOnly) {\n      // This only happens during speculative execution and is reported elsewhere\n      throw new FatalError(\"Trying to create console output in read-only realm\");\n    }\n    if (this.useAbstractInterpretation) {\n      invariant(this.generator !== undefined);\n      this.generator.emitConsoleLog(method, args);\n    } else {\n      console[method](getString(this, args));\n    }\n\n    function getString(realm: Realm, values: Array<string | ConcreteValue>) {\n      let res = \"\";\n      while (values.length) {\n        let next = values.shift();\n        let nextString = ToString(realm, next);\n        res += nextString;\n      }\n      return res;\n    }\n  }\n\n  // Record the current value of binding in this.modifiedBindings unless\n  // there is already an entry for binding.\n  recordModifiedBinding(binding: Binding, env: EnvironmentRecord): Binding {\n    if (env.isReadOnly) {\n      // This only happens during speculative execution and is reported elsewhere\n      throw new FatalError(\"Trying to modify a binding in read-only realm\");\n    }\n    if (this.modifiedBindings !== undefined && !this.modifiedBindings.has(binding))\n      this.modifiedBindings.set(binding, binding.value);\n    return binding;\n  }\n\n  callReportObjectGetOwnProperties(ob: ObjectValue): void {\n    if (this.reportObjectGetOwnProperties !== undefined) {\n      this.reportObjectGetOwnProperties(ob);\n    }\n  }\n\n  callReportPropertyAccess(binding: PropertyBinding): void {\n    if (this.reportPropertyAccess !== undefined) {\n      this.reportPropertyAccess(binding);\n    }\n  }\n\n  // Record the current value of binding in this.modifiedProperties unless\n  // there is already an entry for binding.\n  recordModifiedProperty(binding: PropertyBinding): void {\n    if (this.isReadOnly && (this.getRunningContext().isReadOnly || !this.isNewObject(binding.object))) {\n      // This only happens during speculative execution and is reported elsewhere\n      throw new FatalError(\"Trying to modify a property in read-only realm\");\n    }\n    this.callReportPropertyAccess(binding);\n    if (this.modifiedProperties !== undefined && !this.modifiedProperties.has(binding)) {\n      this.modifiedProperties.set(binding, cloneDescriptor(binding.descriptor));\n    }\n  }\n\n  isNewObject(object: AbstractObjectValue | ObjectValue): boolean {\n    if (object instanceof AbstractObjectValue) {\n      let realm = this;\n      return object.values.getElements().some(element => realm.isNewObject(element));\n    }\n    return this.createdObjects === undefined || this.createdObjects.has(object);\n  }\n\n  recordNewObject(object: ObjectValue): void {\n    if (this.createdObjects !== undefined) {\n      this.createdObjects.add(object);\n    }\n  }\n\n  // Returns the current values of modifiedBindings and modifiedProperties\n  // and then assigns new empty maps to them.\n  getAndResetModifiedMaps(): [void | Bindings, void | PropertyBindings] {\n    let result = [this.modifiedBindings, this.modifiedProperties];\n    this.modifiedBindings = new Map();\n    this.modifiedProperties = new Map();\n    return result;\n  }\n\n  // Restores each Binding in the given map to the value it\n  // had when it was entered into the map and updates the map to record\n  // the value the Binding had just before the call to this method.\n  restoreBindings(modifiedBindings: void | Bindings) {\n    if (modifiedBindings === undefined) return;\n    modifiedBindings.forEach((val, key, m) => {\n      let v = key.value;\n      key.value = val;\n      m.set(key, v);\n    });\n  }\n\n  // Restores each PropertyBinding in the given map to the value it\n  // had when it was entered into the map and updates the map to record\n  // the value the Binding had just before the call to this method.\n  restoreProperties(modifiedProperties: void | PropertyBindings) {\n    if (modifiedProperties === undefined) return;\n    modifiedProperties.forEach((desc, propertyBinding, m) => {\n      let d = propertyBinding.descriptor;\n      propertyBinding.descriptor = desc;\n      m.set(propertyBinding, d);\n    });\n  }\n\n  // Provide the realm with maps in which to track modifications.\n  // A map can be set to undefined if no tracking is required.\n  setModifiedMaps(modifiedBindings: void | Bindings, modifiedProperties: void | PropertyBindings) {\n    this.modifiedBindings = modifiedBindings;\n    this.modifiedProperties = modifiedProperties;\n  }\n\n  // Create a state-less abstract value.\n  // NOTE: `buildNode` MUST NOT create an AST which may mutate or access mutable state! Use `deriveAbstract` for that purpose.\n  createAbstract(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode: ((Array<BabelNodeExpression>) => BabelNodeExpression) | BabelNodeExpression,\n    kind?: string,\n    intrinsicName?: string\n  ) {\n    invariant(this.useAbstractInterpretation);\n    let Constructor = Value.isTypeCompatibleWith(types.getType(), ObjectValue) ? AbstractObjectValue : AbstractValue;\n    return new Constructor(this, types, values, args, buildNode, { kind, intrinsicName });\n  }\n\n  rebuildObjectProperty(object: Value, key: string, propertyValue: Value, path: string) {\n    if (!(propertyValue instanceof AbstractValue)) return;\n    if (!propertyValue.isIntrinsic()) {\n      propertyValue.intrinsicName = `${path}.${key}`;\n      propertyValue.args = [object];\n      propertyValue._buildNode = ([node]) => t.memberExpression(node, t.identifier(key));\n      this.rebuildNestedProperties(propertyValue, propertyValue.intrinsicName);\n    }\n  }\n\n  rebuildNestedProperties(abstractValue: AbstractValue | UndefinedValue, path: string) {\n    if (!(abstractValue instanceof AbstractObjectValue)) return;\n    let template = abstractValue.getTemplate();\n    invariant(!template.intrinsicName || template.intrinsicName === path);\n    // TODO #882: We are using the concept of \"intrinsic values\" to mark the template\n    // object as intrinsic, so that we'll never emit code that creates it, as it instead is mapConstructorDoesntTakeArguments\n    // to refer to an unknown but existing object.\n    // However, it's not really an intrinsic object, and it might not exist ahead of time, but only starting\n    // from this point on, which might be tied to some nested generator.\n    // Which we currently don't track, and that needs to get fixed.\n    // For now, we use intrinsicNameGenerated to mark this case.\n    template.intrinsicName = path;\n    template.intrinsicNameGenerated = true;\n    for (let [key, binding] of template.properties) {\n      if (binding === undefined || binding.descriptor === undefined) continue; // deleted\n      invariant(binding.descriptor !== undefined);\n      let value = binding.descriptor.value;\n      ThrowIfMightHaveBeenDeleted(value);\n      if (value === undefined) {\n        AbstractValue.reportIntrospectionError(abstractValue, key);\n        throw new FatalError();\n      }\n      this.rebuildObjectProperty(abstractValue, key, value, path);\n    }\n  }\n\n  // Create a an abstract value in a way that may observe or mutate state.\n  // NOTE: If the state that is observed or mutated by the AST generated by `buildNode` is also represented in some form in the interpreter,\n  // i.e. not just external state, then the caller must make sure that all relevant interpreter state is updated correspondingly.\n  deriveAbstract(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode: ((Array<BabelNodeExpression>) => BabelNodeExpression) | BabelNodeExpression,\n    optionalArgs?: {| kind?: string, isPure?: boolean, skipInvariant?: boolean |}\n  ): AbstractValue | UndefinedValue {\n    invariant(this.useAbstractInterpretation);\n    let generator = this.generator;\n    invariant(generator);\n    if (types.getType() === UndefinedValue) {\n      return generator.emitVoidExpression(types, values, args, buildNode);\n    } else {\n      return generator.derive(types, values, args, buildNode, optionalArgs);\n    }\n  }\n\n  createExecutionContext(): ExecutionContext {\n    let context = new ExecutionContext();\n\n    let loc = this.nextContextLocation;\n    if (loc) {\n      context.setLocation(loc);\n      this.nextContextLocation = null;\n    }\n\n    return context;\n  }\n\n  setNextExecutionContextLocation(loc: ?BabelNodeSourceLocation) {\n    if (!loc) return;\n\n    //if (this.nextContextLocation) {\n    //  throw new ThrowCompletion(\n    //    Construct(this, this.intrinsics.TypeError, [new StringValue(this, \"Already have a context location that we haven't used yet\")])\n    //  );\n    //} else {\n    this.nextContextLocation = loc;\n    //}\n  }\n\n  reportIntrospectionError(message?: void | string | StringValue) {\n    if (message === undefined) message = \"TODO\";\n    if (typeof message === \"string\") message = new StringValue(this, message);\n    invariant(message instanceof StringValue);\n    this.nextContextLocation = this.currentLocation;\n    let error = new CompilerDiagnostic(message.value, this.currentLocation, \"PP0001\", \"FatalError\");\n    this.handleError(error);\n  }\n\n  createErrorThrowCompletion(type: NativeFunctionValue, message?: void | string | StringValue): ThrowCompletion {\n    invariant(type !== this.intrinsics.__IntrospectionError);\n    if (message === undefined) message = \"TODO\";\n    if (typeof message === \"string\") message = new StringValue(this, message);\n    invariant(message instanceof StringValue);\n    this.nextContextLocation = this.currentLocation;\n    return new ThrowCompletion(Construct(this, type, [message]), this.currentLocation);\n  }\n\n  appendGenerator(generator: Generator, leadingComment: string = \"\"): void {\n    let generatorBody = generator.body;\n    let realmGenerator = this.generator;\n    if (realmGenerator === undefined) {\n      invariant(generatorBody.length === 0);\n      return;\n    }\n    let realmGeneratorBody = realmGenerator.body;\n    let i = 0;\n    if (generatorBody.length > 0 && leadingComment.length > 0) {\n      let firstEntry = generatorBody[i++];\n      let buildNode = (nodes, f) => {\n        let n = firstEntry.buildNode(nodes, f);\n        n.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n        return n;\n      };\n      realmGeneratorBody.push({\n        declared: firstEntry.declared,\n        args: firstEntry.args,\n        buildNode: buildNode,\n      });\n    }\n    for (; i < generatorBody.length; i++) realmGeneratorBody.push(generatorBody[i]);\n  }\n\n  // Pass the error to the realm's error-handler\n  // Return value indicates whether the caller should try to recover from the\n  // error or not ('true' means recover if possible).\n  handleError(diagnostic: CompilerDiagnostic): ErrorHandlerResult {\n    if (!diagnostic.callStack && this.contextStack.length > 0) {\n      let error = Construct(this, this.intrinsics.Error);\n      let stack = error.$Get(\"stack\", error);\n      if (stack instanceof StringValue) diagnostic.callStack = stack.value;\n    }\n    // Default behaviour is to bail on the first error\n    let errorHandler = this.errorHandler;\n    if (!errorHandler) {\n      let msg = `${diagnostic.errorCode}: ${diagnostic.message}`;\n      if (diagnostic.location) {\n        let loc_start = diagnostic.location.start;\n        let loc_end = diagnostic.location.end;\n        msg += ` at ${loc_start.line}:${loc_start.column} to ${loc_end.line}:${loc_end.column}`;\n      }\n      switch (diagnostic.severity) {\n        case \"Information\":\n          console.log(`Info: ${msg}`);\n          return \"Recover\";\n        case \"Warning\":\n          console.warn(`Warn: ${msg}`);\n          return \"Recover\";\n        case \"RecoverableError\":\n          console.error(`Error: ${msg}`);\n          return \"Fail\";\n        case \"FatalError\":\n          console.error(`Fatal Error: ${msg}`);\n          return \"Fail\";\n        default:\n          invariant(false, \"Unexpected error type\");\n      }\n    }\n    return errorHandler(diagnostic);\n  }\n}\n"]}