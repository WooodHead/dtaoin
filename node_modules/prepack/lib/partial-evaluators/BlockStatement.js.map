{"version":3,"sources":["../../src/partial-evaluators/BlockStatement.js"],"names":["ast","strictCode","env","realm","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","body","blockValue","directives","directive","value","res","bAst","length","t","emptyStatement","rAst","blockStatement"],"mappings":";;;;;;ypBAAA;;;;;;;;;AA0BA;;;kBACe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKwD;AACrE;AACA,MAAIC,SAASD,MAAME,iBAAN,GAA0BC,kBAAvC;;AAEA;AACA,MAAIC,WAAW,uCAA0BJ,KAA1B,EAAiCC,MAAjC,CAAf;;AAEA;AACA,6CAA8BD,KAA9B,EAAqCF,UAArC,EAAiDD,IAAIQ,IAArD,EAA2DD,QAA3D;;AAEA;AACAJ,QAAME,iBAAN,GAA0BC,kBAA1B,GAA+CC,QAA/C;;AAEA,MAAI;AACF;AACA,QAAIE,mBAAJ;;AAEA,QAAIT,IAAIU,UAAR,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,6BAAsBV,IAAIU,UAA1B,8HAAsC;AAAA,cAA7BC,SAA6B;;AACpCF,uBAAa,uBAAgBN,KAAhB,EAAuBQ,UAAUC,KAAV,CAAgBA,KAAvC,CAAb;AACD;AAHiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAInB;;AARC,gCAUgB,yCAA4BZ,IAAIQ,IAAhC,EAAsCC,UAAtC,EAAkDR,UAAlD,EAA8DM,QAA9D,EAAwEJ,KAAxE,CAVhB;AAAA;AAAA,QAUGU,GAVH;AAAA,QAUQC,IAVR;;AAWF,6BAAUA,KAAKC,MAAL,GAAc,CAAd,IAAmBF,gCAA7B;AACA,QAAIC,KAAKC,MAAL,KAAgB,CAApB,EAAuB,OAAO,CAACF,GAAD,EAAMG,EAAEC,cAAF,EAAN,EAA0B,EAA1B,CAAP;AACvB,QAAIC,OAAOF,EAAEG,cAAF,CAAiBL,IAAjB,EAAuBd,IAAIU,UAA3B,CAAX;AACA,WAAO,CAACG,GAAD,EAAMK,IAAN,EAAY,EAAZ,CAAP;AACD,GAfD,SAeU;AACR;AACAf,UAAME,iBAAN,GAA0BC,kBAA1B,GAA+CF,MAA/C;AACD;AACF,C;;AAjDD;;AACA;;AACA;;AAMA;;;;AACA;;IAAYY,C","file":"BlockStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeBlockStatement, BabelNodeStatement } from \"babel-types\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\n\nimport { Completion, NormalCompletion } from \"../completions.js\";\nimport { EmptyValue, StringValue, Value } from \"../values/index.js\";\nimport {\n  BlockDeclarationInstantiation,\n  NewDeclarativeEnvironment,\n  PartiallyEvaluateStatements,\n} from \"../methods/index.js\";\n\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\n// ECMA262 13.2.13\nexport default function(\n  ast: BabelNodeBlockStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeStatement, Array<BabelNodeStatement>] {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let blockEnv be NewDeclarativeEnvironment(oldEnv).\n  let blockEnv = NewDeclarativeEnvironment(realm, oldEnv);\n\n  // 3. Perform BlockDeclarationInstantiation(StatementList, blockEnv).\n  BlockDeclarationInstantiation(realm, strictCode, ast.body, blockEnv);\n\n  // 4. Set the running execution context's LexicalEnvironment to blockEnv.\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n\n  try {\n    // 5. Let blockValue be the result of evaluating StatementList.\n    let blockValue: void | NormalCompletion | Value;\n\n    if (ast.directives) {\n      for (let directive of ast.directives) {\n        blockValue = new StringValue(realm, directive.value.value);\n      }\n    }\n\n    let [res, bAst] = PartiallyEvaluateStatements(ast.body, blockValue, strictCode, blockEnv, realm);\n    invariant(bAst.length > 0 || res instanceof EmptyValue);\n    if (bAst.length === 0) return [res, t.emptyStatement(), []];\n    let rAst = t.blockStatement(bAst, ast.directives);\n    return [res, rAst, []];\n  } finally {\n    // 6. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n}\n"]}