"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

// ECMA262 12.15 Assignment Operators


exports.default = function (ast, strictCode, env, realm) {
  var LeftHandSideExpression = ast.left;
  var AssignmentExpression = ast.right;
  var AssignmentOperator = ast.operator;

  // AssignmentExpression : LeftHandSideExpression = AssignmentExpression
  if (AssignmentOperator === "=") {
    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
    if (LeftHandSideExpression.type !== "ObjectLiteral" && LeftHandSideExpression.type !== "ArrayLiteral") {
      // a. Let lref be the result of evaluating LeftHandSideExpression.
      var _env$partiallyEvaluat = env.partiallyEvaluateCompletion(LeftHandSideExpression, strictCode),
          _env$partiallyEvaluat2 = _slicedToArray(_env$partiallyEvaluat, 3),
          _lref = _env$partiallyEvaluat2[0],
          _last = _env$partiallyEvaluat2[1],
          _lio = _env$partiallyEvaluat2[2];

      // b. ReturnIfAbrupt(lref).


      if (_lref instanceof _completions.AbruptCompletion) return [_lref, _last, _lio];
      var _leftCompletion = void 0;

      // c. Let rref be the result of evaluating AssignmentExpression.
      // d. Let rval be ? GetValue(rref).
      var _unbundleNormalComple = (0, _index2.unbundleNormalCompletion)(_lref);

      var _unbundleNormalComple2 = _slicedToArray(_unbundleNormalComple, 2);

      _leftCompletion = _unbundleNormalComple2[0];
      _lref = _unbundleNormalComple2[1];

      var _env$partiallyEvaluat3 = env.partiallyEvaluateCompletionDeref(AssignmentExpression, strictCode),
          _env$partiallyEvaluat4 = _slicedToArray(_env$partiallyEvaluat3, 3),
          _rval = _env$partiallyEvaluat4[0],
          _rast = _env$partiallyEvaluat4[1],
          _rio = _env$partiallyEvaluat4[2];

      var _io = _lio.concat(_rio);
      if (_rval instanceof _completions.AbruptCompletion) {
        return [_rval, t.assignmentExpression(ast.operator, _last, _rast), _io];
      }
      var _rightCompletion = void 0;

      var _unbundleNormalComple3 = (0, _index2.unbundleNormalCompletion)(_rval);

      var _unbundleNormalComple4 = _slicedToArray(_unbundleNormalComple3, 2);

      _rightCompletion = _unbundleNormalComple4[0];
      _rval = _unbundleNormalComple4[1];

      (0, _invariant2.default)(_rval instanceof _index.Value);

      // e. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then
      if ((0, _index2.IsAnonymousFunctionDefinition)(realm, AssignmentExpression) && (0, _index2.IsIdentifierRef)(realm, LeftHandSideExpression)) {
        (0, _invariant2.default)(_rval instanceof _index.ObjectValue);

        // i. Let hasNameProperty be ? HasOwnProperty(rval, "name").
        var hasNameProperty = (0, _index2.HasOwnProperty)(realm, _rval, "name");

        // ii. If hasNameProperty is false, perform SetFunctionName(rval, GetReferencedName(lref)).
        if (!hasNameProperty) {
          (0, _invariant2.default)(_lref instanceof _environment.Reference);
          (0, _index2.SetFunctionName)(realm, _rval, (0, _index2.GetReferencedName)(realm, _lref));
        }
      }

      // f. Perform ? PutValue(lref, rval).
      (0, _index2.PutValue)(realm, _lref, _rval);

      // g. Return rval.
      var _resultAst = t.assignmentExpression(ast.operator, _last, _rast);
      _rval = (0, _index2.composeNormalCompletions)(_leftCompletion, _rightCompletion, _rval, realm);
      return [_rval, _resultAst, _io];
    }
    throw new _errors.FatalError("Patterns aren't supported yet");
    // 2. Let assignmentPattern be the parse of the source text corresponding to LeftHandSideExpression using AssignmentPattern[?Yield] as the goal symbol.
    // 3. Let rref be the result of evaluating AssignmentExpression.
    // 4. Let rval be ? GetValue(rref).
    // 5. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.
    // 6. ReturnIfAbrupt(status).
    // 7. Return rval.
  }

  // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression

  // 1. Let lref be the result of evaluating LeftHandSideExpression.

  var _env$partiallyEvaluat5 = env.partiallyEvaluateCompletion(LeftHandSideExpression, strictCode),
      _env$partiallyEvaluat6 = _slicedToArray(_env$partiallyEvaluat5, 3),
      lref = _env$partiallyEvaluat6[0],
      last = _env$partiallyEvaluat6[1],
      lio = _env$partiallyEvaluat6[2];

  if (lref instanceof _completions.AbruptCompletion) return [lref, last, lio];
  var leftCompletion = void 0;

  // 2. Let lval be ? GetValue(lref).
  var _unbundleNormalComple5 = (0, _index2.unbundleNormalCompletion)(lref);

  var _unbundleNormalComple6 = _slicedToArray(_unbundleNormalComple5, 2);

  leftCompletion = _unbundleNormalComple6[0];
  lref = _unbundleNormalComple6[1];
  var lval = (0, _index2.GetValue)(realm, lref);

  // 3. Let rref be the result of evaluating AssignmentExpression.
  // 4. Let rval be ? GetValue(rref).

  var _env$partiallyEvaluat7 = env.partiallyEvaluateCompletionDeref(AssignmentExpression, strictCode),
      _env$partiallyEvaluat8 = _slicedToArray(_env$partiallyEvaluat7, 3),
      rval = _env$partiallyEvaluat8[0],
      rast = _env$partiallyEvaluat8[1],
      rio = _env$partiallyEvaluat8[2];

  var io = lio.concat(rio);
  if (rval instanceof _completions.AbruptCompletion) {
    return [rval, t.assignmentExpression(ast.operator, last, rast), io];
  }
  var rightCompletion = void 0;

  var _unbundleNormalComple7 = (0, _index2.unbundleNormalCompletion)(rval);

  var _unbundleNormalComple8 = _slicedToArray(_unbundleNormalComple7, 2);

  rightCompletion = _unbundleNormalComple8[0];
  rval = _unbundleNormalComple8[1];

  (0, _invariant2.default)(rval instanceof _index.Value);

  // 5. Let op be the @ where AssignmentOperator is @=.
  var op = AssignmentOperator.slice(0, -1);

  // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.
  var resultValue = void 0,
      resultAst = void 0;
  if (lval instanceof _index.ConcreteValue) {
    if (rval instanceof _index.ConcreteValue) {
      resultValue = (0, _BinaryExpression.computeBinary)(realm, op, lval, rval);
      resultAst = t.assignmentExpression(ast.operator, last, t.valueToNode(resultValue.serialize()));
    }
  }
  // if resultValue is undefined, one or both operands are abstract.
  if (resultValue === undefined && (op === "==" || op === "===" || op === "!=" || op === "!==")) {
    // When comparing to null or undefined, we can return a compile time value if we know the
    // other operand must be an object.
    if (!lval.mightNotBeObject() && (rval instanceof _index.NullValue || rval instanceof _index.UndefinedValue) || !rval.mightNotBeObject() && (lval instanceof _index.NullValue || lval instanceof _index.UndefinedValue)) {
      resultValue = new _index.BooleanValue(realm, op[0] !== "=");
      resultAst = t.assignmentExpression(ast.operator, last, t.valueToNode(resultValue.serialize()));
    }
  }
  // todo: special case if one result is known to be 0 or 1
  if (resultAst === undefined) {
    resultAst = t.assignmentExpression(ast.operator, last, rast);
  }
  return (0, _BinaryExpression2.createAbstractValueForBinary)(op, resultAst, lval, rval, last.loc, rast.loc, leftCompletion, rightCompletion, resultValue, io, realm);
};

var _BinaryExpression = require("../evaluators/BinaryExpression.js");

var _BinaryExpression2 = require("../partial-evaluators/BinaryExpression.js");

var _completions = require("../completions.js");

var _environment = require("../environment.js");

var _errors = require("../errors.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
//# sourceMappingURL=AssignmentExpression.js.map