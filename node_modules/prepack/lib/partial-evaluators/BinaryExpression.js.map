{"version":3,"sources":["../../src/partial-evaluators/BinaryExpression.js"],"names":["ast","strictCode","env","realm","partiallyEvaluateCompletionDeref","left","lval","leftAst","leftIO","leftCompletion","right","rval","rightAst","rightIO","io","concat","t","binaryExpression","operator","rightCompletion","op","resultValue","resultAst","valueToNode","serialize","undefined","mightNotBeObject","createAbstractValueForBinary","loc","lloc","rloc","resultType","val","reportIntrospectionError","createAbstract","topVal","identifier","r"],"mappings":"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","file":"BinaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelBinaryOperator,\n  BabelNodeBinaryExpression,\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeSourceLocation,\n} from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\n\nimport { computeBinary, getPureBinaryOperationResultType } from \"../evaluators/BinaryExpression.js\";\nimport { AbruptCompletion, Completion, NormalCompletion } from \"../completions.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { FatalError } from \"../errors.js\";\nimport { composeNormalCompletions, unbundleNormalCompletion } from \"../methods/index.js\";\nimport { AbstractValue, BooleanValue, ConcreteValue, NullValue, UndefinedValue, Value } from \"../values/index.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeBinaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  let [lval, leftAst, leftIO] = env.partiallyEvaluateCompletionDeref(ast.left, strictCode);\n  if (lval instanceof AbruptCompletion) return [lval, (leftAst: any), leftIO];\n  let leftCompletion;\n  [leftCompletion, lval] = unbundleNormalCompletion(lval);\n  invariant(lval instanceof Value);\n\n  let [rval, rightAst, rightIO] = env.partiallyEvaluateCompletionDeref(ast.right, strictCode);\n  let io = leftIO.concat(rightIO);\n  if (rval instanceof AbruptCompletion) {\n    // todo: if leftCompletion is a PossiblyNormalCompletion, compose\n    return [rval, t.binaryExpression(ast.operator, (leftAst: any), (rightAst: any)), io];\n  }\n  let rightCompletion;\n  [rightCompletion, rval] = unbundleNormalCompletion(rval);\n  invariant(rval instanceof Value);\n\n  let op = ast.operator;\n  let resultValue, resultAst;\n  if (lval instanceof ConcreteValue) {\n    if (rval instanceof ConcreteValue) {\n      resultValue = computeBinary(realm, op, lval, rval);\n      resultAst = t.valueToNode(resultValue.serialize());\n    }\n  }\n  // if resultValue is undefined, one or both operands are abstract.\n  if (resultValue === undefined && (op === \"==\" || op === \"===\" || op === \"!=\" || op === \"!==\")) {\n    // When comparing to null or undefined, we can return a compile time value if we know the\n    // other operand must be an object.\n    if (\n      (!lval.mightNotBeObject() && (rval instanceof NullValue || rval instanceof UndefinedValue)) ||\n      (!rval.mightNotBeObject() && (lval instanceof NullValue || lval instanceof UndefinedValue))\n    ) {\n      resultValue = new BooleanValue(realm, op[0] !== \"=\");\n      resultAst = t.valueToNode(resultValue.serialize());\n    }\n  }\n  // todo: special case if one result is known to be 0 or 1\n  if (resultAst === undefined) {\n    resultAst = t.binaryExpression(op, (leftAst: any), (rightAst: any));\n  }\n  return createAbstractValueForBinary(\n    op,\n    resultAst,\n    lval,\n    rval,\n    leftAst.loc,\n    rightAst.loc,\n    leftCompletion,\n    rightCompletion,\n    resultValue,\n    io,\n    realm\n  );\n}\n\nexport function createAbstractValueForBinary(\n  op: BabelBinaryOperator,\n  ast: BabelNodeExpression,\n  lval: Value,\n  rval: Value,\n  lloc: ?BabelNodeSourceLocation,\n  rloc: ?BabelNodeSourceLocation,\n  leftCompletion: void | NormalCompletion,\n  rightCompletion: void | NormalCompletion,\n  resultValue: void | Value,\n  io: Array<BabelNodeStatement>,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  if (resultValue === undefined) {\n    let resultType = getPureBinaryOperationResultType(realm, op, lval, rval, lloc, rloc);\n    if (resultType === undefined) {\n      // The operation may result in side effects that we cannot track.\n      // Since we have no idea what those effects are, we can either forget\n      // (havoc) everything we know at this stage, or we can fault the\n      // program and/or native model and stop evaluating.\n      // We choose to do the latter.\n      // TODO: report the error and carry on assuming no side effects.\n      let val = lval instanceof AbstractValue ? lval : rval;\n      AbstractValue.reportIntrospectionError((val: any));\n      throw new FatalError();\n    }\n    resultValue = realm.createAbstract(\n      new TypesDomain(resultType),\n      ValuesDomain.topVal,\n      [],\n      t.identifier(\"never used\")\n    );\n  }\n  let r = composeNormalCompletions(leftCompletion, rightCompletion, resultValue, realm);\n  return [r, ast, io];\n}\n"]}