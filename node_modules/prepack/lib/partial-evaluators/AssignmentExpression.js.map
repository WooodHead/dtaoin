{"version":3,"sources":["../../src/partial-evaluators/AssignmentExpression.js"],"names":["ast","strictCode","env","realm","LeftHandSideExpression","left","AssignmentExpression","right","AssignmentOperator","operator","type","partiallyEvaluateCompletion","lref","last","lio","leftCompletion","partiallyEvaluateCompletionDeref","rval","rast","rio","io","concat","t","assignmentExpression","rightCompletion","hasNameProperty","resultAst","lval","op","slice","resultValue","valueToNode","serialize","undefined","mightNotBeObject","loc"],"mappings":"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","file":"AssignmentExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelBinaryOperator,\n  BabelNodeAssignmentExpression,\n  BabelNodeExpression,\n  BabelNodeStatement,\n} from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\n\nimport { computeBinary } from \"../evaluators/BinaryExpression.js\";\nimport { createAbstractValueForBinary } from \"../partial-evaluators/BinaryExpression.js\";\nimport { AbruptCompletion, Completion } from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { BooleanValue, ConcreteValue, NullValue, ObjectValue, UndefinedValue, Value } from \"../values/index.js\";\nimport {\n  GetValue,\n  PutValue,\n  SetFunctionName,\n  IsAnonymousFunctionDefinition,\n  IsIdentifierRef,\n  HasOwnProperty,\n  GetReferencedName,\n  composeNormalCompletions,\n  unbundleNormalCompletion,\n} from \"../methods/index.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 12.15 Assignment Operators\nexport default function(\n  ast: BabelNodeAssignmentExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  let LeftHandSideExpression = ast.left;\n  let AssignmentExpression = ast.right;\n  let AssignmentOperator = ast.operator;\n\n  // AssignmentExpression : LeftHandSideExpression = AssignmentExpression\n  if (AssignmentOperator === \"=\") {\n    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then\n    if (LeftHandSideExpression.type !== \"ObjectLiteral\" && LeftHandSideExpression.type !== \"ArrayLiteral\") {\n      // a. Let lref be the result of evaluating LeftHandSideExpression.\n      let [lref, last, lio] = env.partiallyEvaluateCompletion(LeftHandSideExpression, strictCode);\n\n      // b. ReturnIfAbrupt(lref).\n      if (lref instanceof AbruptCompletion) return [lref, (last: any), lio];\n      let leftCompletion;\n      [leftCompletion, lref] = unbundleNormalCompletion(lref);\n\n      // c. Let rref be the result of evaluating AssignmentExpression.\n      // d. Let rval be ? GetValue(rref).\n      let [rval, rast, rio] = env.partiallyEvaluateCompletionDeref(AssignmentExpression, strictCode);\n      let io = lio.concat(rio);\n      if (rval instanceof AbruptCompletion) {\n        return [rval, t.assignmentExpression(ast.operator, (last: any), (rast: any)), io];\n      }\n      let rightCompletion;\n      [rightCompletion, rval] = unbundleNormalCompletion(rval);\n      invariant(rval instanceof Value);\n\n      // e. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then\n      if (\n        IsAnonymousFunctionDefinition(realm, AssignmentExpression) &&\n        IsIdentifierRef(realm, LeftHandSideExpression)\n      ) {\n        invariant(rval instanceof ObjectValue);\n\n        // i. Let hasNameProperty be ? HasOwnProperty(rval, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, rval, \"name\");\n\n        // ii. If hasNameProperty is false, perform SetFunctionName(rval, GetReferencedName(lref)).\n        if (!hasNameProperty) {\n          invariant(lref instanceof Reference);\n          SetFunctionName(realm, rval, GetReferencedName(realm, lref));\n        }\n      }\n\n      // f. Perform ? PutValue(lref, rval).\n      PutValue(realm, lref, rval);\n\n      // g. Return rval.\n      let resultAst = t.assignmentExpression(ast.operator, (last: any), (rast: any));\n      rval = composeNormalCompletions(leftCompletion, rightCompletion, rval, realm);\n      return [rval, resultAst, io];\n    }\n    throw new FatalError(\"Patterns aren't supported yet\");\n    // 2. Let assignmentPattern be the parse of the source text corresponding to LeftHandSideExpression using AssignmentPattern[?Yield] as the goal symbol.\n    // 3. Let rref be the result of evaluating AssignmentExpression.\n    // 4. Let rval be ? GetValue(rref).\n    // 5. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.\n    // 6. ReturnIfAbrupt(status).\n    // 7. Return rval.\n  }\n\n  // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression\n\n  // 1. Let lref be the result of evaluating LeftHandSideExpression.\n  let [lref, last, lio] = env.partiallyEvaluateCompletion(LeftHandSideExpression, strictCode);\n  if (lref instanceof AbruptCompletion) return [lref, (last: any), lio];\n  let leftCompletion;\n  [leftCompletion, lref] = unbundleNormalCompletion(lref);\n\n  // 2. Let lval be ? GetValue(lref).\n  let lval = GetValue(realm, lref);\n\n  // 3. Let rref be the result of evaluating AssignmentExpression.\n  // 4. Let rval be ? GetValue(rref).\n  let [rval, rast, rio] = env.partiallyEvaluateCompletionDeref(AssignmentExpression, strictCode);\n  let io = lio.concat(rio);\n  if (rval instanceof AbruptCompletion) {\n    return [rval, t.assignmentExpression(ast.operator, (last: any), (rast: any)), io];\n  }\n  let rightCompletion;\n  [rightCompletion, rval] = unbundleNormalCompletion(rval);\n  invariant(rval instanceof Value);\n\n  // 5. Let op be the @ where AssignmentOperator is @=.\n  let op = ((AssignmentOperator.slice(0, -1): any): BabelBinaryOperator);\n\n  // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.\n  let resultValue, resultAst;\n  if (lval instanceof ConcreteValue) {\n    if (rval instanceof ConcreteValue) {\n      resultValue = computeBinary(realm, op, lval, rval);\n      resultAst = t.assignmentExpression(ast.operator, (last: any), t.valueToNode(resultValue.serialize()));\n    }\n  }\n  // if resultValue is undefined, one or both operands are abstract.\n  if (resultValue === undefined && (op === \"==\" || op === \"===\" || op === \"!=\" || op === \"!==\")) {\n    // When comparing to null or undefined, we can return a compile time value if we know the\n    // other operand must be an object.\n    if (\n      (!lval.mightNotBeObject() && (rval instanceof NullValue || rval instanceof UndefinedValue)) ||\n      (!rval.mightNotBeObject() && (lval instanceof NullValue || lval instanceof UndefinedValue))\n    ) {\n      resultValue = new BooleanValue(realm, op[0] !== \"=\");\n      resultAst = t.assignmentExpression(ast.operator, (last: any), t.valueToNode(resultValue.serialize()));\n    }\n  }\n  // todo: special case if one result is known to be 0 or 1\n  if (resultAst === undefined) {\n    resultAst = t.assignmentExpression(ast.operator, (last: any), (rast: any));\n  }\n  return createAbstractValueForBinary(\n    op,\n    resultAst,\n    lval,\n    rval,\n    last.loc,\n    rast.loc,\n    leftCompletion,\n    rightCompletion,\n    resultValue,\n    io,\n    realm\n  );\n}\n"]}