{"version":3,"sources":["../../src/partial-evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","setNextExecutionContextLocation","loc","partiallyEvaluateCompletion","callee","ref","calleeAst","calleeIO","completion","value","func","io","partialArgs","argVals","arguments","arg","partiallyEvaluateCompletionDeref","argValue","argAst","argIO","concat","push","resultAst","t","callExpression","callResult","EvaluateCall","context","getRunningContext","savedCompletion","undefined","callCompletion","captureEffects","callBothFunctionsAndJoinTheirEffects","funcs","cond","func1","func2","getType","isTypeCompatibleWith","evaluateForEffects","compl1","gen1","bindings1","properties1","createdObj1","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","joinedCompletion","applyEffects","argList","kind","args","createAbstract","topVal","identifier","throwIfNotConcrete","intrinsics","eval","length","evalText","strictCaller","evalRealm","thisValue","refEnv","WithBaseObject","thisCall","tailCall","err"],"mappings":"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","file":"CallExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeCallExpression, BabelNodeExpression, BabelNodeStatement } from \"babel-types\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\n\nimport { AbruptCompletion, Completion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { EnvironmentRecord, Reference } from \"../environment.js\";\nimport {\n  composeNormalCompletions,\n  composePossiblyNormalCompletions,\n  EvaluateDirectCallWithArgList,\n  GetBase,\n  GetReferencedName,\n  GetThisValue,\n  GetValue,\n  IsInTailPosition,\n  IsPropertyReference,\n  joinEffects,\n  PerformEval,\n  SameValue,\n  stopEffectCaptureAndJoinCompletions,\n  unbundleNormalCompletion,\n  updatePossiblyNormalCompletionWithValue,\n} from \"../methods/index.js\";\nimport { AbstractValue, BooleanValue, FunctionValue, Value } from \"../values/index.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 12.3.4.1\nexport default function(\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  realm.setNextExecutionContextLocation(ast.loc);\n\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let [ref, calleeAst, calleeIO] = env.partiallyEvaluateCompletion(ast.callee, strictCode);\n  if (ref instanceof AbruptCompletion) return [ref, (calleeAst: any), calleeIO];\n  let completion;\n  if (ref instanceof PossiblyNormalCompletion) {\n    completion = ref;\n    ref = completion.value;\n  }\n  invariant(ref instanceof Value || ref instanceof Reference);\n\n  // 2. Let func be ? GetValue(ref).\n  let func = GetValue(realm, ref);\n\n  let io = calleeIO;\n  let partialArgs = [];\n  let argVals = [];\n  for (let arg of ast.arguments) {\n    let [argValue, argAst, argIO] = env.partiallyEvaluateCompletionDeref(arg, strictCode);\n    io = io.concat(argIO);\n    partialArgs.push((argAst: any));\n    if (argValue instanceof AbruptCompletion) {\n      if (completion instanceof PossiblyNormalCompletion)\n        completion = stopEffectCaptureAndJoinCompletions(completion, argValue, realm);\n      else completion = argValue;\n      let resultAst = t.callExpression((calleeAst: any), partialArgs);\n      return [completion, resultAst, io];\n    }\n    if (argValue instanceof PossiblyNormalCompletion) {\n      argVals.push(argValue.value);\n      if (completion instanceof PossiblyNormalCompletion)\n        completion = composeNormalCompletions(completion, argValue, argValue.value, realm);\n      else completion = argValue;\n    } else {\n      invariant(argValue instanceof Value);\n      argVals.push(argValue);\n    }\n  }\n\n  let callResult = EvaluateCall(ref, func, ast, argVals, strictCode, env, realm);\n  let context = realm.getRunningContext();\n  let savedCompletion = context.savedCompletion;\n  if (savedCompletion !== undefined) {\n    if (completion instanceof Value) {\n      updatePossiblyNormalCompletionWithValue(realm, savedCompletion, completion);\n      completion = savedCompletion;\n    } else if (completion instanceof PossiblyNormalCompletion) {\n      completion = composePossiblyNormalCompletions(realm, savedCompletion, completion);\n    } else {\n      invariant(completion === undefined);\n      completion = savedCompletion;\n    }\n    context.savedCompletion = undefined;\n  }\n  if (callResult instanceof AbruptCompletion) {\n    if (completion instanceof PossiblyNormalCompletion)\n      completion = stopEffectCaptureAndJoinCompletions(completion, callResult, realm);\n    else completion = callResult;\n    let resultAst = t.callExpression((calleeAst: any), partialArgs);\n    return [completion, resultAst, io];\n  }\n  let callCompletion;\n  [callCompletion, callResult] = unbundleNormalCompletion(callResult);\n  invariant(callResult instanceof Value);\n  invariant(completion === undefined || completion instanceof PossiblyNormalCompletion);\n  completion = composeNormalCompletions(completion, callCompletion, callResult, realm);\n  if (completion instanceof PossiblyNormalCompletion) {\n    realm.captureEffects();\n  }\n  return [completion, t.callExpression((calleeAst: any), partialArgs), io];\n}\n\nfunction callBothFunctionsAndJoinTheirEffects(\n  funcs: Array<Value>,\n  ast: BabelNodeCallExpression,\n  argVals: Array<Value>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Completion | Value {\n  let [cond, func1, func2] = funcs;\n  invariant(cond instanceof AbstractValue && cond.getType() === BooleanValue);\n  invariant(Value.isTypeCompatibleWith(func1.getType(), FunctionValue));\n  invariant(Value.isTypeCompatibleWith(func2.getType(), FunctionValue));\n\n  let [compl1, gen1, bindings1, properties1, createdObj1] = realm.evaluateForEffects(() =>\n    EvaluateCall(func1, func1, ast, argVals, strictCode, env, realm)\n  );\n\n  let [compl2, gen2, bindings2, properties2, createdObj2] = realm.evaluateForEffects(() =>\n    EvaluateCall(func2, func2, ast, argVals, strictCode, env, realm)\n  );\n\n  let joinedEffects = joinEffects(\n    realm,\n    cond,\n    [compl1, gen1, bindings1, properties1, createdObj1],\n    [compl2, gen2, bindings2, properties2, createdObj2]\n  );\n  let joinedCompletion = joinedEffects[0];\n  if (joinedCompletion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    realm.captureEffects();\n  }\n\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside joinedCompletion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  invariant(joinedCompletion instanceof Completion || joinedCompletion instanceof Value);\n  return joinedCompletion;\n}\n\nfunction EvaluateCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  argList: Array<Value>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Completion | Value {\n  if (func instanceof AbstractValue && Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n    if (func.kind === \"conditional\")\n      return callBothFunctionsAndJoinTheirEffects(func.args, ast, argList, strictCode, env, realm);\n\n    // The called function comes from the environmental model and we require that\n    // such functions have no visible side-effects. Hence we can carry on\n    // by returning a call node with the arguments updated with their partial counterparts.\n    // TODO: obtain the type of the return value from the abstract function.\n    return realm.createAbstract(TypesDomain.topVal, ValuesDomain.topVal, [], t.identifier(\"never used\"));\n  }\n  // If func is abstract and not known to be a safe function, we can't safely continue.\n  func = func.throwIfNotConcrete();\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (ref instanceof Reference && !IsPropertyReference(realm, ref) && GetReferencedName(realm, ref) === \"eval\") {\n    // a. If SameValue(func, %eval%) is true, then\n    if (SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      return PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n\n  try {\n    return EvaluateDirectCallWithArgList(realm, strictCode, env, ref, func, thisValue, argList, tailCall);\n  } catch (err) {\n    if (err instanceof Completion) return err;\n    throw err;\n  }\n}\n"]}