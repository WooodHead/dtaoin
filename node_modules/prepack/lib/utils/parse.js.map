{"version":3,"sources":["../../src/utils/parse.js"],"names":["realm","code","filename","sourceType","startLine","ast","node","loc","source","e","SyntaxError","referenceErrors","error","some","message","indexOf","msg","intrinsics","ReferenceError","$ErrorData","locationData","sourceCode","stackDecorated","undefined"],"mappings":";;;;;;kBAqBe,UACbA,KADa,EAEbC,IAFa,EAGbC,QAHa,EAME;AAAA,MAFfC,UAEe,uEAFU,QAEV;AAAA,MADfC,SACe,uEADK,CACL;;AACf,MAAI;AACF,QAAIC,MAAM,oBAAMJ,IAAN,EAAY,EAAEC,kBAAF,EAAYC,sBAAZ,EAAwBC,oBAAxB,EAAZ,CAAV;AACA,gCAAaC,GAAb,EAAkB,gBAAQ;AACxB,+BAAUC,KAAKC,GAAf;AACAD,WAAKC,GAAL,CAASC,MAAT,GAAkBN,QAAlB;AACA,aAAO,KAAP;AACD,KAJD;AAKA,WAAOG,GAAP;AACD,GARD,CAQE,OAAOI,CAAP,EAAU;AACV,QAAIA,aAAaC,WAAjB,EAA8B;AAC5B;AACA;AACA,UAAIC,kBAAkB,CACpB,6CADoB,EAEpB,4CAFoB,EAGpB,iDAHoB,CAAtB;;AAMA,UAAIC,cAAJ;AACA,UAAID,gBAAgBE,IAAhB,CAAqB;AAAA,eAAOJ,EAAEK,OAAF,CAAUC,OAAV,CAAkBC,GAAlB,KAA0B,CAAjC;AAAA,OAArB,CAAJ,EAA8D;AAC5DJ,gBAAQ,0BAAUZ,KAAV,EAAiBA,MAAMiB,UAAN,CAAiBC,cAAlC,EAAkD,CAAC,uBAAgBlB,KAAhB,EAAuBS,EAAEK,OAAzB,CAAD,CAAlD,CAAR;AACD,OAFD,MAEO;AACLF,gBAAQ,0BAAUZ,KAAV,EAAiBA,MAAMiB,UAAN,CAAiBP,WAAlC,EAA+C,CAAC,uBAAgBV,KAAhB,EAAuBS,EAAEK,OAAzB,CAAD,CAA/C,CAAR;AACD;AACD;AACA;AACA;AACA,+BAAUF,MAAMO,UAAhB;AACAP,YAAMO,UAAN,CAAiBC,YAAjB,GAAgC;AAC9BlB,kBAAUA,QADoB;AAE9BmB,oBAAYpB,IAFkB;AAG9BM,aAAKE,EAAEF,GAHuB;AAI9Be,wBAAgB;AAJc,OAAhC;AAMA,YAAM,iCAAoBV,KAApB,EAA2BW,SAA3B,CAAN;AACD,KA1BD,MA0BO;AACL,YAAMd,CAAN;AACD;AACF;AACF,C;;AAxDD;;;;AAGA;;AACA;;AACA;;AACA;;;;AACA","file":"parse.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport invariant from \"../invariant.js\";\nimport type { SourceType } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport { ThrowCompletion } from \"../completions.js\";\nimport { StringValue } from \"../values/index.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport { parse } from \"babylon\";\nimport type { BabelNodeFile } from \"babel-types\";\n\nexport default function(\n  realm: Realm,\n  code: string,\n  filename: string,\n  sourceType: SourceType = \"script\",\n  startLine: number = 1\n): BabelNodeFile {\n  try {\n    let ast = parse(code, { filename, sourceType, startLine });\n    traverseFast(ast, node => {\n      invariant(node.loc);\n      node.loc.source = filename;\n      return false;\n    });\n    return ast;\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Babel reports all errors as syntax errors, even if a SyntaxError should be thrown.\n      // What we do here is a totally robust way to address that issue.\n      let referenceErrors = [\n        \"Invalid left-hand side in postfix operation\",\n        \"Invalid left-hand side in prefix operation\",\n        \"Invalid left-hand side in assignment expression\",\n      ];\n\n      let error;\n      if (referenceErrors.some(msg => e.message.indexOf(msg) >= 0)) {\n        error = Construct(realm, realm.intrinsics.ReferenceError, [new StringValue(realm, e.message)]);\n      } else {\n        error = Construct(realm, realm.intrinsics.SyntaxError, [new StringValue(realm, e.message)]);\n      }\n      // These constructors are currently guaranteed to produce an object with\n      // built-in error data. Append location information about the syntax error\n      // and the source code to it so that we can use it to print nicer errors.\n      invariant(error.$ErrorData);\n      error.$ErrorData.locationData = {\n        filename: filename,\n        sourceCode: code,\n        loc: e.loc,\n        stackDecorated: false,\n      };\n      throw new ThrowCompletion(error, undefined);\n    } else {\n      throw e;\n    }\n  }\n}\n"]}