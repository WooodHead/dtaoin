{"version":3,"sources":["../../src/evaluators/AssignmentExpression.js"],"names":["ast","strictCode","env","realm","hasOwnProperty","operator","Error","LeftHandSideExpression","left","AssignmentExpression","right","AssignmentOperator","type","lref","evaluate","rref","rval","hasNameProperty","assignmentPattern","lval","op","slice","r","loc"],"mappings":";;;;;;kBA8Be,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKN;AACP,MAAI,CAACH,IAAII,cAAJ,CAAmB,UAAnB,CAAD,IAAmCJ,IAAIK,QAAJ,KAAiB,IAAxD,EAA8D,MAAMC,MAAM,qBAAN,CAAN;;AAE9D,MAAIC,yBAAyBP,IAAIQ,IAAjC;AACA,MAAIC,uBAAuBT,IAAIU,KAA/B;AACA,MAAIC,qBAAqBX,IAAIK,QAA7B;;AAEA;AACA,MAAIM,uBAAuB,GAA3B,EAAgC;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAIJ,uBAAuBK,IAAvB,KAAgC,eAAhC,IAAmDL,uBAAuBK,IAAvB,KAAgC,cAAvF,EAAuG;AACrG;AACA,UAAIC,QAAOX,IAAIY,QAAJ,CAAaP,sBAAb,EAAqCN,UAArC,CAAX;AACA;AACA;AACA,UAAIc,SAAOb,IAAIY,QAAJ,CAAaL,oBAAb,EAAmCR,UAAnC,CAAX;AACA;AACA,UAAIe,SAAO,sBAASb,KAAT,EAAgBY,MAAhB,CAAX;AACA;AACA,UACE,2CAA8BZ,KAA9B,EAAqCM,oBAArC,KACA,6BAAgBN,KAAhB,EAAuBI,sBAAvB,CAFF,EAGE;AACA,iCAAUS,oCAAV;AACA;AACA,YAAIC,kBAAkB,4BAAed,KAAf,EAAsBa,MAAtB,EAA4B,MAA5B,CAAtB;AACA;AACA,YAAI,CAACC,eAAL,EAAsB;AACpB,mCAAUJ,uCAAV;AACA,uCAAgBV,KAAhB,EAAuBa,MAAvB,EAA6B,+BAAkBb,KAAlB,EAAyBU,KAAzB,CAA7B;AACD;AACF;AACD;AACA,4BAASV,KAAT,EAAgBU,KAAhB,EAAsBG,MAAtB;AACA;AACA,aAAOA,MAAP;AACD;;AAED;AACA,QAAIE,oBAAoBX,sBAAxB;;AAEA;AACA,QAAIQ,QAAOb,IAAIY,QAAJ,CAAaL,oBAAb,EAAmCR,UAAnC,CAAX;;AAEA;AACA,QAAIe,QAAO,sBAASb,KAAT,EAAgBY,KAAhB,CAAX;;AAEA;AACA,mDAAkCZ,KAAlC,EAAyCe,iBAAzC,EAA4DF,KAA5D,EAAkEf,UAAlE,EAA8EC,GAA9E;;AAEA;;AAEA;AACA,WAAOc,KAAP;AACD;;AAED;;AAEA;AACA,MAAIH,OAAOX,IAAIY,QAAJ,CAAaP,sBAAb,EAAqCN,UAArC,CAAX;AACA;AACA,MAAIkB,OAAO,sBAAShB,KAAT,EAAgBU,IAAhB,CAAX;AACA;AACA,MAAIE,OAAOb,IAAIY,QAAJ,CAAaL,oBAAb,EAAmCR,UAAnC,CAAX;AACA;AACA,MAAIe,OAAO,sBAASb,KAAT,EAAgBY,IAAhB,CAAX;AACA;AACA,MAAIK,KAAOT,mBAAmBU,KAAnB,CAAyB,CAAzB,EAA4B,CAAC,CAA7B,CAAX;AACA;AACA,MAAIC,IAAI,sBAASnB,KAAT,EAAgB,qCAAcA,KAAd,EAAqBiB,EAArB,EAAyBD,IAAzB,EAA+BH,IAA/B,EAAqChB,IAAIQ,IAAJ,CAASe,GAA9C,EAAmDvB,IAAIU,KAAJ,CAAUa,GAA7D,CAAhB,CAAR;AACA;AACA,wBAASpB,KAAT,EAAgBU,IAAhB,EAAsBS,CAAtB;AACA;AACA,SAAOA,CAAP;AACD,C;;AApGD;;AACA;;AACA;;AAUA;;;;AAEA","file":"AssignmentExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value, ObjectValue } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport {\n  DestructuringAssignmentEvaluation,\n  GetReferencedName,\n  GetValue,\n  HasOwnProperty,\n  IsAnonymousFunctionDefinition,\n  IsIdentifierRef,\n  PutValue,\n  SetFunctionName,\n} from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeAssignmentExpression, BabelBinaryOperator } from \"babel-types\";\nimport { computeBinary } from \"./BinaryExpression.js\";\n\n// ECMA262 12.15 Assignment Operators\nexport default function(\n  ast: BabelNodeAssignmentExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (!ast.hasOwnProperty(\"operator\") || ast.operator === null) throw Error(\"Unexpected AST form\");\n\n  let LeftHandSideExpression = ast.left;\n  let AssignmentExpression = ast.right;\n  let AssignmentOperator = ast.operator;\n\n  // AssignmentExpression : LeftHandSideExpression = AssignmentExpression\n  if (AssignmentOperator === \"=\") {\n    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (LeftHandSideExpression.type !== \"ObjectPattern\" && LeftHandSideExpression.type !== \"ArrayPattern\") {\n      // a. Let lref be the result of evaluating LeftHandSideExpression.\n      let lref = env.evaluate(LeftHandSideExpression, strictCode);\n      // b. ReturnIfAbrupt(lref). -- Not neccessary\n      // c. Let rref be the result of evaluating AssignmentExpression.\n      let rref = env.evaluate(AssignmentExpression, strictCode);\n      // d. Let rval be ? GetValue(rref).\n      let rval = GetValue(realm, rref);\n      // e. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then\n      if (\n        IsAnonymousFunctionDefinition(realm, AssignmentExpression) &&\n        IsIdentifierRef(realm, LeftHandSideExpression)\n      ) {\n        invariant(rval instanceof ObjectValue);\n        // i. Let hasNameProperty be ? HasOwnProperty(rval, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, rval, \"name\");\n        // ii. If hasNameProperty is false, perform SetFunctionName(rval, GetReferencedName(lref)).\n        if (!hasNameProperty) {\n          invariant(lref instanceof Reference);\n          SetFunctionName(realm, rval, GetReferencedName(realm, lref));\n        }\n      }\n      // f. Perform ? PutValue(lref, rval).\n      PutValue(realm, lref, rval);\n      // g. Return rval.\n      return rval;\n    }\n\n    // 2. Let assignmentPattern be the parse of the source text corresponding to LeftHandSideExpression using AssignmentPattern[?Yield] as the goal symbol.\n    let assignmentPattern = LeftHandSideExpression;\n\n    // 3. Let rref be the result of evaluating AssignmentExpression.\n    let rref = env.evaluate(AssignmentExpression, strictCode);\n\n    // 4. Let rval be ? GetValue(rref).\n    let rval = GetValue(realm, rref);\n\n    // 5. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.\n    DestructuringAssignmentEvaluation(realm, assignmentPattern, rval, strictCode, env);\n\n    // 6. ReturnIfAbrupt(status).\n\n    // 7. Return rval.\n    return rval;\n  }\n\n  // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression\n\n  // 1. Let lref be the result of evaluating LeftHandSideExpression.\n  let lref = env.evaluate(LeftHandSideExpression, strictCode);\n  // 2. Let lval be ? GetValue(lref).\n  let lval = GetValue(realm, lref);\n  // 3. Let rref be the result of evaluating AssignmentExpression.\n  let rref = env.evaluate(AssignmentExpression, strictCode);\n  // 4. Let rval be ? GetValue(rref).\n  let rval = GetValue(realm, rref);\n  // 5. Let op be the @ where AssignmentOperator is @=.\n  let op = ((AssignmentOperator.slice(0, -1): any): BabelBinaryOperator);\n  // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.\n  let r = GetValue(realm, computeBinary(realm, op, lval, rval, ast.left.loc, ast.right.loc));\n  // 7. Perform ? PutValue(lref, r).\n  PutValue(realm, lref, r);\n  // 8. Return r.\n  return r;\n}\n"]}