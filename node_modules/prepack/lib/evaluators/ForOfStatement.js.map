{"version":3,"sources":["../../src/evaluators/ForOfStatement.js"],"names":["InternalGetResultValue","LoopContinues","ForInOfHeadEvaluation","ForInOfBodyEvaluation","ast","strictCode","env","realm","labelSet","left","right","body","type","kind","keyResult","declarations","id","e","target","intrinsics","undefined","value","result","completion","indexOf","BindingInstantiation","envRec","environmentRecord","name","CreateImmutableBinding","CreateMutableBinding","TDZnames","expr","iterationKind","oldEnv","getRunningContext","lexicalEnvironment","length","TDZ","TDZEnvRec","exprRef","evaluate","exprValue","empty","loc","obj","error","handleError","lhs","stmt","iterator","lhsKind","V","destructuring","nextResult","nextValue","iterationEnv","lhsRef","evaluateCompletion","names","lhsName","status","resultValue"],"mappings":"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","file":"ForOfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { Reference } from \"../environment.js\";\nimport { BreakCompletion, AbruptCompletion, ContinueCompletion } from \"../completions.js\";\nimport { AbstractValue, EmptyValue, NullValue, ObjectValue, UndefinedValue, Value } from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  InitializeReferencedBinding,\n  GetValue,\n  PutValue,\n  IteratorStep,\n  IteratorValue,\n  NewDeclarativeEnvironment,\n  ResolveBinding,\n  IteratorClose,\n  ToObjectPartial,\n  EnumerateObjectProperties,\n  UpdateEmpty,\n  BoundNames,\n  BindingInitialization,\n  DestructuringAssignmentEvaluation,\n  GetIterator,\n  IsDestructuring,\n} from \"../methods/index.js\";\nimport type {\n  BabelNode,\n  BabelNodeForOfStatement,\n  BabelNodeLVal,\n  BabelNodeStatement,\n  BabelNodeVariableDeclaration,\n} from \"babel-types\";\n\nexport type IterationKind = \"iterate\" | \"enumerate\";\nexport type LhsKind = \"lexicalBinding\" | \"varBinding\" | \"assignment\";\n\nexport function InternalGetResultValue(realm: Realm, result: Value | AbruptCompletion): Value {\n  if (result instanceof AbruptCompletion) {\n    return result.value;\n  } else {\n    return result;\n  }\n}\n\n// ECMA262 13.7.1.2\nexport function LoopContinues(realm: Realm, completion: Value | AbruptCompletion, labelSet: ?Array<string>): boolean {\n  // 1. If completion.[[Type]] is normal, return true.\n  if (completion instanceof Value) return true;\n  invariant(completion instanceof AbruptCompletion);\n\n  // 2. If completion.[[Type]] is not continue, return false.\n  if (!(completion instanceof ContinueCompletion)) return false;\n\n  // 3. If completion.[[Target]] is empty, return true.\n  if (!completion.target) return true;\n\n  // 4. If completion.[[Target]] is an element of labelSet, return true.\n  if (labelSet != null && labelSet.indexOf(completion.target) >= 0) return true;\n\n  // 5. Return false.\n  return false;\n}\n\n// ECMA262 13.7.5.10\nfunction BindingInstantiation(realm: Realm, ast: BabelNodeVariableDeclaration, env: LexicalEnvironment) {\n  // ast = ForDeclaration : LetOrConst ForBinding\n\n  // 1. Let envRec be environment's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a declarative Environment Record.\n  invariant(envRec instanceof DeclarativeEnvironmentRecord);\n\n  // 3. For each element name of the BoundNames of ForBinding do\n  for (let name of BoundNames(realm, ast)) {\n    // a. If IsConstantDeclaration of LetOrConst is true, then\n    if (ast.kind === \"const\") {\n      // i. Perform ! envRec.CreateImmutableBinding(name, true).\n      envRec.CreateImmutableBinding(name, true);\n    } else {\n      // b.\n      // i. Perform ! envRec.CreateMutableBinding(name, false).\n      envRec.CreateMutableBinding(name, false);\n    }\n  }\n}\n\n// ECMA262 13.7.5.12\nexport function ForInOfHeadEvaluation(\n  realm: Realm,\n  env: LexicalEnvironment,\n  TDZnames: Array<string>,\n  expr: BabelNode,\n  iterationKind: IterationKind,\n  strictCode: boolean\n) {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. If TDZnames is not an empty List, then\n  if (TDZnames.length) {\n    // a. Assert: TDZnames has no duplicate entries.\n\n    // b. Let TDZ be NewDeclarativeEnvironment(oldEnv).\n    let TDZ = NewDeclarativeEnvironment(realm, oldEnv);\n\n    // c. Let TDZEnvRec be TDZ's EnvironmentRecord.\n    let TDZEnvRec = TDZ.environmentRecord;\n\n    // d. For each string name in TDZnames, do\n    for (let name of TDZnames) {\n      // i. Perform ! TDZEnvRec.CreateMutableBinding(name, false).\n      TDZEnvRec.CreateMutableBinding(name, false);\n    }\n\n    // e. Set the running execution context's LexicalEnvironment to TDZ.\n    realm.getRunningContext().lexicalEnvironment = TDZ;\n    env = TDZ;\n  }\n\n  let exprRef;\n  try {\n    // 3. Let exprRef be the result of evaluating expr.\n    exprRef = env.evaluate(expr, strictCode);\n  } finally {\n    // 4. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n  env = oldEnv;\n\n  // 5. Let exprValue be ? GetValue(exprRef).\n  let exprValue = GetValue(realm, exprRef);\n\n  // 6. If iterationKind is enumerate, then\n  if (iterationKind === \"enumerate\") {\n    // a. If exprValue.[[Value]] is null or undefined, then\n    if (exprValue instanceof NullValue || exprValue instanceof UndefinedValue) {\n      // i. Return Completion{[[Type]]: break, [[Value]]: empty, [[Target]]: empty}.\n      throw new BreakCompletion(realm.intrinsics.empty, expr.loc, undefined);\n    }\n\n    // b. Let obj be ToObject(exprValue).\n    let obj = ToObjectPartial(realm, exprValue);\n\n    // c. Return ? EnumerateObjectProperties(obj).\n    if (obj instanceof AbstractValue) {\n      return obj;\n    } else {\n      return EnumerateObjectProperties(realm, obj);\n    }\n  } else {\n    // 8. Else,\n    // 1. Assert: iterationKind is iterate.\n    invariant(iterationKind === \"iterate\", \"expected iterationKind to be iterate\");\n\n    if (exprValue instanceof AbstractValue) {\n      let error = new CompilerDiagnostic(\n        \"for of loops over unknown collections are not yet supported\",\n        expr.loc,\n        \"PP0014\",\n        \"FatalError\"\n      );\n      realm.handleError(error);\n      throw new FatalError();\n    }\n\n    // 1. Return ? GetIterator(exprValue).\n    return GetIterator(realm, exprValue);\n  }\n}\n\n// ECMA262 13.7.5.13\nexport function ForInOfBodyEvaluation(\n  realm: Realm,\n  env: LexicalEnvironment,\n  lhs: BabelNodeVariableDeclaration | BabelNodeLVal,\n  stmt: BabelNodeStatement,\n  iterator: ObjectValue,\n  lhsKind: LhsKind,\n  labelSet: ?Array<string>,\n  strictCode: boolean\n): Value {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 3. Let destructuring be IsDestructuring of lhs.\n  let destructuring = IsDestructuring(lhs);\n\n  // 4. If destructuring is true and if lhsKind is assignment, then\n  if (destructuring && lhsKind === \"assignment\") {\n    // a. Assert: lhs is a LeftHandSideExpression.\n    invariant(lhs.type !== \"VariableDeclaration\");\n\n    // b. Let assignmentPattern be the parse of the source text corresponding to lhs using AssignmentPattern as the goal symbol.\n  }\n\n  // 5. Repeat\n  while (true) {\n    // a. Let nextResult be ? IteratorStep(iterator).\n    let nextResult = IteratorStep(realm, iterator);\n\n    // b. If nextResult is false, return NormalCompletion(V).\n    if (!nextResult) return V;\n\n    // c. Let nextValue be ? IteratorValue(nextResult).\n    let nextValue = IteratorValue(realm, nextResult);\n\n    // d. If lhsKind is either assignment or varBinding, then\n    let iterationEnv: void | LexicalEnvironment;\n    let lhsRef;\n    if (lhsKind === \"assignment\" || lhsKind === \"varBinding\") {\n      // i. If destructuring is false, then\n      if (!destructuring) {\n        // 1. Let lhsRef be the result of evaluating lhs. (It may be evaluated repeatedly.)\n        lhsRef = env.evaluateCompletion(lhs, strictCode);\n      }\n    } else {\n      // e. Else,\n      // i. Assert: lhsKind is lexicalBinding.\n      invariant(lhsKind === \"lexicalBinding\", \"expected lhsKind to be lexicalBinding\");\n      invariant(lhs.type === \"VariableDeclaration\");\n\n      // ii. Assert: lhs is a ForDeclaration.\n\n      // iii. Let iterationEnv be NewDeclarativeEnvironment(oldEnv).\n      iterationEnv = NewDeclarativeEnvironment(realm, oldEnv);\n\n      // iv. Perform BindingInstantiation for lhs passing iterationEnv as the argument.\n      BindingInstantiation(realm, lhs, iterationEnv);\n\n      // v. Set the running execution context's LexicalEnvironment to iterationEnv.\n      realm.getRunningContext().lexicalEnvironment = iterationEnv;\n      env = iterationEnv;\n\n      // vi. If destructuring is false, then\n      if (!destructuring) {\n        let names = BoundNames(realm, lhs);\n\n        // 1. Assert: lhs binds a single name.\n        invariant(names.length === 1, \"expected single name\");\n\n        // 2. Let lhsName be the sole element of BoundNames of lhs.\n        let lhsName = names[0];\n\n        // 3. Let lhsRef be ! ResolveBinding(lhsName).\n        lhsRef = ResolveBinding(realm, lhsName, strictCode);\n      }\n    }\n\n    // f. If destructuring is false, then\n    let status;\n    try {\n      if (!destructuring) {\n        // i. If lhsRef is an abrupt completion, then\n        if (lhsRef instanceof AbruptCompletion) {\n          // 1. Let status be lhsRef.\n          status = lhsRef;\n        } else if (lhsKind === \"lexicalBinding\") {\n          // ii. Else if lhsKind is lexicalBinding, then\n          // 1. Let status be InitializeReferencedBinding(lhsRef, nextValue).\n          invariant(lhsRef instanceof Reference);\n          status = InitializeReferencedBinding(realm, lhsRef, nextValue);\n        } else {\n          // iii. Else,\n          // 1. Let status be PutValue(lhsRef, nextValue).\n          invariant(lhsRef !== undefined);\n          status = PutValue(realm, lhsRef, nextValue);\n        }\n      } else {\n        // g. Else,\n        // i. If lhsKind is assignment, then\n        if (lhsKind === \"assignment\") {\n          invariant(lhs.type === \"ArrayPattern\" || lhs.type === \"ObjectPattern\");\n\n          // 1. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using nextValue as the argument.\n          status = DestructuringAssignmentEvaluation(realm, lhs, nextValue, strictCode, iterationEnv || env);\n        } else if (lhsKind === \"varBinding\") {\n          // ii. Else if lhsKind is varBinding, then\n          // 1. Assert: lhs is a ForBinding.\n\n          // 2. Let status be the result of performing BindingInitialization for lhs passing nextValue and undefined as the arguments.\n          status = BindingInitialization(realm, lhs, nextValue, strictCode, undefined);\n        } else {\n          // iii. Else,\n          // 1. Assert: lhsKind is lexicalBinding.\n          invariant(lhsKind === \"lexicalBinding\");\n\n          // 2. Assert: lhs is a ForDeclaration.\n\n          // 3. Let status be the result of performing BindingInitialization for lhs passing nextValue and iterationEnv as arguments.\n          invariant(iterationEnv !== undefined);\n          status = BindingInitialization(realm, lhs, nextValue, strictCode, iterationEnv);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        status = e;\n      } else {\n        throw e;\n      }\n    }\n\n    // h. If status is an abrupt completion, then\n    if (status instanceof AbruptCompletion) {\n      // i. Set the running execution context's LexicalEnvironment to oldEnv.\n      realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n      // ii. Return ? IteratorClose(iterator, status).\n      throw IteratorClose(realm, iterator, status);\n    }\n\n    // i. Let result be the result of evaluating stmt.\n    let result = env.evaluateCompletion(stmt, strictCode);\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n    // j. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    env = oldEnv;\n\n    // k. If LoopContinues(result, labelSet) is false, return ? IteratorClose(iterator, UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      result = UpdateEmpty(realm, result, V);\n      invariant(result instanceof AbruptCompletion);\n      throw IteratorClose(realm, iterator, result);\n    }\n\n    // l. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n  }\n\n  /* istanbul ignore next */\n  invariant(false); // can't get here but there is no other way to make Flow happy\n}\n\n// ECMA262 13.7.5.11\nexport default function(\n  ast: BabelNodeForOfStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { left, right, body } = ast;\n\n  try {\n    if (left.type === \"VariableDeclaration\") {\n      if (left.kind === \"var\") {\n        // for (var ForBinding o fAssignmentExpression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"iterate\", strictCode);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).\n        return ForInOfBodyEvaluation(\n          realm,\n          env,\n          left.declarations[0].id,\n          body,\n          keyResult,\n          \"varBinding\",\n          labelSet,\n          strictCode\n        );\n      } else {\n        // for (ForDeclaration of AssignmentExpression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, BoundNames(realm, left), right, \"iterate\", strictCode);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).\n        return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"lexicalBinding\", labelSet, strictCode);\n      }\n    } else {\n      // for (LeftHandSideExpression of AssignmentExpression) Statement\n      // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n      let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"iterate\", strictCode);\n      invariant(keyResult instanceof ObjectValue);\n\n      // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).\n      return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"assignment\", labelSet, strictCode);\n    }\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target) return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  }\n}\n"]}