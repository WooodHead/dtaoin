{"version":3,"sources":["../../src/evaluators/UnaryExpression.js"],"names":["ast","strictCode","env","realm","reportError","error","argument","loc","handleError","expr","evaluate","operator","value","computeAbstractly","oldValue","isNaN","intrinsics","NaN","mightNotBeTrue","false","mightNotBeFalse","true","undefined","val","proto","getType","prototype","isInstance","ref","createErrorThrowCompletion","ReferenceError","base","baseObj","deleteStatus","$Delete","TypeError","bindings","referencedName","DeleteBinding","t","Constructor","type","op","createAbstract","topVal","node","unaryExpression"],"mappings":"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","file":"UnaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport {\n  AbstractObjectValue,\n  Value,\n  BooleanValue,\n  ConcreteValue,\n  NumberValue,\n  StringValue,\n  UndefinedValue,\n  NullValue,\n  SymbolValue,\n  ObjectValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { Reference, EnvironmentRecord } from \"../environment.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  GetReferencedName,\n  GetBase,\n  GetValue,\n  ToBoolean,\n  ToObject,\n  ToNumber,\n  ToInt32,\n  IsSuperReference,\n  IsCallable,\n  IsUnresolvableReference,\n  IsStrictReference,\n  IsPropertyReference,\n  IsToNumberPure,\n} from \"../methods/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeUnaryExpression } from \"babel-types\";\n\nfunction isInstance(proto, Constructor): boolean {\n  return proto instanceof Constructor || proto === Constructor.prototype;\n}\n\nfunction computeAbstractly(realm, type, op, val) {\n  return realm.createAbstract(new TypesDomain(type), ValuesDomain.topVal, [val], ([node]) =>\n    t.unaryExpression(op, node)\n  );\n}\n\nexport default function(\n  ast: BabelNodeUnaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  function reportError() {\n    let error = new CompilerDiagnostic(\n      \"might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method\",\n      ast.argument.loc,\n      \"PP0008\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n\n  let expr = env.evaluate(ast.argument, strictCode);\n\n  if (ast.operator === \"+\") {\n    // ECMA262 12.5.6.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Return ? ToNumber(? GetValue(expr)).\n    let value = GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!IsToNumberPure(realm, value)) reportError();\n      return computeAbstractly(realm, NumberValue, \"+\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n\n    return new NumberValue(realm, ToNumber(realm, value));\n  } else if (ast.operator === \"-\") {\n    // ECMA262 12.5.7.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n    let value = GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!IsToNumberPure(realm, value)) reportError();\n      return computeAbstractly(realm, NumberValue, \"-\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = ToNumber(realm, value);\n\n    // 3. If oldValue is NaN, return NaN.\n    if (isNaN(oldValue)) {\n      return realm.intrinsics.NaN;\n    }\n\n    // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n    return new NumberValue(realm, -oldValue);\n  } else if (ast.operator === \"~\") {\n    // ECMA262 12.5.8\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n    let value = GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!IsToNumberPure(realm, value)) reportError();\n      return computeAbstractly(realm, NumberValue, \"~\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = ToInt32(realm, value);\n\n    // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n    return new NumberValue(realm, ~oldValue);\n  } else if (ast.operator === \"!\") {\n    // ECMA262 12.6.9\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n    let value = GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!value.mightNotBeTrue()) return realm.intrinsics.false;\n      if (!value.mightNotBeFalse()) return realm.intrinsics.true;\n      return computeAbstractly(realm, BooleanValue, \"!\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = ToBoolean(realm, value);\n\n    // 3. If oldValue is true, return false.\n    if (oldValue === true) return realm.intrinsics.false;\n\n    // 4. Return true.\n    return realm.intrinsics.true;\n  } else if (ast.operator === \"void\") {\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Perform ? GetValue(expr).\n    GetValue(realm, expr);\n\n    // 3. Return undefined.\n    return realm.intrinsics.undefined;\n  } else if (ast.operator === \"typeof\") {\n    // ECMA262 12.6.5\n\n    // 1. Let val be the result of evaluating UnaryExpression.\n    let val = expr;\n\n    // 2. If Type(val) is Reference, then\n    if (val instanceof Reference) {\n      // a. If IsUnresolvableReference(val) is true, return \"undefined\".\n      if (IsUnresolvableReference(realm, val)) {\n        return new StringValue(realm, \"undefined\");\n      }\n    }\n\n    // 3. Let val be ? GetValue(val).\n    val = GetValue(realm, val);\n\n    // 4. Return a String according to Table 35.\n    let proto = val.getType().prototype;\n    if (isInstance(proto, UndefinedValue)) {\n      return new StringValue(realm, \"undefined\");\n    } else if (isInstance(proto, NullValue)) {\n      return new StringValue(realm, \"object\");\n    } else if (isInstance(proto, StringValue)) {\n      return new StringValue(realm, \"string\");\n    } else if (isInstance(proto, BooleanValue)) {\n      return new StringValue(realm, \"boolean\");\n    } else if (isInstance(proto, NumberValue)) {\n      return new StringValue(realm, \"number\");\n    } else if (isInstance(proto, SymbolValue)) {\n      return new StringValue(realm, \"symbol\");\n    } else if (isInstance(proto, ObjectValue)) {\n      if (IsCallable(realm, val)) {\n        return new StringValue(realm, \"function\");\n      }\n      return new StringValue(realm, \"object\");\n    } else {\n      invariant(val instanceof AbstractValue);\n      return computeAbstractly(realm, StringValue, \"typeof\", val);\n    }\n  } else {\n    invariant(ast.operator === \"delete\");\n    // ECMA262 12.5.3.2\n\n    // 1. Let ref be the result of evaluating UnaryExpression.\n    let ref = expr;\n\n    // 2. ReturnIfAbrupt(ref).\n\n    // 3. If Type(ref) is not Reference, return true.\n    if (!(ref instanceof Reference)) return realm.intrinsics.true;\n\n    // 4. If IsUnresolvableReference(ref) is true, then\n    if (IsUnresolvableReference(realm, ref)) {\n      // a. Assert: IsStrictReference(ref) is false.\n      invariant(!IsStrictReference(realm, ref), \"did not expect a strict reference\");\n\n      // b. Return true.\n      return realm.intrinsics.true;\n    }\n\n    // 5. If IsPropertyReference(ref) is true, then\n    if (IsPropertyReference(realm, ref)) {\n      // a. If IsSuperReference(ref) is true, throw a ReferenceError exception.\n      if (IsSuperReference(realm, ref)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n\n      // b. Let baseObj be ! ToObject(GetBase(ref)).\n      let base = GetBase(realm, ref);\n      // Constructing the reference checks that base is coercible to an object hence\n      invariant(base instanceof ConcreteValue || base instanceof AbstractObjectValue);\n      let baseObj = base instanceof ConcreteValue ? ToObject(realm, base) : base;\n\n      // c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).\n      let deleteStatus = baseObj.$Delete(GetReferencedName(realm, ref));\n\n      // d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.\n      if (!deleteStatus && IsStrictReference(realm, ref)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // e. Return deleteStatus.\n      return new BooleanValue(realm, deleteStatus);\n    }\n\n    // 6. Else ref is a Reference to an Environment Record binding,\n    // a. Let bindings be GetBase(ref).\n    let bindings = GetBase(realm, ref);\n    invariant(bindings instanceof EnvironmentRecord);\n\n    // b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).\n    let referencedName = GetReferencedName(realm, ref);\n    invariant(typeof referencedName === \"string\");\n    return new BooleanValue(realm, bindings.DeleteBinding(referencedName));\n  }\n}\n"]}