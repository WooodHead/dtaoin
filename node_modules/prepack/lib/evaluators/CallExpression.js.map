{"version":3,"sources":["../../src/evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","callee","type","arguments","setNextExecutionContextLocation","loc","ref","evaluate","func","EvaluateCall","t","callBothFunctionsAndJoinTheirEffects","args","cond","func1","func2","getType","isTypeCompatibleWith","evaluateForEffects","compl1","gen1","bindings1","properties1","createdObj1","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","completion","captureEffects","applyEffects","generateRuntimeCall","concat","deriveAbstract","topVal","fun_args","nodes","slice","callExpression","property","error","handleError","kind","intrinsics","eval","argList","length","undefined","evalText","strictCaller","evalRealm","thisValue","refEnv","WithBaseObject","thisCall","tailCall"],"mappings":"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","file":"CallExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { AbruptCompletion, Completion, NormalCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { EnvironmentRecord } from \"../environment.js\";\nimport { Value } from \"../values/index.js\";\nimport { BooleanValue, ConcreteValue, AbstractValue, FunctionValue } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { PerformEval } from \"../methods/function.js\";\nimport {\n  SameValue,\n  GetValue,\n  GetThisValue,\n  GetBase,\n  IsInTailPosition,\n  IsPropertyReference,\n  joinEffects,\n  GetReferencedName,\n  EvaluateDirectCall,\n  ArgumentListEvaluation,\n} from \"../methods/index.js\";\nimport type { BabelNode, BabelNodeCallExpression, BabelNodeExpression, BabelNodeSpreadElement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport SuperCall from \"./SuperCall\";\n\nexport default function(\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Completion | Value {\n  if (ast.callee.type === \"Super\") {\n    return SuperCall(ast.arguments, strictCode, env, realm);\n  }\n\n  // ECMA262 12.3.4.1\n  realm.setNextExecutionContextLocation(ast.loc);\n\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let ref = env.evaluate(ast.callee, strictCode);\n\n  // 2. Let func be ? GetValue(ref).\n  let func = GetValue(realm, ref);\n\n  return EvaluateCall(ref, func, ast, strictCode, env, realm);\n}\n\nfunction callBothFunctionsAndJoinTheirEffects(\n  args: Array<Value>,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Completion | Value {\n  let [cond, func1, func2] = args;\n  invariant(cond instanceof AbstractValue && cond.getType() === BooleanValue);\n  invariant(Value.isTypeCompatibleWith(func1.getType(), FunctionValue));\n  invariant(Value.isTypeCompatibleWith(func2.getType(), FunctionValue));\n\n  let [compl1, gen1, bindings1, properties1, createdObj1] = realm.evaluateForEffects(() =>\n    EvaluateCall(func1, func1, ast, strictCode, env, realm)\n  );\n\n  let [compl2, gen2, bindings2, properties2, createdObj2] = realm.evaluateForEffects(() =>\n    EvaluateCall(func2, func2, ast, strictCode, env, realm)\n  );\n\n  let joinedEffects = joinEffects(\n    realm,\n    cond,\n    [compl1, gen1, bindings1, properties1, createdObj1],\n    [compl2, gen2, bindings2, properties2, createdObj2]\n  );\n  let completion = joinedEffects[0];\n  if (completion instanceof NormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    realm.captureEffects();\n  }\n\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof NormalCompletion || completion instanceof Value);\n  return completion;\n}\n\nfunction EvaluateCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Completion | Value {\n  function generateRuntimeCall() {\n    let args = [func].concat(ArgumentListEvaluation(realm, strictCode, env, ((ast.arguments: any): Array<BabelNode>)));\n    return realm.deriveAbstract(TypesDomain.topVal, ValuesDomain.topVal, args, nodes => {\n      let fun_args = ((nodes.slice(1): any): Array<BabelNodeExpression | BabelNodeSpreadElement>);\n      return t.callExpression(nodes[0], fun_args);\n    });\n  }\n\n  if (func instanceof AbstractValue) {\n    if (!Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n      let loc = ast.callee.type === \"MemberExpression\" ? ast.callee.property.loc : ast.callee.loc;\n      let error = new CompilerDiagnostic(\"might not be a function\", loc, \"PP0005\", \"RecoverableError\");\n      if (realm.handleError(error) === \"Fail\") throw new FatalError();\n    } else if (func.kind === \"conditional\") {\n      return callBothFunctionsAndJoinTheirEffects(func.args, ast, strictCode, env, realm);\n    } else {\n      // Assume that it is a safe function. TODO: really?\n    }\n    return generateRuntimeCall();\n  }\n  invariant(func instanceof ConcreteValue);\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (ref instanceof Reference && !IsPropertyReference(realm, ref) && GetReferencedName(realm, ref) === \"eval\") {\n    // a. If SameValue(func, %eval%) is true, then\n    if (SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n      let argList = ArgumentListEvaluation(realm, strictCode, env, ((ast.arguments: any): Array<BabelNode>));\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      if (evalText instanceof AbstractValue) {\n        let loc = ast.arguments[0].loc;\n        let error = new CompilerDiagnostic(\"eval argument must be a known value\", loc, \"PP0006\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n        // Assume that it is a safe eval with no visible heap changes or abrupt control flow.\n        return generateRuntimeCall();\n      }\n      return PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n  return EvaluateDirectCall(\n    realm,\n    strictCode,\n    env,\n    ref,\n    func,\n    thisValue,\n    ((ast.arguments: any): Array<BabelNode>),\n    tailCall\n  );\n}\n"]}