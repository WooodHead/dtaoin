{"version":3,"sources":["../../src/evaluators/LogicalExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","lbool","operator","rref","right","mightNotBeObject","compl1","gen1","bindings1","properties1","createdObj1","evaluateNodeForEffects","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","completion","captureEffects","applyEffects"],"mappings":";;;;;;ypBAAA;;;;;;;;;kBAqBe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKmB;AAChC,MAAIC,OAAOF,IAAIG,QAAJ,CAAaL,IAAIM,IAAjB,EAAuBL,UAAvB,CAAX;AACA,MAAIM,OAAO,sBAASJ,KAAT,EAAgBC,IAAhB,CAAX;;AAEA,MAAIG,oCAAJ,EAAmC;AACjC,QAAIC,QAAQ,uBAAUL,KAAV,EAAiBI,IAAjB,CAAZ;;AAEA,QAAIP,IAAIS,QAAJ,KAAiB,IAArB,EAA2B;AACzB;AACA,UAAID,UAAU,KAAd,EAAqB,OAAOD,IAAP;AACtB,KAHD,MAGO,IAAIP,IAAIS,QAAJ,KAAiB,IAArB,EAA2B;AAChC;AACA,UAAID,UAAU,IAAd,EAAoB,OAAOD,IAAP;AACrB;;AAED,QAAIG,OAAOR,IAAIG,QAAJ,CAAaL,IAAIW,KAAjB,EAAwBV,UAAxB,CAAX;AACA,WAAO,sBAASE,KAAT,EAAgBO,IAAhB,CAAP;AACD;AACD,2BAAUH,oCAAV;;AAEA,MAAI,CAACA,KAAKK,gBAAL,EAAL,EAA8B;AAC5B,QAAIZ,IAAIS,QAAJ,KAAiB,IAArB,EAA2B,OAAOP,IAAIG,QAAJ,CAAaL,IAAIW,KAAjB,EAAwBV,UAAxB,CAAP,CAA3B,KACK;AACH,aAAOM,IAAP;AACD;AACF;;AAED;;AA3BgC,8BA4B0B,oCAAwBJ,KAAxB,CA5B1B;AAAA;AAAA,MA4B3BU,MA5B2B;AAAA,MA4BnBC,IA5BmB;AAAA,MA4BbC,SA5Ba;AAAA,MA4BFC,WA5BE;AAAA,MA4BWC,WA5BX;;AA6BhCJ,SA7BgC,CA6BxB;;AAER;;AA/BgC,8BAgC0BV,MAAMe,sBAAN,CAA6BlB,IAAIW,KAAjC,EAAwCV,UAAxC,EAAoDC,GAApD,CAhC1B;AAAA;AAAA,MAgC3BiB,MAhC2B;AAAA,MAgCnBC,IAhCmB;AAAA,MAgCbC,SAhCa;AAAA,MAgCFC,WAhCE;AAAA,MAgCWC,WAhCX;;AAkChC;AACA;AACA;AACA;;;AACA,MAAIC,sBAAJ;AACA,MAAIxB,IAAIS,QAAJ,KAAiB,IAArB,EAA2B;AACzBe,oBAAgB,yBACdrB,KADc,EAEdI,IAFc,EAGd,CAACY,MAAD,EAASC,IAAT,EAAeC,SAAf,EAA0BC,WAA1B,EAAuCC,WAAvC,CAHc,EAId,CAAChB,IAAD,EAAOO,IAAP,EAAaC,SAAb,EAAwBC,WAAxB,EAAqCC,WAArC,CAJc,CAAhB;AAMD,GAPD,MAOO;AACLO,oBAAgB,yBACdrB,KADc,EAEdI,IAFc,EAGd,CAACA,IAAD,EAAOO,IAAP,EAAaC,SAAb,EAAwBC,WAAxB,EAAqCC,WAArC,CAHc,EAId,CAACE,MAAD,EAASC,IAAT,EAAeC,SAAf,EAA0BC,WAA1B,EAAuCC,WAAvC,CAJc,CAAhB;AAMD;AACD,MAAIE,aAAaD,cAAc,CAAd,CAAjB;AACA,MAAIC,mDAAJ,EAA4C;AAC1C;AACA;AACA;AACA;AACAtB,UAAMuB,cAAN;AACD;AACD;AACA;AACAvB,QAAMwB,YAAN,CAAmBH,aAAnB;;AAEA;AACA,MAAIC,mDAAJ,EAA4C,MAAMA,UAAN;AAC5C,2BAAUA,uDAA0CA,kCAA1C,IAAyEA,4CAAnF;AACA,SAAOA,UAAP;AACD,C;;AApFD;;AACA;;AAEA;;AACA;;AACA;;AAEA","file":"LogicalExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport { AbruptCompletion, Completion, NormalCompletion } from \"../completions.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { GetValue, joinEffects, ToBoolean } from \"../methods/index.js\";\nimport type { BabelNodeLogicalExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeLogicalExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Completion | Value | Reference {\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = GetValue(realm, lref);\n\n  if (lval instanceof ConcreteValue) {\n    let lbool = ToBoolean(realm, lval);\n\n    if (ast.operator === \"&&\") {\n      // ECMA262 12.13.3\n      if (lbool === false) return lval;\n    } else if (ast.operator === \"||\") {\n      // ECMA262 12.13.3\n      if (lbool === true) return lval;\n    }\n\n    let rref = env.evaluate(ast.right, strictCode);\n    return GetValue(realm, rref);\n  }\n  invariant(lval instanceof AbstractValue);\n\n  if (!lval.mightNotBeObject()) {\n    if (ast.operator === \"&&\") return env.evaluate(ast.right, strictCode);\n    else {\n      return lval;\n    }\n  }\n\n  // Create empty effects for the case where ast.right is not evaluated\n  let [compl1, gen1, bindings1, properties1, createdObj1] = construct_empty_effects(realm);\n  compl1; // ignore\n\n  // Evaluate ast.right in a sandbox to get its effects\n  let [compl2, gen2, bindings2, properties2, createdObj2] = realm.evaluateNodeForEffects(ast.right, strictCode, env);\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of lval.\n  // Note that converting a value to boolean never has a side effect, so we can\n  // use lval as is for the join condition.\n  let joinedEffects;\n  if (ast.operator === \"&&\") {\n    joinedEffects = joinEffects(\n      realm,\n      lval,\n      [compl2, gen2, bindings2, properties2, createdObj2],\n      [lval, gen1, bindings1, properties1, createdObj1]\n    );\n  } else {\n    joinedEffects = joinEffects(\n      realm,\n      lval,\n      [lval, gen1, bindings1, properties1, createdObj1],\n      [compl2, gen2, bindings2, properties2, createdObj2]\n    );\n  }\n  let completion = joinedEffects[0];\n  if (completion instanceof NormalCompletion) {\n    // in this case the evaluation of ast.right may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    realm.captureEffects();\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof NormalCompletion || completion instanceof Value || completion instanceof Reference);\n  return completion;\n}\n"]}