{"version":3,"sources":["../../src/evaluators/UpdateExpression.js"],"names":["ast","strictCode","env","realm","expr","evaluate","argument","oldExpr","error","loc","handleError","operator","op","newAbstractValue","createAbstract","topVal","node","t","binaryExpression","numericLiteral","prefix","oldValue","newValue"],"mappings":";;;;;;ypBAAA;;;;;;;;;kBAsBe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKN;AACP;;AAEA;AACA,MAAIC,OAAOF,IAAIG,QAAJ,CAAaL,IAAIM,QAAjB,EAA2BL,UAA3B,CAAX;;AAEA;AACA,MAAIM,UAAU,qBAASJ,KAAT,EAAgBC,IAAhB,CAAd;AACA,MAAIG,wCAAJ,EAAsC;AACpC,QAAI,CAAC,2BAAeJ,KAAf,EAAsBI,OAAtB,CAAL,EAAqC;AACnC,UAAIC,QAAQ,+BACV,iGADU,EAEVR,IAAIM,QAAJ,CAAaG,GAFH,EAGV,QAHU,EAIV,kBAJU,CAAZ;AAMA,UAAIN,MAAMO,WAAN,CAAkBF,KAAlB,MAA6B,MAAjC,EAAyC,MAAM,wBAAN;AAC1C;AACD,6BAAUR,IAAIW,QAAJ,KAAiB,IAAjB,IAAyBX,IAAIW,QAAJ,KAAiB,IAApD,EAVoC,CAUuB;AAC3D,QAAIC,KAAKZ,IAAIW,QAAJ,KAAiB,IAAjB,GAAwB,GAAxB,GAA8B,GAAvC;AACA,QAAIE,mBAAmBV,MAAMW,cAAN,CACrB,4CADqB,EAErB,qBAAaC,MAFQ,EAGrB,CAACR,OAAD,CAHqB,EAIrB;AAAA;AAAA,UAAES,IAAF;;AAAA,aAAYC,EAAEC,gBAAF,CAAmBN,EAAnB,EAAuBI,IAAvB,EAA6BC,EAAEE,cAAF,CAAiB,CAAjB,CAA7B,CAAZ;AAAA,KAJqB,CAAvB;AAMA,yBAAShB,KAAT,EAAgBC,IAAhB,EAAsBS,gBAAtB;AACA,QAAIb,IAAIoB,MAAR,EAAgB;AACd,aAAOP,gBAAP;AACD,KAFD,MAEO;AACL,aAAON,OAAP;AACD;AACF;AACD,MAAIc,WAAW,qBAASlB,KAAT,EAAgBI,OAAhB,CAAf;;AAEA,MAAIP,IAAIoB,MAAR,EAAgB;AACd,QAAIpB,IAAIW,QAAJ,KAAiB,IAArB,EAA2B;AACzB;;AAEA;AACA,UAAIW,WAAW,gBAAInB,KAAJ,EAAWkB,QAAX,EAAqB,CAArB,CAAf;;AAEA;AACA,2BAASlB,KAAT,EAAgBC,IAAhB,EAAsBkB,QAAtB;;AAEA;AACA,aAAOA,QAAP;AACD,KAXD,MAWO,IAAItB,IAAIW,QAAJ,KAAiB,IAArB,EAA2B;AAChC;;AAEA;AACA,UAAIW,YAAW,gBAAInB,KAAJ,EAAWkB,QAAX,EAAqB,CAAC,CAAtB,CAAf;;AAEA;AACA,2BAASlB,KAAT,EAAgBC,IAAhB,EAAsBkB,SAAtB;;AAEA;AACA,aAAOA,SAAP;AACD;AACD,6BAAU,KAAV;AACD,GAzBD,MAyBO;AACL,QAAItB,IAAIW,QAAJ,KAAiB,IAArB,EAA2B;AACzB;;AAEA;AACA,UAAIW,aAAW,gBAAInB,KAAJ,EAAWkB,QAAX,EAAqB,CAArB,CAAf;;AAEA;AACA,2BAASlB,KAAT,EAAgBC,IAAhB,EAAsBkB,UAAtB;;AAEA;AACA,aAAO,wBAAgBnB,KAAhB,EAAuBkB,QAAvB,CAAP;AACD,KAXD,MAWO,IAAIrB,IAAIW,QAAJ,KAAiB,IAArB,EAA2B;AAChC;;AAEA;AACA,UAAIW,aAAW,gBAAInB,KAAJ,EAAWkB,QAAX,EAAqB,CAAC,CAAtB,CAAf;;AAEA;AACA,2BAASlB,KAAT,EAAgBC,IAAhB,EAAsBkB,UAAtB;;AAEA;AACA,aAAO,wBAAgBnB,KAAhB,EAAuBkB,QAAvB,CAAP;AACD;AACD,6BAAU,KAAV;AACD;AACF,C;;AAnGD;;AACA;;AACA;;AACA;;AAEA;;;;AACA;;IAAYJ,C","file":"UpdateExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { Add, GetValue, ToNumber, PutValue, IsToNumberPure } from \"../methods/index.js\";\nimport { AbstractValue, NumberValue } from \"../values/index.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport type { BabelNodeUpdateExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\nexport default function(\n  ast: BabelNodeUpdateExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // ECMA262 12.4 Update Expressions\n\n  // Let expr be the result of evaluating UnaryExpression.\n  let expr = env.evaluate(ast.argument, strictCode);\n\n  // Let oldValue be ? ToNumber(? GetValue(expr)).\n  let oldExpr = GetValue(realm, expr);\n  if (oldExpr instanceof AbstractValue) {\n    if (!IsToNumberPure(realm, oldExpr)) {\n      let error = new CompilerDiagnostic(\n        \"might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method\",\n        ast.argument.loc,\n        \"PP0008\",\n        \"RecoverableError\"\n      );\n      if (realm.handleError(error) === \"Fail\") throw new FatalError();\n    }\n    invariant(ast.operator === \"++\" || ast.operator === \"--\"); // As per BabelNodeUpdateExpression\n    let op = ast.operator === \"++\" ? \"+\" : \"-\";\n    let newAbstractValue = realm.createAbstract(\n      new TypesDomain(NumberValue),\n      ValuesDomain.topVal,\n      [oldExpr],\n      ([node]) => t.binaryExpression(op, node, t.numericLiteral(1))\n    );\n    PutValue(realm, expr, newAbstractValue);\n    if (ast.prefix) {\n      return newAbstractValue;\n    } else {\n      return oldExpr;\n    }\n  }\n  let oldValue = ToNumber(realm, oldExpr);\n\n  if (ast.prefix) {\n    if (ast.operator === \"++\") {\n      // ECMA262 12.4.6.1\n\n      // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5)\n      let newValue = Add(realm, oldValue, 1);\n\n      // 4. Perform ? PutValue(expr, newValue).\n      PutValue(realm, expr, newValue);\n\n      // 5. Return newValue.\n      return newValue;\n    } else if (ast.operator === \"--\") {\n      // ECMA262 12.4.7.1\n\n      // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, -1);\n\n      // 4. Perform ? PutValue(expr, newValue).\n      PutValue(realm, expr, newValue);\n\n      // 5. Return newValue.\n      return newValue;\n    }\n    invariant(false);\n  } else {\n    if (ast.operator === \"++\") {\n      // ECMA262 12.4.4.1\n\n      // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, 1);\n\n      // 4. Perform ? PutValue(lhs, newValue).\n      PutValue(realm, expr, newValue);\n\n      // 5. Return oldValue.\n      return new NumberValue(realm, oldValue);\n    } else if (ast.operator === \"--\") {\n      // ECMA262 12.4.5.1\n\n      // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, -1);\n\n      // 4. Perform ? PutValue(lhs, newValue).\n      PutValue(realm, expr, newValue);\n\n      // 5. Return oldValue.\n      return new NumberValue(realm, oldValue);\n    }\n    invariant(false);\n  }\n}\n"]}