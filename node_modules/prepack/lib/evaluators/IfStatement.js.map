{"version":3,"sources":["../../src/evaluators/IfStatement.js"],"names":["evaluate","evaluateWithAbstractConditional","ast","strictCode","env","realm","exprRef","test","exprValue","stmtCompletion","evaluateCompletion","consequent","alternate","intrinsics","undefined","mightNotBeObject","condValue","evaluateNodeForEffects","compl1","gen1","bindings1","properties1","createdObj1","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","completion","captureEffects","applyEffects"],"mappings":"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","file":"IfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbruptCompletion, Completion, NormalCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { GetValue, joinEffects, ToBoolean, UpdateEmpty } from \"../methods/index.js\";\nimport type { BabelNode, BabelNodeIfStatement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport function evaluate(\n  ast: BabelNodeIfStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Completion | Value {\n  // 1. Let exprRef be the result of evaluating Expression\n  let exprRef = env.evaluate(ast.test, strictCode);\n  // 2. Let exprValue be ToBoolean(? GetValue(exprRef))\n  let exprValue = GetValue(realm, exprRef);\n\n  if (exprValue instanceof ConcreteValue) {\n    let stmtCompletion;\n    if (ToBoolean(realm, exprValue)) {\n      // 3.a. Let stmtCompletion be the result of evaluating the first Statement\n      stmtCompletion = env.evaluateCompletion(ast.consequent, strictCode);\n    } else {\n      if (ast.alternate)\n        // 4.a. Let stmtCompletion be the result of evaluating the second Statement\n        stmtCompletion = env.evaluateCompletion(ast.alternate, strictCode);\n      else\n        // 3 (of the if only statement). Return NormalCompletion(undefined)\n        stmtCompletion = realm.intrinsics.undefined;\n    }\n    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)\n    //if (stmtCompletion instanceof Reference) return stmtCompletion;\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    return stmtCompletion;\n  }\n  invariant(exprValue instanceof AbstractValue);\n\n  if (!exprValue.mightNotBeObject()) {\n    let stmtCompletion = env.evaluate(ast.consequent, strictCode);\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    return stmtCompletion;\n  } else {\n    return evaluateWithAbstractConditional(exprValue, ast.consequent, ast.alternate, strictCode, env, realm);\n  }\n}\n\nexport function evaluateWithAbstractConditional(\n  condValue: AbstractValue,\n  consequent: BabelNode,\n  alternate: ?BabelNode,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): NormalCompletion | Value {\n  // Evaluate consequent and alternate in sandboxes and get their effects.\n  let [compl1, gen1, bindings1, properties1, createdObj1] = realm.evaluateNodeForEffects(consequent, strictCode, env);\n\n  let [compl2, gen2, bindings2, properties2, createdObj2] = alternate\n    ? realm.evaluateNodeForEffects(alternate, strictCode, env)\n    : construct_empty_effects(realm);\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of condValue.\n  let joinedEffects = joinEffects(\n    realm,\n    condValue,\n    [compl1, gen1, bindings1, properties1, createdObj1],\n    [compl2, gen2, bindings2, properties2, createdObj2]\n  );\n  let completion = joinedEffects[0];\n  if (completion instanceof NormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    realm.captureEffects();\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof NormalCompletion || completion instanceof Value);\n  return completion;\n}\n"]}