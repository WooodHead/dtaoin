{"version":3,"sources":["../../src/evaluators/SwitchStatement.js"],"names":["ast","strictCode","env","realm","labelSet","expression","discriminant","cases","exprRef","evaluate","switchValue","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","CaseBlock","map","c","consequent","reduce","stmts","case_blk","concat","R","CaseBlockEvaluation","e","target","intrinsics","undefined","value","CaseSelectorEvaluation","input","EvaluateCase","r","empty","node","res","evaluateCompletion","EvaluateCaseClauses","A","V","found","C","test","clauseSelector","val","length","default_case_num","findIndex","clause","slice","foundInB","B"],"mappings":"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","file":"SwitchStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbruptCompletion, BreakCompletion } from \"../completions.js\";\nimport { InternalGetResultValue } from \"./ForOfStatement.js\";\nimport { EmptyValue, Value } from \"../values/index.js\";\nimport {\n  GetValue,\n  NewDeclarativeEnvironment,\n  BlockDeclarationInstantiation,\n  StrictEqualityComparisonPartial,\n  UpdateEmpty,\n} from \"../methods/index.js\";\nimport type { BabelNodeSwitchStatement, BabelNodeSwitchCase, BabelNodeExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\n// 13.12.10 Runtime Semantics: CaseSelectorEvaluation\nfunction CaseSelectorEvaluation(\n  expression: BabelNodeExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let exprRef be the result of evaluating Expression.\n  let exprRef = env.evaluate(expression, strictCode);\n\n  // 2. Return ? GetValue(exprRef).\n  return GetValue(realm, exprRef);\n}\n\nfunction CaseBlockEvaluation(\n  cases: Array<BabelNodeSwitchCase>,\n  input: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  let EvaluateCase = (c: BabelNodeSwitchCase): Value | AbruptCompletion => {\n    let r = realm.intrinsics.empty;\n    for (let node of c.consequent) {\n      let res = env.evaluateCompletion(node, strictCode);\n      if (res instanceof AbruptCompletion) return (UpdateEmpty(realm, res, r): any);\n      if (!(res instanceof EmptyValue)) r = res;\n    }\n    return r;\n  };\n\n  let EvaluateCaseClauses = (A: Array<BabelNodeSwitchCase>, V: Value): [boolean, Value] => {\n    // 2. Let A be the List of CaseClause items in CaseClauses, in source text order.\n    // A is passed in\n\n    // 3. Let found be false.\n    let found = false;\n\n    // 4. Repeat for each CaseClause C in A,\n    for (let C of A) {\n      // a. If found is false, then\n      if (!found) {\n        // i. Let clauseSelector be the result of CaseSelectorEvaluation of C.\n        let test = C.test;\n        invariant(test);\n        let clauseSelector = CaseSelectorEvaluation(test, strictCode, env, realm);\n\n        // ii. ReturnIfAbrupt(clauseSelector).\n        // above will throw a Completion which will return\n\n        // iii. Let found be the result of performing Strict Equality Comparison input === clauseSelector.[[Value]].\n        found = StrictEqualityComparisonPartial(realm, input, clauseSelector);\n      }\n      if (found) {\n        // b. If found is true, then\n        // i. Let R be the result of evaluating C.\n        let R = EvaluateCase(C);\n\n        // ii. If R.[[Value]] is not empty, let V be R.[[Value]].\n        let val = InternalGetResultValue(realm, R);\n        if (!(val instanceof EmptyValue)) V = val;\n\n        // iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n        if (R instanceof AbruptCompletion) {\n          throw UpdateEmpty(realm, R, V);\n        }\n      }\n    }\n    return [found, V];\n  };\n\n  // CaseBlock:{}\n  // 1. Return NormalCompletion(undefined).\n  if (cases.length === 0) return realm.intrinsics.undefined;\n\n  // CaseBlock:{CaseClauses DefaultClause CaseClauses}\n  let default_case_num = cases.findIndex(clause => {\n    return clause.test === null;\n  });\n\n  if (default_case_num !== -1) {\n    // 2. Let A be the List of CaseClause items in the first CaseClauses, in source text order. If the first CaseClauses is not present, A is « ».\n    let A = cases.slice(0, default_case_num);\n\n    let V = realm.intrinsics.undefined;\n\n    // 4. Repeat for each CaseClause C in A\n    [, V] = EvaluateCaseClauses(A, V);\n\n    // 5. Let foundInB be false.\n    let foundInB = false;\n\n    // 6. Let B be the List containing the CaseClause items in the second CaseClauses, in source text order. If the second CaseClauses is not present, B is « ».\n    let B = cases.slice(default_case_num + 1);\n\n    [foundInB, V] = EvaluateCaseClauses(B, V);\n\n    // 8. If foundInB is true, return NormalCompletion(V).\n    if (foundInB) return V;\n\n    // 9. Let R be the result of evaluating DefaultClause.\n    let R = EvaluateCase(cases[default_case_num]);\n\n    // 10. If R.[[Value]] is not empty, let V be R.[[Value]].\n    let val = InternalGetResultValue(realm, R);\n    if (!(val instanceof EmptyValue)) V = val;\n\n    // 11. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n    if (R instanceof AbruptCompletion) {\n      throw UpdateEmpty(realm, R, V);\n    }\n\n    // 12: Repeat for each CaseClause C in B (NOTE this is another complete iteration of the second CaseClauses)\n    for (let C of B) {\n      // a. Let R be the result of evaluating CaseClause C.\n      R = EvaluateCase(C);\n\n      // b. If R.[[Value]] is not empty, let V be R.[[Value]].\n      let value = InternalGetResultValue(realm, R);\n      if (!(value instanceof EmptyValue)) V = value;\n\n      // c. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n      if (R instanceof AbruptCompletion) {\n        throw UpdateEmpty(realm, R, V);\n      }\n    }\n\n    // 13. Return NormalCompletion(V).\n    return V;\n  } else {\n    // CaseBlock:{CaseClauses}\n    let V;\n    [, V] = EvaluateCaseClauses(cases, realm.intrinsics.undefined);\n    return V;\n  }\n}\n\n// 13.12.11\nexport default function(\n  ast: BabelNodeSwitchStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: Array<string>\n): Value {\n  let expression = ast.discriminant;\n  let cases: Array<BabelNodeSwitchCase> = ast.cases;\n\n  // 1. Let exprRef be the result of evaluating Expression.\n  let exprRef = env.evaluate(expression, strictCode);\n\n  // 2. Let switchValue be ? GetValue(exprRef).\n  let switchValue = GetValue(realm, exprRef);\n\n  // 3. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 4. Let blockEnv be NewDeclarativeEnvironment(oldEnv).\n  let blockEnv = NewDeclarativeEnvironment(realm, oldEnv);\n\n  // 5. Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).\n  let CaseBlock = cases.map(c => c.consequent).reduce((stmts, case_blk) => stmts.concat(case_blk), []);\n  BlockDeclarationInstantiation(realm, strictCode, CaseBlock, blockEnv);\n\n  // 6. Set the running execution context's LexicalEnvironment to blockEnv.\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n\n  let R;\n  try {\n    // 7. Let R be the result of performing CaseBlockEvaluation of CaseBlock with argument switchValue.\n    R = CaseBlockEvaluation(cases, switchValue, strictCode, blockEnv, realm);\n\n    // 9. Return R.\n    return R;\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target) return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  } finally {\n    // 8. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n}\n"]}