{"version":3,"sources":["../../src/evaluators/SuperProperty.js"],"names":["SuperProperty","MakeSuperPropertyReference","realm","propertyKey","strict","env","HasSuperBinding","createErrorThrowCompletion","intrinsics","ReferenceError","actualThis","GetThisBinding","baseValue","GetSuperBase","bv","ast","strictCode","computed","propertyNameReference","evaluate","property","propertyNameValue","name"],"mappings":";;;;;kBAgDwBA,a;;AAnCxB;;AAEA;;AACA;;AAEA;;;;;;AAEA,SAASC,0BAAT,CAAoCC,KAApC,EAAkDC,WAAlD,EAA+DC,MAA/D,EAA2F;AACzF;AACA,MAAIC,MAAM,gCAAmBH,KAAnB,CAAV;AACA,2BAAUG,qDAAV;;AAEA;AACA,MAAI,CAACA,IAAIC,eAAJ,EAAL,EAA4B;AAC1B,UAAMJ,MAAMK,0BAAN,CAAiCL,MAAMM,UAAN,CAAiBC,cAAlD,EAAkE,iCAAlE,CAAN;AACD;;AAED;AACA,MAAIC,aAAaL,IAAIM,cAAJ,EAAjB;;AAEA;;AAEA;AACA,MAAIC,YAAYP,IAAIQ,YAAJ,EAAhB;;AAEA;AACA,MAAIC,KAAK,oCAAuBZ,KAAvB,EAA8BU,SAA9B,CAAT;;AAEA;;AAEA;AACA,SAAO,2BAAcE,EAAd,EAAkBX,WAAlB,EAA+BC,MAA/B,EAAuCM,UAAvC,CAAP;AACD;;AAED;AA/CA;;;;;;;;;AAgDe,SAASV,aAAT,CACbe,GADa,EAEbC,UAFa,EAGbX,GAHa,EAIbH,KAJa,EAKF;AACX;AACA,MAAIa,IAAIE,QAAR,EAAkB;AAChB;AACA,QAAIC,wBAAwBb,IAAIc,QAAJ,CAAaJ,IAAIK,QAAjB,EAA2BJ,UAA3B,CAA5B;;AAEA;AACA,QAAIK,oBAAoB,sBAASnB,KAAT,EAAgBgB,qBAAhB,CAAxB;;AAEA;AACA,QAAIf,cAAc,kCAAqBD,KAArB,EAA4BmB,iBAA5B,CAAlB;;AAEA;;AAEA;AACA,QAAIjB,SAASY,UAAb;;AAEA;AACA,WAAOf,2BAA2BC,KAA3B,EAAkCC,WAAlC,EAA+CC,MAA/C,CAAP;AACD,GAjBD,MAiBO;AACL;AACA;AACA,QAAID,eAAc,uBAAgBD,KAAhB,EAAuBa,IAAIK,QAAJ,CAAaE,IAApC,CAAlB;;AAEA;AACA,QAAIlB,UAASY,UAAb;;AAEA;AACA,WAAOf,2BAA2BC,KAA3B,EAAkCC,YAAlC,EAA+CC,OAA/C,CAAP;AACD;AACF","file":"SuperProperty.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { FunctionEnvironmentRecord } from \"../environment.js\";\nimport { Reference } from \"../environment.js\";\nimport { StringValue } from \"../values/index.js\";\nimport { GetValue, ToPropertyKeyPartial, RequireObjectCoercible, GetThisEnvironment } from \"../methods/index.js\";\nimport type { BabelNodeMemberExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nfunction MakeSuperPropertyReference(realm: Realm, propertyKey, strict: boolean): Reference {\n  // 1. Let env be GetThisEnvironment( ).\n  let env = GetThisEnvironment(realm);\n  invariant(env instanceof FunctionEnvironmentRecord);\n\n  // 2. If env.HasSuperBinding() is false, throw a ReferenceError exception.\n  if (!env.HasSuperBinding()) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, \"env does not have super binding\");\n  }\n\n  // 3. Let actualThis be env.GetThisBinding().\n  let actualThis = env.GetThisBinding();\n\n  // 4. ReturnIfAbrupt(actualThis).\n\n  // 5. Let baseValue be env.GetSuperBase().\n  let baseValue = env.GetSuperBase();\n\n  // 6. Let bv be RequireObjectCoercible(baseValue).\n  let bv = RequireObjectCoercible(realm, baseValue);\n\n  // 7. ReturnIfAbrupt(bv).\n\n  // 8. Return a value of type Reference that is a Super Reference whose base value is bv, whose referenced name is propertyKey, whose thisValue is actualThis, and whose strict reference flag is strict.\n  return new Reference(bv, propertyKey, strict, actualThis);\n}\n\n// ECMA262 12.3.5.1\nexport default function SuperProperty(\n  ast: BabelNodeMemberExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Reference {\n  // SuperProperty : super [ Expression ]\n  if (ast.computed) {\n    // 1. Let propertyNameReference be the result of evaluating Expression.\n    let propertyNameReference = env.evaluate(ast.property, strictCode);\n\n    // 2. Let propertyNameValue be GetValue(propertyNameReference).\n    let propertyNameValue = GetValue(realm, propertyNameReference);\n\n    // 3. Let propertyKey be ToPropertyKey(propertyNameValue).\n    let propertyKey = ToPropertyKeyPartial(realm, propertyNameValue);\n\n    // 4. ReturnIfAbrupt(propertyKey).\n\n    // 5. If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.\n    let strict = strictCode;\n\n    // 6. Return MakeSuperPropertyReference(propertyKey, strict).\n    return MakeSuperPropertyReference(realm, propertyKey, strict);\n  } else {\n    // SuperProperty : super . IdentifierName\n    // 1. Let propertyKey be StringValue of IdentifierName.\n    let propertyKey = new StringValue(realm, ast.property.name);\n\n    // 2. If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.\n    let strict = strictCode;\n\n    // 3. Return MakeSuperPropertyReference(propertyKey, strict).\n    return MakeSuperPropertyReference(realm, propertyKey, strict);\n  }\n}\n"]}