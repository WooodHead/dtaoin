{"version":3,"sources":["../../src/evaluators/WithStatement.js"],"names":["ast","strictCode","env","realm","val","evaluate","object","loc","error","handleError","obj","oldEnv","newEnv","environmentRecord","withEnvironment","getRunningContext","lexicalEnvironment","C","evaluateCompletion","body","res","intrinsics","undefined"],"mappings":";;;;;;kBAqBe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKN;AACP;AACA,MAAIC,MAAMF,IAAIG,QAAJ,CAAaL,IAAIM,MAAjB,EAAyBL,UAAzB,CAAV;;AAEA;AACAG,QAAM,sBAASD,KAAT,EAAgBC,GAAhB,CAAN;AACA,MAAIA,mCAAJ,EAAkC;AAChC,QAAIG,MAAMP,IAAIM,MAAJ,CAAWC,GAArB;AACA,QAAIC,QAAQ,+BAAuB,mCAAvB,EAA4DD,GAA5D,EAAiE,QAAjE,EAA2E,kBAA3E,CAAZ;AACA,QAAIJ,MAAMM,WAAN,CAAkBD,KAAlB,MAA6B,MAAjC,EAAyC,MAAM,wBAAN;AAC1C;AACD,MAAIE,MAAM,6BAAgBP,KAAhB,EAAuBC,GAAvB,CAAV;;AAEA;AACA,MAAIO,SAAST,GAAb;;AAEA;AACA,MAAIU,SAAS,kCAAqBT,KAArB,EAA4BO,GAA5B,EAAiCC,MAAjC,CAAb;;AAEA;AACA,2BAAUC,OAAOC,iBAAP,gDAAV;AACAD,SAAOC,iBAAP,CAAyBC,eAAzB,GAA2C,IAA3C;;AAEA;AACAX,QAAMY,iBAAN,GAA0BC,kBAA1B,GAA+CJ,MAA/C;;AAEA,MAAI;AACF;AACA,QAAIK,IAAIL,OAAOM,kBAAP,CAA0BlB,IAAImB,IAA9B,EAAoClB,UAApC,CAAR;AACA,6BAAUgB,6BAAsBA,0CAAhC;;AAEA;AACA,QAAIG,MAAM,yBAAYjB,KAAZ,EAAmBc,CAAnB,EAAsBd,MAAMkB,UAAN,CAAiBC,SAAvC,CAAV;AACA,QAAIF,4CAAJ,EAAqC,MAAMA,GAAN;AACrC,6BAAUA,2BAAV;AACA,WAAOA,GAAP;AACD,GAVD,SAUU;AACR;AACAjB,UAAMY,iBAAN,GAA0BC,kBAA1B,GAA+CL,MAA/C;AACD;AACF,C;;AAtDD;;AACA;;AACA;;AACA;;AACA;;AACA","file":"WithStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport { LexicalEnvironment, ObjectEnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { AbstractValue, Value } from \"../values/index.js\";\nimport { ToObjectPartial, GetValue, NewObjectEnvironment, UpdateEmpty } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeWithStatement } from \"babel-types\";\n\n// ECMA262 13.11.7\nexport default function(\n  ast: BabelNodeWithStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let val be the result of evaluating Expression.\n  let val = env.evaluate(ast.object, strictCode);\n\n  // 2. Let obj be ? ToObject(? GetValue(val)).\n  val = GetValue(realm, val);\n  if (val instanceof AbstractValue) {\n    let loc = ast.object.loc;\n    let error = new CompilerDiagnostic(\"with object must be a known value\", loc, \"PP0007\", \"RecoverableError\");\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n  let obj = ToObjectPartial(realm, val);\n\n  // 3. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = env;\n\n  // 4. Let newEnv be NewObjectEnvironment(obj, oldEnv).\n  let newEnv = NewObjectEnvironment(realm, obj, oldEnv);\n\n  // 5. Set the withEnvironment flag of newEnv's EnvironmentRecord to true.\n  invariant(newEnv.environmentRecord instanceof ObjectEnvironmentRecord);\n  newEnv.environmentRecord.withEnvironment = true;\n\n  // 6. Set the running execution context's LexicalEnvironment to newEnv.\n  realm.getRunningContext().lexicalEnvironment = newEnv;\n\n  try {\n    // 7. Let C be the result of evaluating Statement.\n    let C = newEnv.evaluateCompletion(ast.body, strictCode);\n    invariant(C instanceof Value || C instanceof AbruptCompletion);\n\n    // 9. Return Completion(UpdateEmpty(C, undefined)).\n    let res = UpdateEmpty(realm, C, realm.intrinsics.undefined);\n    if (res instanceof AbruptCompletion) throw res;\n    invariant(res instanceof Value);\n    return res;\n  } finally {\n    // 8. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n}\n"]}