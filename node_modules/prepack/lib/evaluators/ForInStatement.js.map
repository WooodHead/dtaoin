{"version":3,"sources":["../../src/evaluators/ForInStatement.js"],"names":["ast","strictCode","env","realm","labelSet","left","right","body","reportErrorAndThrowIfNotConcrete","val","loc","reportError","type","kind","keyResult","isSimple","emitResidualLoopIfSafe","declarations","id","e","target","intrinsics","undefined","value","t","error","handleError","lh","obexpr","ob","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","envRec","environmentRecord","absStr","createAbstract","topVal","stringLiteral","boundName","n","identifier","CreateMutableBinding","InitializeBinding","evaluateNodeForEffects","compl","gen","bindings","properties","createdObj","empty","size","targetObject","sourceObject","forEach","desc","key","map","object","unknownProperty","sourceValue","cond","args","mem","condition","o","oe","values","getElements","co","generator","makeSimple","makePartial","isPartial","makeNotPartial","keyValPairs","keyVal","$Get","$Set","push","buildNode","obj","tgt","src","obj1","tgt1","src1","forInStatement","blockStatement","expressionStatement","assignmentExpression","memberExpression"],"mappings":"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","file":"ForInStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { BreakCompletion } from \"../completions.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { ForInOfHeadEvaluation, ForInOfBodyEvaluation } from \"./ForOfStatement.js\";\nimport { BoundNames, EnumerableOwnProperties, NewDeclarativeEnvironment, UpdateEmpty } from \"../methods/index.js\";\nimport {\n  AbstractValue,\n  AbstractObjectValue,\n  ArrayValue,\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeForInStatement,\n  BabelNodeSourceLocation,\n  BabelNodeStatement,\n  BabelNodeVariableDeclaration,\n} from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\n// helper func to report error\nfunction reportError(realm: Realm, loc: ?BabelNodeSourceLocation) {\n  let error = new CompilerDiagnostic(\n    \"for in loops over unknown objects are not yet supported\",\n    loc,\n    \"PP0013\",\n    \"FatalError\"\n  );\n  realm.handleError(error);\n  throw new FatalError();\n}\n\n// ECMA262 13.7.5.11\nexport default function(\n  ast: BabelNodeForInStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { left, right, body } = ast;\n\n  function reportErrorAndThrowIfNotConcrete(val: Value, loc: ?BabelNodeSourceLocation) {\n    if (val instanceof AbstractValue) reportError(realm, loc);\n  }\n\n  try {\n    if (left.type === \"VariableDeclaration\") {\n      if (left.kind === \"var\") {\n        // for (var ForBinding in Expression) Statement\n        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"enumerate\", strictCode);\n        if (keyResult instanceof AbstractObjectValue && keyResult.isSimple()) {\n          return emitResidualLoopIfSafe(ast, strictCode, env, realm, left, right, keyResult, body);\n        }\n        reportErrorAndThrowIfNotConcrete(keyResult, right.loc);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).\n        return ForInOfBodyEvaluation(\n          realm,\n          env,\n          left.declarations[0].id,\n          body,\n          keyResult,\n          \"varBinding\",\n          labelSet,\n          strictCode\n        );\n      } else {\n        // for (ForDeclaration in Expression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, BoundNames(realm, left), right, \"enumerate\", strictCode);\n        reportErrorAndThrowIfNotConcrete(keyResult, right.loc);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).\n        return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"lexicalBinding\", labelSet, strictCode);\n      }\n    } else {\n      // for (LeftHandSideExpression in Expression) Statement\n      // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n      let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"enumerate\", strictCode);\n      reportErrorAndThrowIfNotConcrete(keyResult, right.loc);\n      invariant(keyResult instanceof ObjectValue);\n\n      // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).\n      return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"assignment\", labelSet, strictCode);\n    }\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target) return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  }\n}\n\nfunction emitResidualLoopIfSafe(\n  ast: BabelNodeForInStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  lh: BabelNodeVariableDeclaration,\n  obexpr: BabelNodeExpression,\n  ob: AbstractObjectValue,\n  body: BabelNodeStatement\n) {\n  invariant(ob.isSimple());\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n  let blockEnv = NewDeclarativeEnvironment(realm, oldEnv);\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n  try {\n    let envRec = blockEnv.environmentRecord;\n    invariant(envRec instanceof DeclarativeEnvironmentRecord, \"expected declarative environment record\");\n    let absStr = realm.createAbstract(\n      new TypesDomain(StringValue),\n      ValuesDomain.topVal,\n      [],\n      t.stringLiteral(\"never used\")\n    );\n    let boundName;\n    for (let n of BoundNames(realm, lh)) {\n      invariant(boundName === undefined);\n      boundName = t.identifier(n);\n      envRec.CreateMutableBinding(n, false);\n      envRec.InitializeBinding(n, absStr);\n    }\n    let [compl, gen, bindings, properties, createdObj] = realm.evaluateNodeForEffects(body, strictCode, blockEnv);\n    if (compl instanceof Value && gen.empty() && bindings.size === 0 && properties.size === 1) {\n      invariant(createdObj.size === 0); // or there will be more than one property\n      let targetObject;\n      let sourceObject;\n      properties.forEach((desc, key, map) => {\n        if (key.object.unknownProperty === key) {\n          targetObject = key.object;\n          invariant(desc !== undefined);\n          let sourceValue = desc.value;\n          if (sourceValue instanceof AbstractValue) {\n            // because sourceValue was written to key.object.unknownProperty it must be that\n            let cond = sourceValue.args[0];\n            // and because the write always creates a value of this shape\n            invariant(cond instanceof AbstractValue && cond.kind === \"template for property name condition\");\n            if (sourceValue.args[2] instanceof UndefinedValue) {\n              // check that the value that was assigned itself came from\n              // an expression of the form sourceObject[absStr].\n              let mem = sourceValue.args[1];\n              while (mem instanceof AbstractValue) {\n                if (\n                  mem.kind === \"sentinel member expression\" &&\n                  mem.args[0] instanceof ObjectValue &&\n                  mem.args[1] === absStr\n                ) {\n                  sourceObject = mem.args[0];\n                  break;\n                }\n                // check if mem is a test for absStr being equal to a known property\n                // if so skip over it until we get to the expression of the form sourceObject[absStr].\n                let condition = mem.args[0];\n                if (condition instanceof AbstractValue && condition.kind === \"check for known property\") {\n                  if (condition.args[0] === absStr) {\n                    mem = mem.args[2];\n                    continue;\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }\n      });\n      if (targetObject instanceof ObjectValue && sourceObject !== undefined) {\n        let o;\n        let oe = ob.values.getElements();\n        if (oe.size !== 1) {\n          o = ob;\n        } else {\n          for (let co of oe) o = co;\n          invariant(o !== undefined && o.isSimple());\n        }\n        let generator = realm.generator;\n        invariant(generator !== undefined);\n        // make target object simple and partial, so that it returns a fully\n        // abstract value for every property it is queried for.\n        targetObject.makeSimple();\n        targetObject.makePartial();\n        if (sourceObject === o) {\n          // Known enumerable properties of sourceObject can become known\n          // properties of targetObject.\n          invariant(sourceObject.isPartial());\n          sourceObject.makeNotPartial();\n          // EnumerableOwnProperties is sufficient because sourceObject is simple\n          let keyValPairs = EnumerableOwnProperties(realm, sourceObject, \"key+value\");\n          sourceObject.makePartial();\n          for (let keyVal of keyValPairs) {\n            invariant(keyVal instanceof ArrayValue);\n            let key = keyVal.$Get(\"0\", keyVal);\n            let val = keyVal.$Get(\"1\", keyVal);\n            invariant(key instanceof StringValue); // sourceObject is simple\n            targetObject.$Set(key, val, targetObject);\n          }\n        }\n        // add loop to generator\n        generator.body.push({\n          // duplicate args to ensure refcount > 1\n          args: [o, targetObject, sourceObject, targetObject, sourceObject],\n          buildNode: ([obj, tgt, src, obj1, tgt1, src1]) => {\n            invariant(boundName !== undefined);\n            return t.forInStatement(\n              lh,\n              obj,\n              t.blockStatement([\n                t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.memberExpression(tgt, boundName, true),\n                    t.memberExpression(src, boundName, true)\n                  )\n                ),\n              ])\n            );\n          },\n        });\n\n        return realm.intrinsics.undefined;\n      }\n    }\n  } finally {\n    // 6. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n\n  reportError(realm, obexpr.loc);\n  invariant(false);\n}\n"]}