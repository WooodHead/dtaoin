{"version":3,"sources":["../../src/evaluators/ClassDeclaration.js"],"names":["ClassDefinitionEvaluation","ast","strictCode","env","realm","BindingClassDeclarationEvaluation","intrinsics","empty","EvaluateClassHeritage","ClassHeritage","ref","getRunningContext","lexicalEnvironment","evaluate","val","error","loc","handleError","className","lex","classScope","classScopeEnvRec","environmentRecord","undefined","CreateImmutableBinding","protoParent","constructorParent","superClass","ObjectPrototype","FunctionPrototype","superclass","null","createErrorThrowCompletion","TypeError","$FunctionKind","proto","constructor","ClassBody","body","elem","type","push","length","constructorFile","program","classDeclaration","F","constructorInfo","$Closure","$ConstructorKind","methods","m","InitializeBinding","id","name","value","hasNameProperty"],"mappings":"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","file":"ClassDeclaration.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, Value } from \"../values/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { NullValue, EmptyValue, ObjectValue, ECMAScriptFunctionValue } from \"../values/index.js\";\nimport type {\n  BabelNodeClassDeclaration,\n  BabelNodeClassExpression,\n  BabelNodeClassMethod,\n  BabelNodeExpression,\n} from \"babel-types\";\nimport parse from \"../utils/parse.js\";\nimport {\n  HasOwnProperty,\n  SetFunctionName,\n  IsConstructor,\n  Get,\n  MakeConstructor,\n  CreateMethodProperty,\n  DefineMethod,\n  NewDeclarativeEnvironment,\n  MakeClassConstructor,\n  ObjectCreate,\n  ConstructorMethod,\n  GetValue,\n  IsStatic,\n  PropertyDefinitionEvaluation,\n  InitializeBoundName,\n  NonConstructorMethodDefinitions,\n} from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\n\nfunction EvaluateClassHeritage(\n  realm: Realm,\n  ClassHeritage: BabelNodeExpression,\n  strictCode: boolean\n): ObjectValue | null {\n  let ref = realm.getRunningContext().lexicalEnvironment.evaluate(ClassHeritage, strictCode);\n  let val = GetValue(realm, ref);\n  if (val instanceof AbstractValue) {\n    let error = new CompilerDiagnostic(\"unknown super class\", ClassHeritage.loc, \"PP0009\", \"RecoverableError\");\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n  if (!(val instanceof ObjectValue)) {\n    return null;\n  }\n  return val;\n}\n\n// ECMA262 14.5.14\nexport function ClassDefinitionEvaluation(\n  realm: Realm,\n  ast: BabelNodeClassDeclaration | BabelNodeClassExpression,\n  className: string | void,\n  strictCode: boolean,\n  env: LexicalEnvironment\n) {\n  // 1. Let lex be the LexicalEnvironment of the running execution context.\n  let lex = env;\n\n  // 2. Let classScope be NewDeclarativeEnvironment(lex).\n  let classScope = NewDeclarativeEnvironment(realm, lex);\n\n  // 3. Let classScopeEnvRec be classScope’s EnvironmentRecord.\n  let classScopeEnvRec = classScope.environmentRecord;\n\n  // 4. If className is not undefined, then\n  if (className !== undefined) {\n    // a. Perform classScopeEnvRec.CreateImmutableBinding(className, true).\n    classScopeEnvRec.CreateImmutableBinding(className, true);\n  }\n\n  let protoParent;\n  let constructorParent;\n  // 5. If ClassHeritage opt is not present, then\n  let ClassHeritage = ast.superClass;\n  if (!ClassHeritage) {\n    // a. Let protoParent be the intrinsic object %ObjectPrototype%.\n    protoParent = realm.intrinsics.ObjectPrototype;\n\n    // b. Let constructorParent be the intrinsic object %FunctionPrototype%.\n    constructorParent = realm.intrinsics.FunctionPrototype;\n  } else {\n    // 6. Else\n    // a. Set the running execution context’s LexicalEnvironment to classScope.\n    realm.getRunningContext().lexicalEnvironment = classScope;\n    let superclass = null;\n    try {\n      // b. Let superclass be the result of evaluating ClassHeritage.\n      superclass = EvaluateClassHeritage(realm, ClassHeritage, strictCode);\n    } finally {\n      // c. Set the running execution context’s LexicalEnvironment to lex.\n      realm.getRunningContext().lexicalEnvironment = lex;\n    }\n\n    // d. ReturnIfAbrupt(superclass).\n\n    // e. If superclass is null, then\n    if (superclass === null) {\n      // i. Let protoParent be null.\n      protoParent = realm.intrinsics.null;\n\n      // ii. Let constructorParent be the intrinsic object %FunctionPrototype%.\n      constructorParent = realm.intrinsics.FunctionPrototype;\n    } else if (!IsConstructor(realm, superclass)) {\n      // f. Else if IsConstructor(superclass) is false, throw a TypeError exception.\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"superclass must be a constructor\");\n    } else {\n      // g. Else\n      // i. If superclass has a [[FunctionKind]] internal slot whose value is \"generator\", throw a TypeError exception.\n      if (superclass instanceof ECMAScriptFunctionValue && superclass.$FunctionKind === \"generator\") {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"superclass cannot be a generator\");\n      }\n\n      // ii. Let protoParent be Get(superclass, \"prototype\").\n      protoParent = Get(realm, superclass, \"prototype\");\n\n      // iii. ReturnIfAbrupt(protoParent).\n\n      // iv. If Type(protoParent) is neither Object nor Null, throw a TypeError exception.\n      if (!(protoParent instanceof ObjectValue || protoParent instanceof NullValue)) {\n        if (protoParent instanceof AbstractValue) {\n          let error = new CompilerDiagnostic(\n            \"unknown super class prototype\",\n            ClassHeritage.loc,\n            \"PP0010\",\n            \"RecoverableError\"\n          );\n          if (realm.handleError(error) === \"Fail\") throw new FatalError();\n          protoParent = realm.intrinsics.ObjectPrototype;\n        } else {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.TypeError,\n            \"protoParent must be an instance of Object or Null\"\n          );\n        }\n      }\n\n      // v. Let constructorParent be superclass.\n      constructorParent = superclass;\n    }\n  }\n\n  // 7. Let proto be ObjectCreate(protoParent).\n  let proto = ObjectCreate(realm, protoParent);\n\n  let constructor;\n  let ClassBody: Array<BabelNodeClassMethod> = [];\n  for (let elem of ast.body.body) {\n    if (elem.type === \"ClassMethod\") {\n      ClassBody.push(elem);\n    }\n  }\n  // 8. If ClassBody opt is not present, let constructor be empty.\n  if (ClassBody.length === 0) {\n    constructor = realm.intrinsics.empty;\n  } else {\n    // 9. Else, let constructor be ConstructorMethod of ClassBody.\n    constructor = ConstructorMethod(realm, ClassBody);\n  }\n\n  // 10. If constructor is empty, then,\n  if (constructor instanceof EmptyValue) {\n    let constructorFile;\n    // a. If ClassHeritage opt is present, then\n    if (ast.superClass) {\n      // i. Let constructor be the result of parsing the source text\n      //     constructor(... args){ super (...args);}\n      // using the syntactic grammar with the goal symbol MethodDefinition.\n      constructorFile = parse(realm, \"class NeedClassForParsing { constructor(... args){ super (...args);} }\", \"\");\n    } else {\n      // b. Else,\n      // i. Let constructor be the result of parsing the source text\n      //     constructor( ){ }\n      // using the syntactic grammar with the goal symbol MethodDefinition.\n      constructorFile = parse(realm, \"class NeedClassForParsing { constructor( ){ } }\", \"\");\n    }\n\n    let { program: { body: [classDeclaration] } } = constructorFile;\n    invariant(classDeclaration.type === \"ClassDeclaration\");\n    let { body } = ((classDeclaration: any): BabelNodeClassDeclaration);\n    invariant(body.body[0].type === \"ClassMethod\");\n    constructor = ((body.body[0]: any): BabelNodeClassMethod);\n  }\n\n  // 11. Set the running execution context’s LexicalEnvironment to classScope.\n  realm.getRunningContext().lexicalEnvironment = classScope;\n\n  let F;\n  try {\n    // 12. Let constructorInfo be the result of performing DefineMethod for constructor with arguments proto and constructorParent as the optional functionPrototype argument.\n    let constructorInfo = DefineMethod(realm, constructor, proto, env, strictCode, constructorParent);\n\n    // 13. Assert: constructorInfo is not an abrupt completion.\n\n    // 14. Let F be constructorInfo.[[closure]]\n    F = constructorInfo.$Closure;\n\n    // 15. If ClassHeritage opt is present, set F’s [[ConstructorKind]] internal slot to \"derived\".\n    if (ast.superClass) {\n      F.$ConstructorKind = \"derived\";\n    }\n\n    // 16. Perform MakeConstructor(F, false, proto).\n    MakeConstructor(realm, F, false, proto);\n\n    // 17. Perform MakeClassConstructor(F).\n    MakeClassConstructor(realm, F);\n\n    // 18. Perform CreateMethodProperty(proto, \"constructor\", F).\n    CreateMethodProperty(realm, proto, \"constructor\", F);\n\n    let methods;\n    // 19. If ClassBody opt is not present, let methods be a new empty List.\n    if (ClassBody.length === 0) {\n      methods = [];\n    } else {\n      // 20. Else, let methods be NonConstructorMethodDefinitions of ClassBody.\n      methods = NonConstructorMethodDefinitions(realm, ClassBody);\n    }\n\n    // 21. For each ClassElement m in order from methods\n    for (let m of methods) {\n      // a. If IsStatic of m is false, then\n      if (!IsStatic(m)) {\n        // Let status be the result of performing PropertyDefinitionEvaluation for m with arguments proto and false.\n        PropertyDefinitionEvaluation(realm, m, proto, env, strictCode, false);\n      } else {\n        // Else,\n        // Let status be the result of performing PropertyDefinitionEvaluation for m with arguments F and false.\n        PropertyDefinitionEvaluation(realm, m, F, env, strictCode, false);\n      }\n      // c. If status is an abrupt completion, then\n      // i. Set the running execution context's LexicalEnvironment to lex.\n      // ii. Return Completion(status).\n    }\n  } finally {\n    // 22. Set the running execution context’s LexicalEnvironment to lex.\n    realm.getRunningContext().lexicalEnvironment = lex;\n  }\n\n  // 23. If className is not undefined, then\n  if (className !== undefined) {\n    // Perform classScopeEnvRec.InitializeBinding(className, F).\n    classScopeEnvRec.InitializeBinding(className, F);\n  }\n  // Return F.\n  return F;\n}\n\n// ECMA2 14.5.15\nfunction BindingClassDeclarationEvaluation(\n  realm: Realm,\n  ast: BabelNodeClassDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment\n) {\n  // ClassDeclaration : class BindingIdentifier ClassTail\n  if (ast.id) {\n    // 1. Let className be StringValue of BindingIdentifier.\n    let className = ast.id.name;\n\n    // 2. Let value be the result of ClassDefinitionEvaluation of ClassTail with argument className.\n    let value = ClassDefinitionEvaluation(realm, ast, className, strictCode, env);\n\n    // 3. ReturnIfAbrupt(value).\n\n    // 4. Let hasNameProperty be HasOwnProperty(value, \"name\").\n    let hasNameProperty = HasOwnProperty(realm, value, \"name\");\n\n    // 5. ReturnIfAbrupt(hasNameProperty).\n\n    // 6. If hasNameProperty is false, then perform SetFunctionName(value, className).\n    if (hasNameProperty === false) {\n      SetFunctionName(realm, value, className);\n    }\n\n    // 7. Let env be the running execution context’s LexicalEnvironment.\n\n    // 8. Let status be InitializeBoundName(className, value, env).\n    InitializeBoundName(realm, className, value, env);\n\n    // 9. ReturnIfAbrupt(status).\n\n    // 10. Return value.\n    return value;\n  } else {\n    // ClassDeclaration : class ClassTail\n    // 1. Return the result of ClassDefinitionEvaluation of ClassTail with argument undefined.\n    return ClassDefinitionEvaluation(realm, ast, undefined, strictCode, env);\n  }\n}\n\n// ECMA262 14.5.16\nexport default function(\n  ast: BabelNodeClassDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let status be the result of BindingClassDeclarationEvaluation of this ClassDeclaration.\n  BindingClassDeclarationEvaluation(realm, ast, strictCode, env);\n\n  // 2. ReturnIfAbrupt(status).\n\n  // 3. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n"]}