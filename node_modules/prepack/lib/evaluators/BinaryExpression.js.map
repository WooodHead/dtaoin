{"version":3,"sources":["../../src/evaluators/BinaryExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","rref","right","rval","computeBinary","operator","loc","getPureBinaryOperationResultType","t","unknownValueOfOrToString","op","lloc","rloc","reportErrorIfNotPure","purityTest","typeIfPure","leftPure","rightPure","error","handleError","ltype","rtype","undefined","getType","mightNotBeObject","isSimple","type","createAbstract","topVal","lnode","rnode","binaryExpression","lprim","rprim","lstr","rstr","lnum","rnum","r","intrinsics","false","value","true","base","exponent","Math","pow","isNaN","NaN","createErrorThrowCompletion","TypeError"],"mappings":"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","file":"BinaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport {\n  Value,\n  AbstractValue,\n  AbstractObjectValue,\n  ConcreteValue,\n  UndefinedValue,\n  NullValue,\n  BooleanValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n} from \"../values/index.js\";\nimport { GetValue } from \"../methods/index.js\";\nimport { HasProperty, HasSomeCompatibleType } from \"../methods/index.js\";\nimport {\n  Add,\n  AbstractEqualityComparison,\n  StrictEqualityComparison,\n  AbstractRelationalComparison,\n  InstanceofOperator,\n  IsToPrimitivePure,\n  GetToPrimitivePureResultType,\n  IsToNumberPure,\n} from \"../methods/index.js\";\nimport { ToUint32, ToInt32, ToNumber, ToPrimitive, ToString, ToPropertyKey } from \"../methods/index.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeBinaryExpression, BabelBinaryOperator, BabelNodeSourceLocation } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeBinaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // evaluate left\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = GetValue(realm, lref);\n\n  // evaluate right\n  let rref = env.evaluate(ast.right, strictCode);\n  let rval = GetValue(realm, rref);\n\n  return computeBinary(realm, ast.operator, lval, rval, ast.left.loc, ast.right.loc);\n}\n\nlet unknownValueOfOrToString = \"might be an object with an unknown valueOf or toString or Symbol.toPrimitive method\";\n\n// Returns result type if binary operation is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\nexport function getPureBinaryOperationResultType(\n  realm: Realm,\n  op: BabelBinaryOperator,\n  lval: Value,\n  rval: Value,\n  lloc: ?BabelNodeSourceLocation,\n  rloc: ?BabelNodeSourceLocation\n): typeof Value {\n  function reportErrorIfNotPure(purityTest: (Realm, Value) => boolean, typeIfPure: typeof Value): typeof Value {\n    let leftPure = purityTest(realm, lval);\n    let rightPure = purityTest(realm, rval);\n    if (leftPure && rightPure) return typeIfPure;\n    let loc = !leftPure ? lloc : rloc;\n    let error = new CompilerDiagnostic(unknownValueOfOrToString, loc, \"PP0002\", \"RecoverableError\");\n    if (realm.handleError(error) === \"Recover\") {\n      // Assume that an unknown value is actually a primitive or otherwise a well behaved object.\n      return typeIfPure;\n    }\n    throw new FatalError();\n  }\n  if (op === \"+\") {\n    let ltype = GetToPrimitivePureResultType(realm, lval);\n    let rtype = GetToPrimitivePureResultType(realm, rval);\n    if (ltype === undefined || rtype === undefined) {\n      let loc = ltype === undefined ? lloc : rloc;\n      let error = new CompilerDiagnostic(unknownValueOfOrToString, loc, \"PP0002\", \"RecoverableError\");\n      if (realm.handleError(error) === \"Recover\") {\n        // Assume that the unknown value is actually a primitive or otherwise a well behaved object.\n        ltype = lval.getType();\n        rtype = rval.getType();\n        if (ltype === StringValue || rtype === StringValue) return StringValue;\n        if (ltype === NumberValue && rtype === NumberValue) return NumberValue;\n        return Value;\n      }\n      throw new FatalError();\n    }\n    if (ltype === StringValue || rtype === StringValue) return StringValue;\n    return NumberValue;\n  } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\" || op === \"!=\" || op === \"==\") {\n    return reportErrorIfNotPure(IsToPrimitivePure, BooleanValue);\n  } else if (op === \"===\" || op === \"!==\") {\n    return BooleanValue;\n  } else if (\n    op === \">>>\" ||\n    op === \"<<\" ||\n    op === \">>\" ||\n    op === \"&\" ||\n    op === \"|\" ||\n    op === \"^\" ||\n    op === \"**\" ||\n    op === \"%\" ||\n    op === \"/\" ||\n    op === \"*\" ||\n    op === \"-\"\n  ) {\n    return reportErrorIfNotPure(IsToNumberPure, NumberValue);\n  } else if (op === \"in\" || op === \"instanceof\") {\n    if (rval.mightNotBeObject()) {\n      let error = new CompilerDiagnostic(\n        `might not be an object, hence the ${op} operator might throw a TypeError`,\n        rloc,\n        \"PP0003\",\n        \"RecoverableError\"\n      );\n      if (realm.handleError(error) === \"Recover\") {\n        // Assume that the object is actually a well behaved object.\n        return BooleanValue;\n      }\n      throw new FatalError();\n    }\n    if (rval instanceof ObjectValue || rval instanceof AbstractObjectValue) {\n      // Simple object won't throw here, aren't proxy objects or typed arrays and do not have @@hasInstance properties.\n      if (rval.isSimple()) return BooleanValue;\n    }\n    let error = new CompilerDiagnostic(\n      `might be an object that behaves badly for the ${op} operator`,\n      rloc,\n      \"PP0004\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(error) === \"Recover\") {\n      // Assume that the object is actually a well behaved object.\n      return BooleanValue;\n    }\n    throw new FatalError();\n  }\n  invariant(false, \"unimplemented \" + op);\n}\n\nexport function computeBinary(\n  realm: Realm,\n  op: BabelBinaryOperator,\n  lval: Value,\n  rval: Value,\n  lloc: ?BabelNodeSourceLocation,\n  rloc: ?BabelNodeSourceLocation\n): Value {\n  // partial evaluation shortcut for a particular pattern\n  if (op === \"==\" || op === \"===\" || op === \"!=\" || op === \"!==\") {\n    if (\n      (!lval.mightNotBeObject() && HasSomeCompatibleType(rval, NullValue, UndefinedValue)) ||\n      (HasSomeCompatibleType(lval, NullValue, UndefinedValue) && !rval.mightNotBeObject())\n    )\n      return new BooleanValue(realm, op[0] !== \"=\");\n  }\n\n  if (lval instanceof AbstractValue || rval instanceof AbstractValue) {\n    let type = getPureBinaryOperationResultType(realm, op, lval, rval, lloc, rloc);\n    return realm.createAbstract(new TypesDomain(type), ValuesDomain.topVal, [lval, rval], ([lnode, rnode]) =>\n      t.binaryExpression(op, lnode, rnode)\n    );\n  }\n\n  invariant(lval instanceof ConcreteValue);\n  invariant(rval instanceof ConcreteValue);\n\n  if (op === \"+\") {\n    // ECMA262 12.8.3 The Addition Operator\n    let lprim = ToPrimitive(realm, lval);\n    let rprim = ToPrimitive(realm, rval);\n\n    if (lprim instanceof StringValue || rprim instanceof StringValue) {\n      let lstr = ToString(realm, lprim);\n      let rstr = ToString(realm, rprim);\n      return new StringValue(realm, lstr + rstr);\n    }\n\n    let lnum = ToNumber(realm, lprim);\n    let rnum = ToNumber(realm, rprim);\n    return Add(realm, lnum, rnum);\n  } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\") {\n    // ECMA262 12.10.3\n    if (op === \"<\") {\n      let r = AbstractRelationalComparison(realm, lval, rval, true);\n      if (r instanceof UndefinedValue) {\n        return realm.intrinsics.false;\n      } else {\n        return r;\n      }\n    } else if (op === \"<=\") {\n      let r = AbstractRelationalComparison(realm, rval, lval, false);\n      if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n        return realm.intrinsics.false;\n      } else {\n        return realm.intrinsics.true;\n      }\n    } else if (op === \">\") {\n      let r = AbstractRelationalComparison(realm, rval, lval, false);\n      if (r instanceof UndefinedValue) {\n        return realm.intrinsics.false;\n      } else {\n        return r;\n      }\n    } else if (op === \">=\") {\n      let r = AbstractRelationalComparison(realm, lval, rval, true);\n      if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n        return realm.intrinsics.false;\n      } else {\n        return realm.intrinsics.true;\n      }\n    }\n  } else if (op === \">>>\") {\n    // ECMA262 12.9.5.1\n    let lnum = ToUint32(realm, lval);\n    let rnum = ToUint32(realm, rval);\n\n    return new NumberValue(realm, lnum >>> rnum);\n  } else if (op === \"<<\" || op === \">>\") {\n    let lnum = ToInt32(realm, lval);\n    let rnum = ToUint32(realm, rval);\n\n    if (op === \"<<\") {\n      // ECMA262 12.9.3.1\n      return new NumberValue(realm, lnum << rnum);\n    } else if (op === \">>\") {\n      // ECMA262 12.9.4.1\n      return new NumberValue(realm, lnum >> rnum);\n    }\n  } else if (op === \"**\") {\n    // ECMA262 12.6.3\n\n    // 5. Let base be ? ToNumber(leftValue).\n    let base = ToNumber(realm, lval);\n\n    // 6. Let exponent be ? ToNumber(rightValue).\n    let exponent = ToNumber(realm, rval);\n\n    // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.7.3.4.\n    return new NumberValue(realm, Math.pow(base, exponent));\n  } else if (op === \"%\" || op === \"/\" || op === \"*\" || op === \"-\") {\n    // ECMA262 12.7.3\n    let lnum = ToNumber(realm, lval);\n    let rnum = ToNumber(realm, rval);\n\n    if (isNaN(rnum)) return realm.intrinsics.NaN;\n    if (isNaN(lnum)) return realm.intrinsics.NaN;\n\n    if (op === \"-\") {\n      return Add(realm, lnum, rnum, true);\n    } else if (op === \"%\") {\n      // The sign of the result equals the sign of the dividend.\n      // If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.\n      // If the dividend is finite and the divisor is an infinity, the result equals the dividend.\n      // If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.\n      return new NumberValue(realm, lnum % rnum);\n    } else if (op === \"/\") {\n      // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n      // Division of an infinity by an infinity results in NaN.\n      // Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.\n      // Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.\n      // Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.\n      // Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.\n      // Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.\n      return new NumberValue(realm, lnum / rnum);\n    } else if (op === \"*\") {\n      // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n      // Multiplication of an infinity by a zero results in NaN.\n      // Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.\n      // Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.\n      return new NumberValue(realm, lnum * rnum);\n    }\n  } else if (op === \"!==\") {\n    return new BooleanValue(realm, !StrictEqualityComparison(realm, lval, rval));\n  } else if (op === \"===\") {\n    return new BooleanValue(realm, StrictEqualityComparison(realm, lval, rval));\n  } else if (op === \"!=\") {\n    return new BooleanValue(realm, !AbstractEqualityComparison(realm, lval, rval));\n  } else if (op === \"==\") {\n    return new BooleanValue(realm, AbstractEqualityComparison(realm, lval, rval));\n  } else if (op === \"&\" || op === \"|\" || op === \"^\") {\n    // ECMA262 12.12.3\n\n    // 5. Let lnum be ? ToInt32(lval).\n    let lnum: number = ToInt32(realm, lval);\n\n    // 6. Let rnum be ? ToInt32(rval).\n    let rnum: number = ToInt32(realm, rval);\n\n    // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer.\n    if (op === \"&\") {\n      return new NumberValue(realm, lnum & rnum);\n    } else if (op === \"|\") {\n      return new NumberValue(realm, lnum | rnum);\n    } else if (op === \"^\") {\n      return new NumberValue(realm, lnum ^ rnum);\n    }\n  } else if (op === \"in\") {\n    // ECMA262 12.10.3\n\n    // 5. If Type(rval) is not Object, throw a TypeError exception.\n    if (!(rval instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. Return ? HasProperty(rval, ToPropertyKey(lval)).\n    return new BooleanValue(realm, HasProperty(realm, rval, ToPropertyKey(realm, lval)));\n  } else if (op === \"instanceof\") {\n    // ECMA262 12.10.3\n\n    // 5. Return ? InstanceofOperator(lval, rval).;\n    return new BooleanValue(realm, InstanceofOperator(realm, lval, rval));\n  }\n\n  invariant(false, \"unimplemented \" + op);\n}\n"]}